{"version":3,"sources":["node_modules/browser-pack/_prelude.js","feature/err/instrument/debug.js","nr-loader-dev.min.js","feature/err/instrument/index.js","feature/ins/instrument/index.js","feature/spa/instrument/index.js","feature/stn/instrument/index.js","feature/wrap-events.js","feature/wrap-fetch.js","feature/wrap-history.js","feature/wrap-jsonp.js","feature/wrap-mutation.js","feature/wrap-promise.js","feature/wrap-raf.js","feature/wrap-timer.js","feature/wrap-xhr.js","feature/xhr/instrument/distributed-tracing.js","feature/xhr/instrument/index.js","feature/xhr/instrument/parse-url.js","feature/xhr/instrument/response-size.js","loader/api.js","loader/config.js","loader/data-size.js","loader/firefox-version.js","loader/now.js","loader/protocol-allowed.js","loader/timings.js","loader/unique-id.js","loader/user-agent.js","loader/visibility.js","map-own/index.js","node_modules/lodash._slice/index.js","performance-check/index.js","ee","gos","handle","id","loader","wrap-function"],"names":["window","NREUM","__nr_require","modules","cache","entry","newRequire","name","m","exports","call","x","id","i","length","1","require","module","log","message","flags","console","err","flagArr","ee","mapOwn","localStorage","getItem","split","indexOf","dev","nrDev","on","stack","args","origThis","key","val","join","2","onerrorHandler","filename","lineno","column","errorObj","skipNext","notice","UncaughtException","e","handle","loader","now","origOnerror","apply","this","slice","arguments","sourceURL","line","doNotStamp","time","getOrSet","onerror","handleErrors","NR_ERR_PROP","disabled","features","Error","xhrWrappable","obj","methodName","thrown","3","ins","4","startTimestamp","depth","startHash","location","hash","FN_START","endTimestamp","trackURLChange","JS_TIME","FN_END","unusedArgs","hashChangedDuringCb","historyEE","emit","timestamp","type","START","END","BODY","CB_START","CB_END","FETCH","ADD_EVENT_LISTENER","win","mutationEE","promiseEE","eventsEE","timerEE","fetchEE","xhrEE","jsonpEE","baseEE","tracerEE","get","spa","buffer","5","noOp","performance","timing","getEntriesByType","rafEE","learResourceTimings","RESOURCE_TIMING_BUFFER_FULL","BST_RESOURCE","RESOURCE","BST_TIMER","PUSH_STATE","stn","origEvent","o","EV","target","evt","bstStart","bstType","startPath","pathname","document","passive","6","findAndWrapNode","object","step","hasOwnProperty","Object","getPrototypeOf","wrapNode","node","wrapFn","inPlace","REMOVE_EVENT_LISTENER","uniqueListener","XHR","XMLHttpRequest","prototype","originalListener","wrapped","wrapHandleEvent","handleEvent","listener","function","7","wrapPromiseMethod","prefix","fn","ctx","dtPayload","ctxId","dt","promise","then","bodyPrefix","bodyMethods","Req","Request","Res","Response","fetch","proto","res","size","headers","rxSize","8","history","constructor","pushState","replaceState","9","wrapElement","el","onLoad","context","removeEventListener","onError","isScript","nodeName","toLowerCase","isValidElement","addEventListener","callbackName","extractCallbackName","src","callback","discoverParent","validCallback","parent","shouldWrap","matches","match","CALLBACK_REGEX","discoverValue","longKey","VALUE_REGEX","remaining","PARENT_REGEX","domInsertMethods","Node","appendChild","HTMLElement","HTMLHeadElement","HTMLBodyElement","10","OriginalObserver","MO","MutationObserver","cb","11","WrappedPromise","executor","wrappedExecutor","promiseWrapper","OriginalPromise","getCtx","getContext","getOrSetContext","PR","Promise","forEach","method","original","subPromises","setNrId","overwrite","finalized","originalReturnValue","sub","resolve","returnVal","create","value","getOwnPropertyNames","wrapInPlace","originalThis","argsToArray","result","nextPromise","trigger","store","toString","12","equestAnimationFrame","13","interval","timer","timerDuration","isNaN","SET_TIMEOUT","SET_INTERVAL","CLEAR_TIMEOUT","DASH","14","wrapOnreadystatechange","xhr","getObject","wrapXHR","readyState","resolved","handlers","enqueuePendingXhr","pendingXhrs","push","drainPendingXhrs","setImmediate","toggle","dummyNode","data","copy","from","to","originals","OrigXHR","SI","READY_STATE_CHANGE","opts","createTextNode","observe","characterData","15","generateTracePayload","parsedOrigin","shouldGenerateTrace","nr","loader_config","accountId","accountID","agentId","agentID","trustKey","spanId","uniqueId","generateSpanId","traceId","generateTraceId","Date","payload","sameOrigin","isAllowedOrigin","useTraceContextHeadersForCors","traceContextParentHeader","generateTraceContextParentHeader","traceContextStateHeader","generateTraceContextStateHeader","excludeNewrelicHeader","useNewrelicHeaderForCors","newrelicHeader","generateTraceHeader","appId","version","transactionId","parentType","sampled","priority","hasBtoa","btoa","v","d","ty","ac","ap","tr","ti","tk","JSON","stringify","isDtEnabled","allowed","dtConfig","init","distributed_tracing","allowed_origins","Array","allowedOrigin","parseUrl","hostname","protocol","port","enabled","exclude_newrelic_header","cors_use_newrelic_header","cors_use_tracecontext_headers","16","end","params","metrics","ended","handlersLen","aborted","duration","startTime","loadCaptureCalled","status","captureXhrData","cbTime","addUrl","url","parsed","host","responseSizeFromXhr","lastSize","header","getResponseHeader","cat","pop","ffVersion","dataSize","origXHR","totalCbs","called","xhrGuids","event","opera","loaded","setRequestHeader","xpid","added","txSize","onloadCalled","onload","useCapture","idString","xhrCbStart","addHeaders","headersObj","set","URL","href","clone","Headers","17","stringsToParsedUrls","urlEl","createElement","ret","firstSplit","charAt","sameProtocol","sameDomain","domain","18","responseType","response","undefined","responseText","19","InteractionHandle","apiCall","notSpa","bufferGroup","concat","newrelic","asyncApiFns","spaPrefix","num","fnName","addPageAction","setCurrentRouteName","interaction","InteractionApiProto","createTracer","contextStore","ixn","hasCb","n","noticeError","customAttributes","20","getConfiguration","path","parts","21","ArrayBuffer","byteLength","Blob","FormData","22","navigator","userAgent","23","performanceCheck","exists","Math","round","lastTimestamp","max","getTime","offset","getLastTimestamp","24","protocolAllowed","25","perfObserver","list","observer","entries","getEntries","floor","lcpObserver","clsObserver","hadRecentInput","captureInteraction","fiRecorded","fi","timeStamp","attributes","captureVisibilityChange","state","page_view_timing","performanceObserver","lcpPerformanceObserver","clsPerformanceObserver","subscribeToVisibilityChange","PerformanceObserver","entryTypes","buffered","allowedEventTypes","26","generateUuid","getRandomValue","randomVals","rvIndex","random","crypto","msCrypto","getRandomValues","Uint8Array","c","template","generateRandomHexString","chars","27","agentName","agentVersion","detectedParts","requestedParts","safari","agent","28","handleVisibilityChange","hidden","eventName","msHidden","webkitHidden","29","results","has","30","array","start","index","31","EventContext","old","contextOrStore","getNewContext","force","bubble","handlersArray","listeners","len","eventBuffer","bufferGroupMap","emitter","splice","getOrCreate","emitters","bufferEventsByGroup","types","group","abort","abortIfNotLoaded","api","feature","backlog","gos","prop","getVal","defineProperty","keys","writable","enumerable","windowLoaded","loadFired","info","exp","firstScript","doc","getElementsByTagName","setTimeout","licenseKey","applicationID","defInfo","ts","scheme","parentNode","insertBefore","stateChange","config","ATTACH_EVENT","XHR_PROTO","ST","CT","clearTimeout","REQ","Event","origin","beacon","errorBeacon","test","wrap-function","createWrapperWithEmitter","always","nrWrapper","report","safeEmit","notWrappable","flag","methods","prependMethodPrefix","arr","inWrapper","prev","Function","wrapFunction","wrapper"],"mappings":"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","file":"nr-loader-dev.min.js","sourcesContent":["// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requireuires ]\n//\n// map of requireuires is short require name -> numeric require\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  function newRequire (name) {\n    if (!cache[name]) {\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n\n  // If there is already an agent on the page, use it instead.\n  if (typeof __nr_require === 'function') return __nr_require\n\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  return newRequire\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar mapOwn = require(29)\nvar flags = {}\nvar flagArr\n\ntry {\n  flagArr = localStorage.getItem('__nr_flags').split(',')\n  if (console && typeof console.log === 'function') {\n    flags.console = true\n    if (flagArr.indexOf('dev') !== -1) flags.dev = true\n    if (flagArr.indexOf('nr_dev') !== -1) flags.nrDev = true\n  }\n} catch (err) {\n // no op\n}\n\nif (flags.nrDev) ee.on('internal-error', function (err) { log(err.stack) })\nif (flags.dev) ee.on('fn-err', function (args, origThis, err) { log(err.stack) })\nif (flags.dev) {\n  log('NR AGENT IN DEVELOPMENT MODE')\n  log('flags: ' + mapOwn(flags, function (key, val) { return key }).join(', '))\n}\n\nfunction log (message) {\n  try {\n    if (flags.console) console.log(message)\n  } catch (err) {\n    // no op\n  }\n}\n","window.NREUM || (NREUM={});__nr_require=// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requireuires ]\n//\n// map of requireuires is short require name -> numeric require\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  function newRequire (name) {\n    if (!cache[name]) {\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n\n  // If there is already an agent on the page, use it instead.\n  if (typeof __nr_require === 'function') return __nr_require\n\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  return newRequire\n})\n({1:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar mapOwn = require(29)\nvar flags = {}\nvar flagArr\n\ntry {\n  flagArr = localStorage.getItem('__nr_flags').split(',')\n  if (console && typeof console.log === 'function') {\n    flags.console = true\n    if (flagArr.indexOf('dev') !== -1) flags.dev = true\n    if (flagArr.indexOf('nr_dev') !== -1) flags.nrDev = true\n  }\n} catch (err) {\n // no op\n}\n\nif (flags.nrDev) ee.on('internal-error', function (err) { log(err.stack) })\nif (flags.dev) ee.on('fn-err', function (args, origThis, err) { log(err.stack) })\nif (flags.dev) {\n  log('NR AGENT IN DEVELOPMENT MODE')\n  log('flags: ' + mapOwn(flags, function (key, val) { return key }).join(', '))\n}\n\nfunction log (message) {\n  try {\n    if (flags.console) console.log(message)\n  } catch (err) {\n    // no op\n  }\n}\n\n},{}],2:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handle = require(\"handle\")\nvar slice = require(30)\nvar ee = require(\"ee\")\nvar loader = require(\"loader\")\nvar getOrSet = require(\"gos\")\nvar origOnerror = window.onerror\nvar handleErrors = false\nvar NR_ERR_PROP = 'nr@seenError'\n\nif (loader.disabled) return\n\n// skipNext counter to keep track of uncaught\n// errors that will be the same as caught errors.\nvar skipNext = 0\n\n// Declare that we are using err instrumentation\nloader.features.err = true\nrequire(1)\n\nwindow.onerror = onerrorHandler\n\ntry {\n  throw new Error()\n} catch (e) {\n  // Only wrap stuff if try/catch gives us useful data. It doesn't in IE < 10.\n  if ('stack' in e) {\n    require(13)\n    require(12)\n\n    if ('addEventListener' in window) {\n      require(6)\n    }\n\n    if (loader.xhrWrappable) {\n      require(14)\n    }\n\n    handleErrors = true\n  }\n}\n\nee.on('fn-start', function (args, obj, methodName) {\n  if (handleErrors) skipNext += 1\n})\n\nee.on('fn-err', function (args, obj, err) {\n  if (handleErrors && !err[NR_ERR_PROP]) {\n    getOrSet(err, NR_ERR_PROP, function getVal () {\n      return true\n    })\n    this.thrown = true\n    notice(err)\n  }\n})\n\nee.on('fn-end', function () {\n  if (!handleErrors) return\n  if (!this.thrown && skipNext > 0) skipNext -= 1\n})\n\nee.on('internal-error', function (e) {\n  handle('ierr', [e, loader.now(), true])\n})\n\n// FF and Android browsers do not provide error info to the 'error' event callback,\n// so we must use window.onerror\nfunction onerrorHandler (message, filename, lineno, column, errorObj) {\n  try {\n    if (skipNext) skipNext -= 1\n    else notice(errorObj || new UncaughtException(message, filename, lineno), true)\n  } catch (e) {\n    try {\n      handle('ierr', [e, loader.now(), true])\n    } catch (err) {\n    }\n  }\n\n  if (typeof origOnerror === 'function') return origOnerror.apply(this, slice(arguments))\n  return false\n}\n\nfunction UncaughtException (message, filename, lineno) {\n  this.message = message || 'Uncaught error with no additional information'\n  this.sourceURL = filename\n  this.line = lineno\n}\n\n// emits 'handle > error' event, which the error aggregator listens on\nfunction notice (err, doNotStamp) {\n  // by default add timestamp, unless specifically told not to\n  // this is to preserve existing behavior\n  var time = (!doNotStamp) ? loader.now() : null\n  handle('err', [err, time])\n}\n\n},{}],3:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Turn on feature\nvar loader = require(\"loader\")\n\nif (loader.disabled) return\nloader.features.ins = true\n\n},{}],4:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar START = '-start'\nvar END = '-end'\nvar BODY = '-body'\nvar FN_START = 'fn' + START\nvar FN_END = 'fn' + END\nvar CB_START = 'cb' + START\nvar CB_END = 'cb' + END\nvar JS_TIME = 'jsTime'\nvar FETCH = 'fetch'\nvar ADD_EVENT_LISTENER = 'addEventListener'\n\nvar win = window\nvar location = win.location\n\nvar loader = require(\"loader\")\n\n// loader.xhrWrappable will be false in chrome for ios, but addEventListener is still available.\n// sauce does not have a browser to test this case against, so be careful when modifying this check\nif (!win[ADD_EVENT_LISTENER] || !loader.xhrWrappable || loader.disabled) return\n\nvar mutationEE = require(10)\nvar promiseEE = require(11)\nvar historyEE = require(8)\nvar eventsEE = require(6)\nvar timerEE = require(13)\nvar fetchEE = require(7)\nvar xhrEE = require(14)\nvar jsonpEE = require(9)\nvar baseEE = require(\"ee\")\nvar tracerEE = baseEE.get('tracer')\n\nrequire(16)\nloader.features.spa = true\n\n// Get after wrapping\nvar depth = 0\nvar startHash\n\nbaseEE.on(FN_START, startTimestamp)\npromiseEE.on(CB_START, startTimestamp)\njsonpEE.on(CB_START, startTimestamp)\n\nfunction startTimestamp () {\n  depth++\n  startHash = location.hash\n  this[FN_START] = loader.now()\n}\n\nbaseEE.on(FN_END, endTimestamp)\npromiseEE.on(CB_END, endTimestamp)\njsonpEE.on(CB_END, endTimestamp)\n\nfunction endTimestamp () {\n  depth--\n  if (location.hash !== startHash) {\n    trackURLChange(0, true)\n  }\n\n  var time = loader.now()\n  this[JS_TIME] = (~~this[JS_TIME]) + time - this[FN_START]\n  this[FN_END] = time\n}\n\nbaseEE.buffer([FN_START, FN_END, 'xhr-done', 'xhr-resolved'])\neventsEE.buffer([FN_START])\ntimerEE.buffer(['setTimeout' + END, 'clearTimeout' + START, FN_START])\nxhrEE.buffer([FN_START, 'new-xhr', 'send-xhr' + START])\nfetchEE.buffer([FETCH + START, FETCH + '-done', FETCH + BODY + START, FETCH + BODY + END])\nhistoryEE.buffer(['newURL'])\nmutationEE.buffer([FN_START])\npromiseEE.buffer(['propagate', CB_START, CB_END, 'executor-err', 'resolve' + START])\ntracerEE.buffer([FN_START, 'no-' + FN_START])\njsonpEE.buffer(['new-jsonp', 'cb-start', 'jsonp-error', 'jsonp-end'])\n\ntimestamp(xhrEE, 'send-xhr' + START)\ntimestamp(baseEE, 'xhr-resolved')\ntimestamp(baseEE, 'xhr-done')\ntimestamp(fetchEE, FETCH + START)\ntimestamp(fetchEE, FETCH + '-done')\ntimestamp(jsonpEE, 'new-jsonp')\ntimestamp(jsonpEE, 'jsonp-end')\ntimestamp(jsonpEE, 'cb-start')\n\nhistoryEE.on('pushState-end', trackURLChange)\nhistoryEE.on('replaceState-end', trackURLChange)\n\nfunction trackURLChange (unusedArgs, hashChangedDuringCb) {\n  historyEE.emit('newURL', ['' + location, hashChangedDuringCb])\n}\n\nwin[ADD_EVENT_LISTENER]('hashchange', trackURLChange, true)\nwin[ADD_EVENT_LISTENER]('load', trackURLChange, true)\n\nwin[ADD_EVENT_LISTENER]('popstate', function () {\n  trackURLChange(0, depth > 1)\n}, true)\n\nfunction timestamp (ee, type) {\n  ee.on(type, function () {\n    this[type] = loader.now()\n  })\n}\n\n},{}],5:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nif (!(window.performance &&\n  window.performance.timing &&\n  window.performance.getEntriesByType\n  )) return\n\nvar ee = require(\"ee\")\nvar handle = require(\"handle\")\nvar timerEE = require(13)\nvar rafEE = require(12)\n\nvar learResourceTimings = 'learResourceTimings'\nvar ADD_EVENT_LISTENER = 'addEventListener'\nvar RESOURCE_TIMING_BUFFER_FULL = 'resourcetimingbufferfull'\nvar BST_RESOURCE = 'bstResource'\nvar RESOURCE = 'resource'\nvar START = '-start'\nvar END = '-end'\nvar FN_START = 'fn' + START\nvar FN_END = 'fn' + END\nvar BST_TIMER = 'bstTimer'\nvar PUSH_STATE = 'pushState'\n\n// Turn on feature harvesting\nvar loader = require(\"loader\")\nif (loader.disabled) return\n\nloader.features.stn = true\n\n// wrap history ap\nrequire(8)\n\n// wrap events\nif ('addEventListener' in window) {\n  require(6)\n}\n\n// Cache the value of window.Event for later instanceof checks, in case someone\n// overwrites it to be a non-function.\nvar origEvent = NREUM.o.EV\n\nee.on(FN_START, function (args, target) {\n  var evt = args[0]\n  if (evt instanceof origEvent) {\n    this.bstStart = loader.now()\n  }\n})\n\nee.on(FN_END, function (args, target) {\n  var evt = args[0]\n  if (evt instanceof origEvent) {\n    handle('bst', [evt, target, this.bstStart, loader.now()])\n  }\n})\n\ntimerEE.on(FN_START, function (args, obj, type) {\n  this.bstStart = loader.now()\n  this.bstType = type\n})\n\ntimerEE.on(FN_END, function (args, target) {\n  handle(BST_TIMER, [target, this.bstStart, loader.now(), this.bstType])\n})\n\nrafEE.on(FN_START, function () {\n  this.bstStart = loader.now()\n})\n\nrafEE.on(FN_END, function (args, target) {\n  handle(BST_TIMER, [target, this.bstStart, loader.now(), 'requestAnimationFrame'])\n})\n\nee.on(PUSH_STATE + START, function (args) {\n  this.time = loader.now()\n  this.startPath = location.pathname + location.hash\n})\nee.on(PUSH_STATE + END, function (args) {\n  handle('bstHist', [location.pathname + location.hash, this.startPath, this.time])\n})\n\nif (ADD_EVENT_LISTENER in window.performance) {\n  if (window.performance['c' + learResourceTimings]) {\n    window.performance[ADD_EVENT_LISTENER](RESOURCE_TIMING_BUFFER_FULL, function (e) {\n      handle(BST_RESOURCE, [window.performance.getEntriesByType(RESOURCE)])\n      window.performance['c' + learResourceTimings]()\n    }, false)\n  } else {\n    window.performance[ADD_EVENT_LISTENER]('webkit' + RESOURCE_TIMING_BUFFER_FULL, function (e) {\n      handle(BST_RESOURCE, [window.performance.getEntriesByType(RESOURCE)])\n      window.performance['webkitC' + learResourceTimings]()\n    }, false)\n  }\n}\n\ndocument[ADD_EVENT_LISTENER]('scroll', noOp, {passive: true})\ndocument[ADD_EVENT_LISTENER]('keypress', noOp, false)\ndocument[ADD_EVENT_LISTENER]('click', noOp, false)\n\nfunction noOp (e) { /* no-op */ }\n\n},{}],6:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('events')\nvar wrapFn = require(\"wrap-function\")(ee, true)\nvar getOrSet = require(\"gos\")\n\nvar XHR = XMLHttpRequest\nvar ADD_EVENT_LISTENER = 'addEventListener'\nvar REMOVE_EVENT_LISTENER = 'removeEventListener'\n\nmodule.exports = ee\n\n// Guard against instrumenting environments w/o necessary features\nif ('getPrototypeOf' in Object) {\n  findAndWrapNode(document)\n  findAndWrapNode(window)\n  findAndWrapNode(XHR.prototype)\n} else if (XHR.prototype.hasOwnProperty(ADD_EVENT_LISTENER)) {\n  wrapNode(window)\n  wrapNode(XHR.prototype)\n}\n\nee.on(ADD_EVENT_LISTENER + '-start', function (args, target) {\n  var originalListener = args[1]\n\n  var wrapped = getOrSet(originalListener, 'nr@wrapped', function () {\n    var listener = {\n      object: wrapHandleEvent,\n      'function': originalListener\n    }[typeof originalListener]\n\n    return listener ? wrapFn(listener, 'fn-', null, (listener.name || 'anonymous')) : originalListener\n\n    function wrapHandleEvent () {\n      if (typeof originalListener.handleEvent !== 'function') return\n      return originalListener.handleEvent.apply(originalListener, arguments)\n    }\n  })\n\n  this.wrapped = args[1] = wrapped\n})\n\nee.on(REMOVE_EVENT_LISTENER + '-start', function (args) {\n  args[1] = this.wrapped || args[1]\n})\n\nfunction findAndWrapNode (object) {\n  var step = object\n  while (step && !step.hasOwnProperty(ADD_EVENT_LISTENER)) { step = Object.getPrototypeOf(step) }\n  if (step) { wrapNode(step) }\n}\n\nfunction wrapNode (node) {\n  wrapFn.inPlace(node, [ADD_EVENT_LISTENER, REMOVE_EVENT_LISTENER], '-', uniqueListener)\n}\n\nfunction uniqueListener (args, obj) {\n  // Context for the listener is stored on itself.\n  return args[1]\n}\n\n},{}],7:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('fetch')\nvar slice = require(30)\nvar mapOwn = require(29)\n\nmodule.exports = ee\n\nvar win = window\nvar prefix = 'fetch-'\nvar bodyPrefix = prefix + 'body-'\nvar bodyMethods = ['arrayBuffer', 'blob', 'json', 'text', 'formData']\nvar Req = win.Request\nvar Res = win.Response\nvar fetch = win.fetch\nvar proto = 'prototype'\nvar ctxId = 'nr@context'\n\nif (!(Req && Res && fetch)) {\n  return\n}\n\nmapOwn(bodyMethods, function (i, name) {\n  wrapPromiseMethod(Req[proto], name, bodyPrefix)\n  wrapPromiseMethod(Res[proto], name, bodyPrefix)\n})\n\nwrapPromiseMethod(win, 'fetch', prefix)\n\nee.on(prefix + 'end', function (err, res) {\n  var ctx = this\n  if (res) {\n    var size = res.headers.get('content-length')\n    if (size !== null) {\n      ctx.rxSize = size\n    }\n    ee.emit(prefix + 'done', [null, res], ctx)\n  } else {\n    ee.emit(prefix + 'done', [err], ctx)\n  }\n})\n\nfunction wrapPromiseMethod (target, name, prefix) {\n  var fn = target[name]\n  if (typeof fn === 'function') {\n    target[name] = function () {\n      var args = slice(arguments)\n\n      var ctx = {}\n      // we are wrapping args in an array so we can preserve the reference\n      ee.emit(prefix + 'before-start', [args], ctx)\n      var dtPayload\n      if (ctx[ctxId] && ctx[ctxId].dt) dtPayload = ctx[ctxId].dt\n\n      var promise = fn.apply(this, args)\n\n      ee.emit(prefix + 'start', [args, dtPayload], promise)\n\n      return promise.then(function (val) {\n        ee.emit(prefix + 'end', [null, val], promise)\n        return val\n      }, function (err) {\n        ee.emit(prefix + 'end', [err], promise)\n        throw err\n      })\n    }\n  }\n}\n\n},{}],8:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// History pushState wrapper\nvar ee = require(\"ee\").get('history')\nvar wrapFn = require(\"wrap-function\")(ee)\n\nmodule.exports = ee\n\nvar prototype = window.history && window.history.constructor && window.history.constructor.prototype\nvar object = window.history\nif (prototype && prototype.pushState && prototype.replaceState) {\n  object = prototype\n}\nwrapFn.inPlace(object, [ 'pushState', 'replaceState' ], '-')\n\n},{}],9:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('jsonp')\nvar wrapFn = require(\"wrap-function\")(ee)\n\nmodule.exports = ee\n\nif (!shouldWrap()) return\n\nvar CALLBACK_REGEX = /[?&](?:callback|cb)=([^&#]+)/\nvar PARENT_REGEX = /(.*)\\.([^.]+)/\nvar VALUE_REGEX = /^(\\w+)(\\.|$)(.*)$/\nvar domInsertMethods = ['appendChild', 'insertBefore', 'replaceChild']\n\n// JSONP works by dynamically inserting <script> elements - wrap DOM methods for\n// inserting elements to detect insertion of JSONP-specific elements.\nif (Node && Node.prototype && Node.prototype.appendChild) {\n  wrapFn.inPlace(Node.prototype, domInsertMethods, 'dom-')\n} else {\n  wrapFn.inPlace(HTMLElement.prototype, domInsertMethods, 'dom-')\n  wrapFn.inPlace(HTMLHeadElement.prototype, domInsertMethods, 'dom-')\n  wrapFn.inPlace(HTMLBodyElement.prototype, domInsertMethods, 'dom-')\n}\n\nee.on('dom-start', function (args) {\n  wrapElement(args[0])\n})\n\n// subscribe to events on the JSONP <script> element and wrap the JSONP callback\n// in order to track start and end of the interaction node\nfunction wrapElement (el) {\n  var isScript = el && typeof el.nodeName === 'string' &&\n    el.nodeName.toLowerCase() === 'script'\n  if (!isScript) return\n\n  var isValidElement = typeof el.addEventListener === 'function'\n  if (!isValidElement) return\n\n  var callbackName = extractCallbackName(el.src)\n  if (!callbackName) return\n\n  var callback = discoverParent(callbackName)\n  var validCallback = typeof callback.parent[callback.key] === 'function'\n  if (!validCallback) return\n\n  // At this point we know that the element is a valid JSONP script element.\n  // The following events are emitted during the lifetime of a JSONP call:\n  // * immediately emit `new-jsonp` to notify start of the JSONP work\n  // * the wrapped callback will emit `cb-start` and `cb-end` during the execution\n  //   of the callback, here we can inspect the response\n  // * when the element emits the `load` event (script loaded and executed),\n  //   emit `jsonp-end` to notify end of the JSONP work\n  // * if the element emits the `error` event, in response emit `jsonp-error`\n  //   (and `jsonp-end`). Note that the callback in this case will likely not get\n  //   called.\n\n  var context = {}\n  wrapFn.inPlace(callback.parent, [callback.key], 'cb-', context)\n\n  el.addEventListener('load', onLoad, false)\n  el.addEventListener('error', onError, false)\n  ee.emit('new-jsonp', [el.src], context)\n\n  function onLoad () {\n    ee.emit('jsonp-end', [], context)\n    el.removeEventListener('load', onLoad, false)\n    el.removeEventListener('error', onError, false)\n  }\n\n  function onError () {\n    ee.emit('jsonp-error', [], context)\n    ee.emit('jsonp-end', [], context)\n    el.removeEventListener('load', onLoad, false)\n    el.removeEventListener('error', onError, false)\n  }\n}\n\nfunction shouldWrap () {\n  return 'addEventListener' in window\n}\n\nfunction extractCallbackName (src) {\n  var matches = src.match(CALLBACK_REGEX)\n  return matches ? matches[1] : null\n}\n\nfunction discoverValue (longKey, obj) {\n  var matches = longKey.match(VALUE_REGEX)\n  var key = matches[1]\n  var remaining = matches[3]\n  if (!remaining) {\n    return obj[key]\n  }\n  return discoverValue(remaining, obj[key])\n}\n\nfunction discoverParent (key) {\n  var matches = key.match(PARENT_REGEX)\n  if (matches && matches.length >= 3) {\n    return {\n      key: matches[2],\n      parent: discoverValue(matches[1], window)\n    }\n  }\n  return {\n    key: key,\n    parent: window\n  }\n}\n\n},{}],10:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('mutation')\nvar wrapFn = require(\"wrap-function\")(ee)\nvar OriginalObserver = NREUM.o.MO\n\nmodule.exports = ee\n\nif (OriginalObserver) {\n  window.MutationObserver = function WrappedMutationObserver (cb) {\n    if (this instanceof OriginalObserver) {\n      return new OriginalObserver(wrapFn(cb, 'fn-'))\n    } else {\n      return OriginalObserver.apply(this, arguments)\n    }\n  }\n\n  MutationObserver.prototype = OriginalObserver.prototype\n}\n\n},{}],11:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar wrapFn = require(\"wrap-function\")\nvar promiseEE = require(\"ee\").get('promise')\nvar getContext = require(\"ee\").getOrSetContext\nvar promiseWrapper = wrapFn(promiseEE)\nvar mapOwn = require(29)\nvar OriginalPromise = NREUM.o.PR\n\nmodule.exports = promiseEE\n\nif (!OriginalPromise) return\n\nwindow.Promise = WrappedPromise\n\n;['all', 'race'].forEach(function (method) {\n  var original = OriginalPromise[method]\n  OriginalPromise[method] = function (subPromises) {\n    var finalized = false\n    mapOwn(subPromises, function (i, sub) {\n      Promise.resolve(sub).then(setNrId(method === 'all'), setNrId(false))\n    })\n\n    var originalReturnValue = original.apply(OriginalPromise, arguments)\n    var promise = OriginalPromise.resolve(originalReturnValue)\n\n    return promise\n\n    function setNrId (overwrite) {\n      return function () {\n        promiseEE.emit('propagate', [null, !finalized], originalReturnValue, false, false)\n        finalized = finalized || !overwrite\n      }\n    }\n  }\n})\n\n;['resolve', 'reject'].forEach(function (method) {\n  var original = OriginalPromise[method]\n  OriginalPromise[method] = function (val) {\n    var returnVal = original.apply(OriginalPromise, arguments)\n    if (val !== returnVal) {\n      promiseEE.emit('propagate', [val, true], returnVal, false, false)\n    }\n\n    return returnVal\n  }\n})\n\nOriginalPromise.prototype['catch'] = function wrappedCatch (fn) {\n  return this.then(null, fn)\n}\n\nOriginalPromise.prototype = Object.create(OriginalPromise.prototype, {\n  constructor: {value: WrappedPromise}\n})\n\nmapOwn(Object.getOwnPropertyNames(OriginalPromise), function copy (i, key) {\n  try {\n    WrappedPromise[key] = OriginalPromise[key]\n  } catch (err) {\n    // ignore properties we can't copy\n  }\n})\n\nfunction WrappedPromise (executor) {\n  var ctx = promiseEE.context()\n  var wrappedExecutor = promiseWrapper(executor, 'executor-', ctx, null, false)\n\n  var promise = new OriginalPromise(wrappedExecutor)\n\n  promiseEE.context(promise).getCtx = function () {\n    return ctx\n  }\n\n  return promise\n}\n\nwrapFn.wrapInPlace(OriginalPromise.prototype, 'then', function wrapThen(original) {\n  return function wrappedThen() {\n    var originalThis = this\n    var args = wrapFn.argsToArray.apply(this, arguments)\n\n    var ctx = getContext(originalThis)\n    ctx.promise = originalThis\n    args[0] = promiseWrapper(args[0], 'cb-', ctx, null, false)\n    args[1] = promiseWrapper(args[1], 'cb-', ctx, null, false)\n\n    var result = original.apply(this, args)\n\n    ctx.nextPromise = result\n    promiseEE.emit('propagate', [originalThis, true], result, false, false)\n\n    return result\n  }\n})\n\npromiseEE.on('executor-start', function (args) {\n  args[0] = promiseWrapper(args[0], 'resolve-', this, null, false)\n  args[1] = promiseWrapper(args[1], 'resolve-', this, null, false)\n})\n\npromiseEE.on('executor-err', function (args, originalThis, err) {\n  args[1](err)\n})\n\npromiseEE.on('cb-end', function (args, originalThis, result) {\n  promiseEE.emit('propagate', [result, true], this.nextPromise, false, false)\n})\n\npromiseEE.on('propagate', function (val, overwrite, trigger) {\n  if (!this.getCtx || overwrite) {\n    this.getCtx = function () {\n      if (val instanceof Promise) {\n        var store = promiseEE.context(val)\n      }\n\n      return store && store.getCtx ? store.getCtx() : this\n    }\n  }\n})\n\nWrappedPromise.toString = function () {\n  return '' + OriginalPromise\n}\n\n},{}],12:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Request Animation Frame wrapper\nvar ee = require(\"ee\").get('raf')\nvar wrapFn = require(\"wrap-function\")(ee)\n\nvar equestAnimationFrame = 'equestAnimationFrame'\n\nmodule.exports = ee\n\nwrapFn.inPlace(window, [\n  'r' + equestAnimationFrame,\n  'mozR' + equestAnimationFrame,\n  'webkitR' + equestAnimationFrame,\n  'msR' + equestAnimationFrame\n], 'raf-')\n\nee.on('raf-start', function (args) {\n  // Wrap the callback handed to requestAnimationFrame\n  args[0] = wrapFn(args[0], 'fn-')\n})\n\n},{}],13:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('timer')\nvar wrapFn = require(\"wrap-function\")(ee)\n\nvar SET_TIMEOUT = 'setTimeout'\nvar SET_INTERVAL = 'setInterval'\nvar CLEAR_TIMEOUT = 'clearTimeout'\nvar START = '-start'\nvar DASH = '-'\n\nmodule.exports = ee\n\nwrapFn.inPlace(window, [SET_TIMEOUT, 'setImmediate'], SET_TIMEOUT + DASH)\nwrapFn.inPlace(window, [SET_INTERVAL], SET_INTERVAL + DASH)\nwrapFn.inPlace(window, [CLEAR_TIMEOUT, 'clearImmediate'], CLEAR_TIMEOUT + DASH)\n\nee.on(SET_INTERVAL + START, interval)\nee.on(SET_TIMEOUT + START, timer)\n\nfunction interval (args, obj, type) {\n  args[0] = wrapFn(args[0], 'fn-', null, type)\n}\n\nfunction timer (args, obj, type) {\n  this.method = type\n  this.timerDuration = isNaN(args[1]) ? 0 : +args[1]\n  args[0] = wrapFn(args[0], 'fn-', this, type)\n}\n\n},{}],14:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// wrap-events patches XMLHttpRequest.prototype.addEventListener for us.\nrequire(6)\n\nvar baseEE = require(\"ee\")\nvar ee = baseEE.get('xhr')\nvar wrapFn = require(\"wrap-function\")(ee)\nvar originals = NREUM.o\nvar OrigXHR = originals.XHR\nvar MutationObserver = originals.MO\nvar Promise = originals.PR\nvar setImmediate = originals.SI\n\nvar READY_STATE_CHANGE = 'readystatechange'\n\nvar handlers = ['onload', 'onerror', 'onabort', 'onloadstart', 'onloadend', 'onprogress', 'ontimeout']\nvar pendingXhrs = []\n\nmodule.exports = ee\n\nvar XHR = window.XMLHttpRequest = function (opts) {\n  var xhr = new OrigXHR(opts)\n  try {\n    ee.emit('new-xhr', [xhr], xhr)\n    xhr.addEventListener(READY_STATE_CHANGE, wrapXHR, false)\n  } catch (e) {\n    try {\n      ee.emit('internal-error', [e])\n    } catch (err) {}\n  }\n  return xhr\n}\n\ncopy(OrigXHR, XHR)\n\nXHR.prototype = OrigXHR.prototype\n\nwrapFn.inPlace(XHR.prototype, ['open', 'send'], '-xhr-', getObject)\n\nee.on('send-xhr-start', function (args, xhr) {\n  wrapOnreadystatechange(args, xhr)\n  enqueuePendingXhr(xhr)\n})\nee.on('open-xhr-start', wrapOnreadystatechange)\n\nfunction wrapOnreadystatechange (args, xhr) {\n  wrapFn.inPlace(xhr, ['onreadystatechange'], 'fn-', getObject)\n}\n\nfunction wrapXHR () {\n  var xhr = this\n  var ctx = ee.context(xhr)\n\n  if (xhr.readyState > 3 && !ctx.resolved) {\n    ctx.resolved = true\n    ee.emit('xhr-resolved', [], xhr)\n  }\n\n  wrapFn.inPlace(xhr, handlers, 'fn-', getObject)\n}\n\n// Wrapping the onreadystatechange property of XHRs takes some special tricks.\n//\n// The issue is that the onreadystatechange property may be assigned *after*\n// send() is called against an XHR. This is of particular importance because\n// jQuery uses a single onreadystatechange handler to implement all of the XHR\n// callbacks thtat it provides, and it assigns that property after calling send.\n//\n// There are several 'obvious' approaches to wrapping the onreadystatechange\n// when it's assigned after send:\n//\n// 1. Try to wrap the onreadystatechange handler from a readystatechange\n//    addEventListener callback (the addEventListener callback will fire before\n//    the onreadystatechange callback).\n//\n//      Caveat: this doesn't work in Chrome or Safari, and in fact will cause\n//      the onreadystatechange handler to not be invoked at all during the\n//      firing cycle in which it is wrapped, which may break applications :(\n//\n// 2. Use Object.defineProperty to create a setter for the onreadystatechange\n//    property, and wrap from that setter.\n//\n//      Caveat: onreadystatechange is not a configurable property in Safari or\n//      older versions of the Android browser.\n//\n// 3. Schedule wrapping of the onreadystatechange property using a setTimeout\n//    call issued just before the call to send.\n//\n//      Caveat: sometimes, the onreadystatechange handler fires before the\n//      setTimeout, meaning the wrapping happens too late.\n//\n// The setTimeout approach is closest to what we use here: we want to schedule\n// the wrapping of the onreadystatechange property when send is called, but\n// ensure that our wrapping happens before onreadystatechange has a chance to\n// fire.\n//\n// We achieve this using a hybrid approach:\n//\n// * In browsers that support MutationObserver, we use that to schedule wrapping\n//   of onreadystatechange.\n//\n// * We have discovered that MutationObserver in IE causes a memory leak, so we\n//   now will prefer setImmediate for IE, and use a resolved promise to schedule\n//   the wrapping in Edge (and other browsers that support promises)\n//\n// * In older browsers that don't support MutationObserver, we rely on the fact\n//   that the call to send is probably happening within a callback that we've\n//   already wrapped, and use our existing fn-end event callback to wrap the\n//   onreadystatechange at the end of the current callback.\n//\n\nif (MutationObserver) {\n  var resolved = Promise && Promise.resolve()\n  if (!setImmediate && !Promise) {\n    var toggle = 1\n    var dummyNode = document.createTextNode(toggle)\n    new MutationObserver(drainPendingXhrs).observe(dummyNode, { characterData: true })\n  }\n} else {\n  baseEE.on('fn-end', function (args) {\n    // We don't want to try to wrap onreadystatechange from within a\n    // readystatechange callback.\n    if (args[0] && args[0].type === READY_STATE_CHANGE) return\n    drainPendingXhrs()\n  })\n}\n\nfunction enqueuePendingXhr (xhr) {\n  pendingXhrs.push(xhr)\n  if (MutationObserver) {\n    if (resolved) {\n      resolved.then(drainPendingXhrs)\n    } else if (setImmediate) {\n      setImmediate(drainPendingXhrs)\n    } else {\n      toggle = -toggle\n      dummyNode.data = toggle\n    }\n  }\n}\n\nfunction drainPendingXhrs () {\n  for (var i = 0; i < pendingXhrs.length; i++) {\n    wrapOnreadystatechange([], pendingXhrs[i])\n  }\n  if (pendingXhrs.length) pendingXhrs = []\n}\n\n// Use the object these methods are on as their\n// context store for the event emitter\nfunction getObject (args, obj) {\n  return obj\n}\n\nfunction copy (from, to) {\n  for (var i in from) {\n    to[i] = from[i]\n  }\n  return to\n}\n\n},{}],15:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar uniqueId = require(26)\nvar parseUrl = require(17)\n\nmodule.exports = {\n  generateTracePayload: generateTracePayload,\n  shouldGenerateTrace: shouldGenerateTrace\n}\n\nfunction generateTracePayload (parsedOrigin) {\n  if (!shouldGenerateTrace(parsedOrigin)) {\n    return null\n  }\n\n  var nr = window.NREUM\n  if (!nr.loader_config) {\n    return null\n  }\n\n  var accountId = (nr.loader_config.accountID || '').toString() || null\n  var agentId = (nr.loader_config.agentID || '').toString() || null\n  var trustKey = (nr.loader_config.trustKey || '').toString() || null\n\n  if (!accountId || !agentId) {\n    return null\n  }\n\n  var spanId = uniqueId.generateSpanId()\n  var traceId = uniqueId.generateTraceId()\n  var timestamp = Date.now()\n\n  var payload = {\n    spanId: spanId,\n    traceId: traceId,\n    timestamp: timestamp\n  }\n\n  if (parsedOrigin.sameOrigin ||\n      (isAllowedOrigin(parsedOrigin) && useTraceContextHeadersForCors())) {\n    payload.traceContextParentHeader = generateTraceContextParentHeader(spanId, traceId)\n    payload.traceContextStateHeader = generateTraceContextStateHeader(spanId, timestamp,\n      accountId, agentId, trustKey)\n  }\n\n  if ((parsedOrigin.sameOrigin && !excludeNewrelicHeader()) ||\n      (!parsedOrigin.sameOrigin && isAllowedOrigin(parsedOrigin) && useNewrelicHeaderForCors())) {\n    payload.newrelicHeader = generateTraceHeader(spanId, traceId, timestamp, accountId,\n      agentId, trustKey)\n  }\n\n  return payload\n}\n\nfunction generateTraceContextParentHeader(spanId, traceId) {\n  return '00-' + traceId + '-' + spanId + '-01'\n}\n\nfunction generateTraceContextStateHeader(spanId, timestamp, accountId, appId, trustKey) {\n  var version = 0\n  var transactionId = ''\n  var parentType = 1\n  var sampled = ''\n  var priority = ''\n\n  return trustKey + '@nr=' + version + '-' + parentType + '-' + accountId +\n    '-' + appId + '-' + spanId + '-' + transactionId + '-' + sampled + '-' + priority + '-' + timestamp\n}\n\nfunction generateTraceHeader (spanId, traceId, timestamp, accountId, appId, trustKey) {\n  var hasBtoa = ('btoa' in window && typeof window.btoa === 'function')\n  if (!hasBtoa) {\n    return null\n  }\n\n  var payload = {\n    v: [0, 1],\n    d: {\n      ty: 'Browser',\n      ac: accountId,\n      ap: appId,\n      id: spanId,\n      tr: traceId,\n      ti: timestamp\n    }\n  }\n  if (trustKey && accountId !== trustKey) {\n    payload.d.tk = trustKey\n  }\n\n  return btoa(JSON.stringify(payload))\n}\n\n// return true if DT is enabled and the origin is allowed, either by being\n// same-origin, or included in the allowed list\nfunction shouldGenerateTrace (parsedOrigin) {\n  return isDtEnabled() && isAllowedOrigin(parsedOrigin)\n}\n\nfunction isAllowedOrigin(parsedOrigin) {\n  var allowed = false\n  var dtConfig = {}\n\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    dtConfig = NREUM.init.distributed_tracing\n  }\n\n  if (parsedOrigin.sameOrigin) {\n    allowed = true\n  } else if (dtConfig.allowed_origins instanceof Array) {\n    for (var i = 0; i < dtConfig.allowed_origins.length; i++) {\n      var allowedOrigin = parseUrl(dtConfig.allowed_origins[i])\n      if (parsedOrigin.hostname === allowedOrigin.hostname &&\n          parsedOrigin.protocol === allowedOrigin.protocol &&\n          parsedOrigin.port === allowedOrigin.port) {\n        allowed = true\n        break\n      }\n    }\n  }\n  return allowed\n}\n\nfunction isDtEnabled() {\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    return !!NREUM.init.distributed_tracing.enabled\n  }\n  return false\n}\n\n// exclude the newrelic header for same-origin calls\nfunction excludeNewrelicHeader() {\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    return !!NREUM.init.distributed_tracing.exclude_newrelic_header\n  }\n  return false\n}\n\nfunction useNewrelicHeaderForCors() {\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    return NREUM.init.distributed_tracing.cors_use_newrelic_header !== false\n  }\n  return false\n}\n\nfunction useTraceContextHeadersForCors() {\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    return !!NREUM.init.distributed_tracing.cors_use_tracecontext_headers\n  }\n  return false\n}\n\n},{}],16:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar loader = require(\"loader\")\n\n// Don't instrument Chrome for iOS, it is buggy and acts like there are URL verification issues\nif (!loader.xhrWrappable || loader.disabled) return\n\nvar handle = require(\"handle\")\nvar parseUrl = require(17)\nvar generateTracePayload = require(15).generateTracePayload\nvar ee = require(\"ee\")\nvar handlers = [ 'load', 'error', 'abort', 'timeout' ]\nvar handlersLen = handlers.length\nvar id = require(\"id\")\nvar ffVersion = require(22)\nvar dataSize = require(21)\nvar responseSizeFromXhr = require(18)\n\nvar origXHR = window.XMLHttpRequest\n\n// Declare that we are using xhr instrumentation\nloader.features.xhr = true\n\nrequire(14)\nrequire(7)\n\n// Setup the context for each new xhr object\nee.on('new-xhr', function (xhr) {\n  var ctx = this\n  ctx.totalCbs = 0\n  ctx.called = 0\n  ctx.cbTime = 0\n  ctx.end = end\n  ctx.ended = false\n  ctx.xhrGuids = {}\n  ctx.lastSize = null\n  ctx.loadCaptureCalled = false\n\n  xhr.addEventListener('load', function (event) {\n    captureXhrData(ctx, xhr)\n  }, false)\n\n  // In Firefox 34+, XHR ProgressEvents report pre-content-decoding sizes via\n  // their 'loaded' property, rather than post-decoding sizes. We want\n  // post-decoding sizes for consistency with browsers where that's all we have.\n  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1227674\n  //\n  // In really old versions of Firefox (older than somewhere between 5 and 10),\n  // we don't reliably get a final XHR ProgressEvent which reflects the full\n  // size of the transferred resource.\n  //\n  // So, in both of these cases, we fall back to not using ProgressEvents to\n  // measure XHR sizes.\n\n  if (ffVersion && (ffVersion > 34 || ffVersion < 10)) return\n\n  // In Opera, ProgressEvents report loaded values that are too high.\n  if (window.opera) return\n\n  xhr.addEventListener('progress', function (event) {\n    ctx.lastSize = event.loaded\n  }, false)\n})\n\nee.on('open-xhr-start', function (args) {\n  this.params = { method: args[0] }\n  addUrl(this, args[1])\n  this.metrics = {}\n})\n\nee.on('open-xhr-end', function (args, xhr) {\n  if ('loader_config' in NREUM && 'xpid' in NREUM.loader_config && this.sameOrigin) {\n    xhr.setRequestHeader('X-NewRelic-ID', NREUM.loader_config.xpid)\n  }\n\n  var payload = generateTracePayload(this.parsedOrigin)\n  if (payload) {\n    var added = false\n    if (payload.newrelicHeader) {\n      xhr.setRequestHeader('newrelic', payload.newrelicHeader)\n      added = true\n    }\n    if (payload.traceContextParentHeader) {\n      xhr.setRequestHeader('traceparent', payload.traceContextParentHeader)\n      if (payload.traceContextStateHeader) {\n        xhr.setRequestHeader('tracestate', payload.traceContextStateHeader)\n      }\n      added = true\n    }\n    if (added) {\n      this.dt = payload\n    }\n  }\n})\n\nee.on('send-xhr-start', function (args, xhr) {\n  var metrics = this.metrics\n  var data = args[0]\n  var context = this\n\n  if (metrics && data) {\n    var size = dataSize(data)\n    if (size) metrics.txSize = size\n  }\n\n  this.startTime = loader.now()\n\n  this.listener = function (evt) {\n    try {\n      if (evt.type === 'abort' && !(context.loadCaptureCalled)) {\n        context.params.aborted = true\n      }\n      if (evt.type !== 'load' || (context.called === context.totalCbs) && (context.onloadCalled || typeof (xhr.onload) !== 'function')) context.end(xhr)\n    } catch (e) {\n      try {\n        ee.emit('internal-error', [e])\n      } catch (err) {}\n    }\n  }\n\n  for (var i = 0; i < handlersLen; i++) {\n    xhr.addEventListener(handlers[i], this.listener, false)\n  }\n})\n\nee.on('xhr-cb-time', function (time, onload, xhr) {\n  this.cbTime += time\n  if (onload) this.onloadCalled = true\n  else this.called += 1\n  if ((this.called === this.totalCbs) && (this.onloadCalled || typeof (xhr.onload) !== 'function')) this.end(xhr)\n})\n\nee.on('xhr-load-added', function (cb, useCapture) {\n  // Ignore if the same arguments are passed to addEventListener twice\n  var idString = '' + id(cb) + !!useCapture\n  if (!this.xhrGuids || this.xhrGuids[idString]) return\n  this.xhrGuids[idString] = true\n\n  this.totalCbs += 1\n})\n\nee.on('xhr-load-removed', function (cb, useCapture) {\n  // Ignore if event listener didn't exist for this xhr object\n  var idString = '' + id(cb) + !!useCapture\n  if (!this.xhrGuids || !this.xhrGuids[idString]) return\n  delete this.xhrGuids[idString]\n\n  this.totalCbs -= 1\n})\n\n// Listen for load listeners to be added to xhr objects\nee.on('addEventListener-end', function (args, xhr) {\n  if (xhr instanceof origXHR && args[0] === 'load') ee.emit('xhr-load-added', [args[1], args[2]], xhr)\n})\n\nee.on('removeEventListener-end', function (args, xhr) {\n  if (xhr instanceof origXHR && args[0] === 'load') ee.emit('xhr-load-removed', [args[1], args[2]], xhr)\n})\n\n// Listen for those load listeners to be called.\nee.on('fn-start', function (args, xhr, methodName) {\n  if (xhr instanceof origXHR) {\n    if (methodName === 'onload') this.onload = true\n    if ((args[0] && args[0].type) === 'load' || this.onload) this.xhrCbStart = loader.now()\n  }\n})\n\nee.on('fn-end', function (args, xhr) {\n  if (this.xhrCbStart) ee.emit('xhr-cb-time', [loader.now() - this.xhrCbStart, this.onload, xhr], xhr)\n})\n\nee.on('fetch-before-start', function (args) {\n  var opts = args[1] || {}\n  var url\n  // argument is USVString\n  if (typeof args[0] === 'string') {\n    url = args[0]\n  // argument is Request object\n  } else if (args[0] && args[0].url) {\n    url = args[0].url\n  // argument is URL object\n  } else if (window.URL && args[0] && args[0] instanceof URL) {\n    url = args[0].href\n  }\n\n  if (url) {\n    this.parsedOrigin = parseUrl(url)\n    this.sameOrigin = this.parsedOrigin.sameOrigin\n  }\n\n  var payload = generateTracePayload(this.parsedOrigin)\n  if (!payload || (!payload.newrelicHeader && !payload.traceContextParentHeader)) {\n    return\n  }\n\n  if (typeof args[0] === 'string' || (window.URL && args[0] && args[0] instanceof URL)) {\n    var clone = {}\n\n    for (var key in opts) {\n      clone[key] = opts[key]\n    }\n\n    clone.headers = new Headers(opts.headers || {})\n    if (addHeaders(clone.headers, payload)) {\n      this.dt = payload\n    }\n\n    if (args.length > 1) {\n      args[1] = clone\n    } else {\n      args.push(clone)\n    }\n  } else if (args[0] && args[0].headers) {\n    if (addHeaders(args[0].headers, payload)) {\n      this.dt = payload\n    }\n  }\n\n  function addHeaders(headersObj, payload) {\n    var added = false\n    if (payload.newrelicHeader) {\n      headersObj.set('newrelic', payload.newrelicHeader)\n      added = true\n    }\n    if (payload.traceContextParentHeader) {\n      headersObj.set('traceparent', payload.traceContextParentHeader)\n      if (payload.traceContextStateHeader) {\n        headersObj.set('tracestate', payload.traceContextStateHeader)\n      }\n      added = true\n    }\n    return added\n  }\n})\n\n// Create report for XHR request that has finished\nfunction end (xhr) {\n  var params = this.params\n  var metrics = this.metrics\n\n  if (this.ended) return\n  this.ended = true\n\n  for (var i = 0; i < handlersLen; i++) {\n    xhr.removeEventListener(handlers[i], this.listener, false)\n  }\n\n  if (params.aborted) return\n  metrics.duration = loader.now() - this.startTime\n  if (!this.loadCaptureCalled && xhr.readyState === 4) {\n    captureXhrData(this, xhr)\n  } else if (params.status == null) {\n    params.status = 0\n  }\n\n  // Always send cbTime, even if no noticeable time was taken.\n  metrics.cbTime = this.cbTime\n  ee.emit('xhr-done', [xhr], xhr)\n  handle('xhr', [params, metrics, this.startTime])\n}\n\nfunction addUrl (ctx, url) {\n  var parsed = parseUrl(url)\n  var params = ctx.params\n\n  params.host = parsed.hostname + ':' + parsed.port\n  params.pathname = parsed.pathname\n  ctx.parsedOrigin = parseUrl(url)\n  ctx.sameOrigin = ctx.parsedOrigin.sameOrigin\n}\n\nfunction captureXhrData (ctx, xhr) {\n  ctx.params.status = xhr.status\n\n  var size = responseSizeFromXhr(xhr, ctx.lastSize)\n  if (size) ctx.metrics.rxSize = size\n\n  if (ctx.sameOrigin) {\n    var header = xhr.getResponseHeader('X-NewRelic-App-Data')\n    if (header) {\n      ctx.params.cat = header.split(', ').pop()\n    }\n  }\n\n  ctx.loadCaptureCalled = true\n}\n\n},{}],17:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stringsToParsedUrls = {}\n\nmodule.exports = function parseUrl (url) {\n  if (url in stringsToParsedUrls) {\n    return stringsToParsedUrls[url]\n  }\n\n  var urlEl = document.createElement('a')\n  var location = window.location\n  var ret = {}\n\n  // Use an anchor dom element to resolve the url natively.\n  urlEl.href = url\n\n  ret.port = urlEl.port\n\n  var firstSplit = urlEl.href.split('://')\n\n  if (!ret.port && firstSplit[1]) {\n    ret.port = firstSplit[1].split('/')[0].split('@').pop().split(':')[1]\n  }\n  if (!ret.port || ret.port === '0') ret.port = (firstSplit[0] === 'https' ? '443' : '80')\n\n  // Host not provided in IE for relative urls\n  ret.hostname = (urlEl.hostname || location.hostname)\n\n  ret.pathname = urlEl.pathname\n\n  ret.protocol = firstSplit[0]\n\n  // Pathname sometimes doesn't have leading slash (IE 8 and 9)\n  if (ret.pathname.charAt(0) !== '/') ret.pathname = '/' + ret.pathname\n\n  // urlEl.protocol is ':' in old ie when protocol is not specified\n  var sameProtocol = !urlEl.protocol || urlEl.protocol === ':' || urlEl.protocol === location.protocol\n  var sameDomain = urlEl.hostname === document.domain && urlEl.port === location.port\n\n  // urlEl.hostname is not provided by IE for relative urls, but relative urls are also same-origin\n  ret.sameOrigin = sameProtocol && (!urlEl.hostname || sameDomain)\n\n  // Only cache if url doesn't have a path\n  if (ret.pathname === '/') {\n    stringsToParsedUrls[url] = ret\n  }\n\n  return ret\n}\n\n},{}],18:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar dataSize = require(21)\n\nmodule.exports = responseSizeFromXhr\n\nfunction responseSizeFromXhr (xhr, lastSize) {\n  var type = xhr.responseType\n  if (type === 'json' && lastSize !== null) return lastSize\n  // Caution! Chrome throws an error if you try to access xhr.responseText for binary data\n  if (type === 'arraybuffer' || type === 'blob' || type === 'json') {\n    return dataSize(xhr.response)\n  } else if (type === 'text' || type === '' || type === undefined) {  // empty string type defaults to 'text'\n    return dataSize(xhr.responseText)\n  } else {  // e.g. ms-stream and document (we do not currently determine the size of Document objects)\n    return undefined\n  }\n}\n\n},{}],19:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handle = require(\"handle\")\nvar mapOwn = require(29)\nvar slice = require(30)\nvar tracerEE = require(\"ee\").get('tracer')\nvar loader = require(\"loader\")\n\nvar nr = NREUM\nif (typeof (window.newrelic) === 'undefined') newrelic = nr\n\nvar asyncApiFns = [\n  'setPageViewName',\n  'setCustomAttribute',\n  'setErrorHandler',\n  'finished',\n  'addToTrace',\n  'inlineHit',\n  'addRelease'\n]\n\nvar prefix = 'api-'\nvar spaPrefix = prefix + 'ixn-'\n\n// Setup stub functions that queue calls for later processing.\nmapOwn(asyncApiFns, function (num, fnName) {\n  nr[fnName] = apiCall(prefix + fnName, true, 'api')\n})\n\nnr.addPageAction = apiCall(prefix + 'addPageAction', true)\nnr.setCurrentRouteName = apiCall(prefix + 'routeName', true)\n\nmodule.exports = newrelic\n\nnr.interaction = function () {\n  return new InteractionHandle().get()\n}\n\nfunction InteractionHandle () {}\n\nvar InteractionApiProto = InteractionHandle.prototype = {\n  createTracer: function (name, cb) {\n    var contextStore = {}\n    var ixn = this\n    var hasCb = typeof cb === 'function'\n    handle(spaPrefix + 'tracer', [loader.now(), name, contextStore], ixn)\n    return function () {\n      tracerEE.emit((hasCb ? '' : 'no-') + 'fn-start', [loader.now(), ixn, hasCb], contextStore)\n      if (hasCb) {\n        try {\n          return cb.apply(this, arguments)\n        } catch (err) {\n          tracerEE.emit('fn-err', [arguments, this, err], contextStore)\n          // the error came from outside the agent, so don't swallow\n          throw err\n        } finally {\n          tracerEE.emit('fn-end', [loader.now()], contextStore)\n        }\n      }\n    }\n  }\n}\n\nmapOwn('actionText,setName,setAttribute,save,ignore,onEnd,getContext,end,get'.split(','), function addApi (n, name) {\n  InteractionApiProto[name] = apiCall(spaPrefix + name)\n})\n\nfunction apiCall (name, notSpa, bufferGroup) {\n  return function () {\n    handle(name, [loader.now()].concat(slice(arguments)), notSpa ? null : this, bufferGroup)\n    return notSpa ? void 0 : this\n  }\n}\n\nnewrelic.noticeError = function (err, customAttributes) {\n  if (typeof err === 'string') err = new Error(err)\n  handle('err', [err, loader.now(), false, customAttributes])\n}\n\n},{}],20:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getConfiguration: getConfiguration\n}\n\nfunction getConfiguration(path) {\n  if (!NREUM.init) return\n  var val = NREUM.init\n  var parts = path.split('.')\n  for (var i = 0; i < parts.length - 1; i++) {\n    val = val[parts[i]]\n    if (typeof val !== 'object') return\n  }\n  val = val[parts[parts.length - 1]]\n  return val\n}\n\n},{}],21:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = function dataSize (data) {\n  if (typeof data === 'string' && data.length) return data.length\n  if (typeof data !== 'object') return undefined\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer && data.byteLength) return data.byteLength\n  if (typeof Blob !== 'undefined' && data instanceof Blob && data.size) return data.size\n  if (typeof FormData !== 'undefined' && data instanceof FormData) return undefined\n\n  try {\n    return JSON.stringify(data).length\n  } catch (e) {\n    return undefined\n  }\n}\n\n},{}],22:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = 0\nvar match = navigator.userAgent.match(/Firefox[\\/\\s](\\d+\\.\\d+)/)\nif (match) ffVersion = +match[1]\n\nmodule.exports = ffVersion\n\n},{}],23:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar lastTimestamp = new Date().getTime()\nvar offset = lastTimestamp\n\nvar performanceCheck = require(31)\n\nmodule.exports = now\nmodule.exports.offset = offset\nmodule.exports.getLastTimestamp = getLastTimestamp\n\nfunction now () {\n  if (performanceCheck.exists && performance.now) {\n    return Math.round(performance.now())\n  }\n  // ensure a new timestamp is never smaller than a previous timestamp\n  return (lastTimestamp = Math.max(new Date().getTime(), lastTimestamp)) - offset\n}\n\nfunction getLastTimestamp() {\n  return lastTimestamp\n}\n\n},{}],24:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = protocolAllowed\n\nfunction protocolAllowed (location) {\n  return !!(location && location.protocol && location.protocol !== 'file:')\n}\n\n},{}],25:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// collect page view timings unless the feature is explicitly disabled\nif ('init' in NREUM && 'page_view_timing' in NREUM.init &&\n  'enabled' in NREUM.init.page_view_timing &&\n  NREUM.init.page_view_timing.enabled === false) {\n  return\n}\n\nvar handle = require(\"handle\")\nvar loader = require(\"loader\")\nvar subscribeToVisibilityChange = require(28)\n\nvar origEvent = NREUM.o.EV\n\n// paint metrics\nfunction perfObserver(list, observer) {\n  var entries = list.getEntries()\n  entries.forEach(function (entry) {\n    if (entry.name === 'first-paint') {\n      handle('timing', ['fp', Math.floor(entry.startTime)])\n    } else if (entry.name === 'first-contentful-paint') {\n      handle('timing', ['fcp', Math.floor(entry.startTime)])\n    }\n  })\n}\n\n// largest contentful paint\nfunction lcpObserver(list, observer) {\n  var entries = list.getEntries()\n  if (entries.length > 0) {\n    handle('lcp', [entries[entries.length - 1]])\n  }\n}\n\nfunction clsObserver(list) {\n  list.getEntries().forEach(function(entry) {\n    if (!entry.hadRecentInput) {\n      handle('cls', [entry])\n    }\n  })\n}\n\nvar performanceObserver\nvar lcpPerformanceObserver\nvar clsPerformanceObserver\nif ('PerformanceObserver' in window && typeof window.PerformanceObserver === 'function') {\n  // passing in an unknown entry type to observer could throw an exception\n  performanceObserver = new PerformanceObserver(perfObserver) // eslint-disable-line no-undef\n  try {\n    performanceObserver.observe({entryTypes: ['paint']})\n  } catch (e) {}\n\n  lcpPerformanceObserver = new PerformanceObserver(lcpObserver) // eslint-disable-line no-undef\n  try {\n    lcpPerformanceObserver.observe({entryTypes: ['largest-contentful-paint']})\n  } catch (e) {}\n\n  clsPerformanceObserver = new PerformanceObserver(clsObserver) // eslint-disable-line no-undef\n  try {\n    clsPerformanceObserver.observe({type: 'layout-shift', buffered: true})\n  } catch (e) {}\n}\n\n// first interaction and first input delay\nif ('addEventListener' in document) {\n  var fiRecorded = false\n  var allowedEventTypes = ['click', 'keydown', 'mousedown', 'pointerdown', 'touchstart']\n  allowedEventTypes.forEach(function (e) {\n    document.addEventListener(e, captureInteraction, false)\n  })\n}\n\nfunction captureInteraction(evt) {\n  if (evt instanceof origEvent && !fiRecorded) {\n    var fi = Math.round(evt.timeStamp)\n    var attributes = {\n      type: evt.type\n    }\n\n    // The value of Event.timeStamp is epoch time in some old browser, and relative\n    // timestamp in newer browsers. We assume that large numbers represent epoch time.\n    if (fi <= loader.now()) {\n      attributes['fid'] = loader.now() - fi\n    } else if (fi > loader.offset && fi <= Date.now()) {\n      fi = fi - loader.offset\n      attributes['fid'] = loader.now() - fi\n    } else {\n      fi = loader.now()\n    }\n\n    fiRecorded = true\n    handle('timing', ['fi', fi, attributes])\n  }\n}\n\n// page visibility events\nsubscribeToVisibilityChange(captureVisibilityChange)\n\nfunction captureVisibilityChange(state) {\n  handle('pageHide', [loader.now(), state])\n}\n\n},{}],26:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  generateUuid: generateUuid,\n  generateSpanId: generateSpanId,\n  generateTraceId: generateTraceId\n}\n\nfunction generateUuid () {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n\n  // v4 UUID\n  var template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  var id = ''\n  var c\n  for (var i = 0; i < template.length; i++) {\n    c = template[i]\n    if (c === 'x') {\n      id += getRandomValue().toString(16)\n    } else if (c === 'y') {\n      // this is the uuid variant per spec (8, 9, a, b)\n      // % 4, then shift to get values 8-11\n      c = getRandomValue() & 0x3 | 0x8\n      id += c.toString(16)\n    } else {\n      id += c\n    }\n  }\n\n  return id\n}\n\n// 16-character hex string (per DT spec)\nfunction generateSpanId () {\n  return generateRandomHexString(16)\n}\n\n// 32-character hex string (per DT spec)\nfunction generateTraceId() {\n  return generateRandomHexString(32)\n}\n\nfunction generateRandomHexString(length) {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues && Uint8Array) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  var chars = []\n  for (var i = 0; i < length; i++) {\n    chars.push(getRandomValue().toString(16))\n  }\n  return chars.join('')\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n}\n\n},{}],27:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Feature-detection is much preferred over using User Agent to detect browser.\n// However, there are cases where feature detection is not possible, for example\n// when a specific version of a browser has a bug that requires a workaround in just\n// that version.\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Browser_Name\nvar agentName = null\nvar agentVersion = null\nvar safari = /Version\\/(\\S+)\\s+Safari/\n\nif (navigator.userAgent) {\n  var userAgent = navigator.userAgent\n  var parts = userAgent.match(safari)\n\n  if (parts && userAgent.indexOf('Chrome') === -1 &&\n      userAgent.indexOf('Chromium') === -1) {\n    agentName = 'Safari'\n    agentVersion = parts[1]\n  }\n}\n\nmodule.exports = {\n  agent: agentName,\n  version: agentVersion,\n  match: match\n}\n\nfunction match (name, version) {\n  if (!agentName) {\n    return false\n  }\n\n  if (name !== agentName) {\n    return false\n  }\n\n  // version not provided, only match by name\n  if (!version) {\n    return true\n  }\n\n  // version provided, but not detected - not reliable match\n  if (!agentVersion) {\n    return false\n  }\n\n  var detectedParts = agentVersion.split('.')\n  var requestedParts = version.split('.')\n  for (var i = 0; i < requestedParts.length; i++) {\n    if (requestedParts[i] !== detectedParts[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n},{}],28:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = subscribeToVisibilityChange\n\nvar hidden, eventName, state\n\nif (typeof document.hidden !== 'undefined') {\n  hidden = 'hidden'\n  eventName = 'visibilitychange'\n  state = 'visibilityState'\n} else if (typeof document.msHidden !== 'undefined') {\n  hidden = 'msHidden'\n  eventName = 'msvisibilitychange'\n} else if (typeof document.webkitHidden !== 'undefined') {\n  hidden = 'webkitHidden'\n  eventName = 'webkitvisibilitychange'\n  state = 'webkitVisibilityState'\n}\n\nfunction subscribeToVisibilityChange(cb) {\n  if ('addEventListener' in document && eventName) {\n    document.addEventListener(eventName, handleVisibilityChange, false)\n  }\n\n  function handleVisibilityChange() {\n    if (state && document[state]) {\n      cb(document[state])\n    } else if (document[hidden]) {\n      cb('hidden')\n    } else {\n      cb('visible')\n    }\n  }\n}\n\n},{}],29:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = mapOwn\n\nfunction mapOwn (obj, fn) {\n  var results = []\n  var key = ''\n  var i = 0\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      results[i] = fn(key, obj[key])\n      i += 1\n    }\n  }\n\n  return results\n}\n\n},{}],30:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n\n},{}],31:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  exists: typeof (window.performance) !== 'undefined' && window.performance.timing && typeof (window.performance.timing.navigationStart) !== 'undefined'\n}\n\n},{}],\"ee\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ctxId = 'nr@context'\nvar getOrSet = require(\"gos\")\nvar mapOwn = require(29)\n\nvar eventBuffer = {}\nvar emitters = {}\n\nvar baseEE = module.exports = ee()\nmodule.exports.getOrSetContext = getOrSetContext\n\nbaseEE.backlog = eventBuffer\n\nfunction EventContext () {}\n\nfunction ee (old) {\n  var handlers = {}\n  var bufferGroupMap = {}\n\n  var emitter = {\n    on: addEventListener,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    emit: emit,\n    get: getOrCreate,\n    listeners: listeners,\n    context: context,\n    buffer: bufferEventsByGroup,\n    abort: abortIfNotLoaded,\n    aborted: false\n  }\n\n  return emitter\n\n  function context (contextOrStore) {\n    if (contextOrStore && contextOrStore instanceof EventContext) {\n      return contextOrStore\n    } else if (contextOrStore) {\n      return getOrSet(contextOrStore, ctxId, getNewContext)\n    } else {\n      return getNewContext()\n    }\n  }\n\n  function emit (type, args, contextOrStore, force, bubble) {\n    if (bubble !== false) bubble = true\n    if (baseEE.aborted && !force) { return }\n    if (old && bubble) old(type, args, contextOrStore)\n\n    var ctx = context(contextOrStore)\n    var handlersArray = listeners(type)\n    var len = handlersArray.length\n\n    // Extremely verbose debug logging\n    // if ([/^xhr/].map(function (match) {return type.match(match)}).filter(Boolean).length) {\n    //  console.log(type + ' args:')\n    //  console.log(args)\n    //  console.log(type + ' handlers array:')\n    //  console.log(handlersArray)\n    //  console.log(type + ' context:')\n    //  console.log(ctx)\n    //  console.log(type + ' ctxStore:')\n    //  console.log(ctxStore)\n    // }\n\n    // Apply each handler function in the order they were added\n    // to the context with the arguments\n\n    for (var i = 0; i < len; i++) handlersArray[i].apply(ctx, args)\n\n    // Buffer after emitting for consistent ordering\n    var bufferGroup = eventBuffer[bufferGroupMap[type]]\n    if (bufferGroup) {\n      bufferGroup.push([emitter, type, args, ctx])\n    }\n\n    // Return the context so that the module that emitted can see what was done.\n    return ctx\n  }\n\n  function addEventListener (type, fn) {\n    // Retrieve type from handlers, if it doesn't exist assign the default and retrieve it.\n    handlers[type] = listeners(type).concat(fn)\n  }\n\n  function removeEventListener (type, fn) {\n    var listeners = handlers[type]\n    if (!listeners) return\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1)\n      }\n    }\n  }\n\n  function listeners (type) {\n    return handlers[type] || []\n  }\n\n  function getOrCreate (name) {\n    return (emitters[name] = emitters[name] || ee(emit))\n  }\n\n  function bufferEventsByGroup (types, group) {\n    mapOwn(types, function (i, type) {\n      group = group || 'feature'\n      bufferGroupMap[type] = group\n      if (!(group in eventBuffer)) {\n        eventBuffer[group] = []\n      }\n    })\n  }\n}\n\n// get context object from store object, or create if does not exist\nfunction getOrSetContext(obj) {\n  return getOrSet(obj, ctxId, getNewContext)\n}\n\nfunction getNewContext () {\n  return new EventContext()\n}\n\n// abort should be called 30 seconds after the page has started running\n// We should drop our data and stop collecting if we still have a backlog, which\n// signifies the rest of the agent wasn't loaded\nfunction abortIfNotLoaded () {\n  if (eventBuffer.api || eventBuffer.feature) {\n    baseEE.aborted = true\n    eventBuffer = baseEE.backlog = {}\n  }\n}\n\n},{}],\"gos\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = getOrSet\n\n// Always returns the current value of obj[prop], even if it has to set it first\nfunction getOrSet (obj, prop, getVal) {\n  // If the value exists return it.\n  if (has.call(obj, prop)) return obj[prop]\n\n  var val = getVal()\n\n  // Attempt to set the property so it's not enumerable\n  if (Object.defineProperty && Object.keys) {\n    try {\n      Object.defineProperty(obj, prop, {\n        value: val, // old IE inherits non-write-ability\n        writable: true,\n        enumerable: false\n      })\n\n      return val\n    } catch (e) {\n      // Can't report internal errors,\n      // because GOS is a dependency of the reporting mechanisms\n    }\n  }\n\n  // fall back to setting normally\n  obj[prop] = val\n  return val\n}\n\n},{}],\"handle\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('handle')\n\n// Exported for register-handler to attach to.\nmodule.exports = handle\nhandle.ee = ee\n\nfunction handle (type, args, ctx, group) {\n  ee.buffer([type], group)\n  ee.emit(type, args, ctx)\n}\n\n},{}],\"id\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Start assigning ids at 1 so 0 can always be used for window, without\n// actually setting it (which would create a global variable).\nvar index = 1\nvar prop = 'nr@id'\nvar getOrSet = require(\"gos\")\n\nmodule.exports = id\n\n// Always returns id of obj, may tag obj with an id in the process.\nfunction id (obj) {\n  var type = typeof obj\n  // We can only tag objects, functions, and arrays with ids.\n  // For all primitive values we instead return -1.\n  if (!obj || !(type === 'object' || type === 'function')) return -1\n  if (obj === window) return 0\n\n  return getOrSet(obj, prop, function () { return index++ })\n}\n\n},{}],\"loader\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar now = require(23)\nvar handle = require(\"handle\")\nvar mapOwn = require(29)\nvar ee = require(\"ee\")\nvar userAgent = require(27)\nvar protocolAllowed = require(24)\nvar config = require(20)\n\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\nvar win = window\nvar doc = win.document\n\nvar ADD_EVENT_LISTENER = 'addEventListener'\nvar ATTACH_EVENT = 'attachEvent'\nvar XHR = win.XMLHttpRequest\nvar XHR_PROTO = XHR && XHR.prototype\n\nvar disabled = !protocolAllowed(win.location)\n\nNREUM.o = {\n  ST: setTimeout,\n  SI: win.setImmediate,\n  CT: clearTimeout,\n  XHR: XHR,\n  REQ: win.Request,\n  EV: win.Event,\n  PR: win.Promise,\n  MO: win.MutationObserver\n}\n\nvar origin = '' + location\nvar defInfo = {\n  beacon: 'bam.nr-data.net',\n  errorBeacon: 'bam.nr-data.net',\n  agent: 'js-agent.newrelic.com/nr-dev.min.js'\n}\n\nvar xhrWrappable = XHR &&\n  XHR_PROTO &&\n  XHR_PROTO[ADD_EVENT_LISTENER] &&\n  !/CriOS/.test(navigator.userAgent)\n\nvar exp = module.exports = {\n  offset: now.getLastTimestamp(),\n  now: now,\n  origin: origin,\n  features: {},\n  xhrWrappable: xhrWrappable,\n  userAgent: userAgent,\n  disabled: disabled\n}\n\nif (!protocolAllowed(win.location)) return\n\n// api loads registers several event listeners, but does not have any exports\nrequire(19)\n\n// paint timings\nrequire(25)\n\nif (doc[ADD_EVENT_LISTENER]) {\n  doc[ADD_EVENT_LISTENER]('DOMContentLoaded', loaded, false)\n  win[ADD_EVENT_LISTENER]('load', windowLoaded, false)\n} else {\n  doc[ATTACH_EVENT]('onreadystatechange', stateChange)\n  win[ATTACH_EVENT]('onload', windowLoaded)\n}\n\nhandle('mark', ['firstbyte', now.getLastTimestamp()], null, 'api')\n\nvar loadFired = 0\nfunction windowLoaded () {\n  if (loadFired++) return\n  var info = exp.info = NREUM.info\n\n  var firstScript = doc.getElementsByTagName('script')[0]\n  setTimeout(ee.abort, 30000)\n\n  if (!(info && info.licenseKey && info.applicationID && firstScript)) {\n    return ee.abort()\n  }\n\n  mapOwn(defInfo, function (key, val) {\n    // this will overwrite any falsy value in config\n    // This is intentional because agents may write an empty string to\n    // the agent key in the config, in which case we want to use the default\n    if (!info[key]) info[key] = val\n  })\n\n  var ts = now()\n  handle('mark', ['onload', ts + exp.offset], null, 'api')\n  handle('timing', ['load', ts])\n\n  var agent = doc.createElement('script')\n  agent.src = scheme + '://' + info.agent\n  firstScript.parentNode.insertBefore(agent, firstScript)\n}\n\nfunction stateChange () {\n  if (doc.readyState === 'complete') loaded()\n}\n\nfunction loaded () {\n  handle('mark', ['domContent', now() + exp.offset], null, 'api')\n}\n\n},{}],\"wrap-function\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar slice = require(30)\nvar flag = 'nr@original'\nvar has = Object.prototype.hasOwnProperty\nvar inWrapper = false\n\nmodule.exports = createWrapperWithEmitter\nmodule.exports.wrapFunction = wrapFunction\nmodule.exports.wrapInPlace = wrapInPlace\nmodule.exports.argsToArray = argsToArray\n\nfunction createWrapperWithEmitter(emitter, always) {\n  emitter || (emitter = ee)\n\n  wrapFn.inPlace = inPlace\n  wrapFn.flag = flag\n\n  return wrapFn\n\n  function wrapFn (fn, prefix, getContext, methodName, bubble) {\n    // Unless fn is both wrappable and unwrapped, return it unchanged.\n    if (notWrappable(fn)) return fn\n\n    if (!prefix) prefix = ''\n\n    nrWrapper[flag] = fn\n    copy(fn, nrWrapper, emitter)\n    return nrWrapper\n\n    function nrWrapper () {\n      var args\n      var originalThis\n      var ctx\n      var result\n\n      try {\n        originalThis = this\n        args = slice(arguments)\n\n        if (typeof getContext === 'function') {\n          ctx = getContext(args, originalThis)\n        } else {\n          ctx = getContext || {}\n        }\n      } catch (e) {\n        report([e, '', [args, originalThis, methodName], ctx], emitter)\n      }\n\n      // Warning: start events may mutate args!\n      safeEmit(prefix + 'start', [args, originalThis, methodName], ctx, bubble)\n\n      try {\n        result = fn.apply(originalThis, args)\n        return result\n      } catch (err) {\n        safeEmit(prefix + 'err', [args, originalThis, err], ctx, bubble)\n\n        // rethrow error so we don't effect execution by observing.\n        throw err\n      } finally {\n        // happens no matter what.\n        safeEmit(prefix + 'end', [args, originalThis, result], ctx, bubble)\n      }\n    }\n  }\n\n  function inPlace (obj, methods, prefix, getContext, bubble) {\n    if (!prefix) prefix = ''\n    // If prefix starts with '-' set this boolean to add the method name to\n    // the prefix before passing each one to wrap.\n    var prependMethodPrefix = (prefix.charAt(0) === '-')\n    var fn\n    var method\n    var i\n\n    for (i = 0; i < methods.length; i++) {\n      method = methods[i]\n      fn = obj[method]\n\n      // Unless fn is both wrappable and unwrapped bail,\n      // so we don't add extra properties with undefined values.\n      if (notWrappable(fn)) continue\n\n      obj[method] = wrapFn(fn, (prependMethodPrefix ? method + prefix : prefix), getContext, method, bubble)\n    }\n  }\n\n  function safeEmit (evt, arr, store, bubble) {\n    if (inWrapper && !always) return\n    var prev = inWrapper\n    inWrapper = true\n    try {\n      emitter.emit(evt, arr, store, always, bubble)\n    } catch (e) {\n      report([e, evt, arr, store], emitter)\n    }\n    inWrapper = prev\n  }\n}\n\nfunction report (args, emitter) {\n  emitter || (emitter = ee)\n  try {\n    emitter.emit('internal-error', args)\n  } catch (err) {}\n}\n\nfunction copy (from, to, emitter) {\n  if (Object.defineProperty && Object.keys) {\n    // Create accessors that proxy to actual function\n    try {\n      var keys = Object.keys(from)\n      keys.forEach(function (key) {\n        Object.defineProperty(to, key, {\n          get: function () { return from[key] },\n          set: function (val) { from[key] = val; return val }\n        })\n      })\n      return to\n    } catch (e) {\n      report([e], emitter)\n    }\n  }\n  // fall back to copying properties\n  for (var i in from) {\n    if (has.call(from, i)) {\n      to[i] = from[i]\n    }\n  }\n  return to\n}\n\nfunction notWrappable (fn) {\n  return !(fn && fn instanceof Function && fn.apply && !fn[flag])\n}\n\nfunction wrapFunction(fn, wrapper) {\n  var wrapped = wrapper(fn)\n  wrapped[flag] = fn\n  copy(fn, wrapped, ee)\n  return wrapped\n}\n\nfunction wrapInPlace(obj, fnName, wrapper) {\n  var fn = obj[fnName]\n  obj[fnName] = wrapFunction(fn, wrapper)\n}\n\nfunction argsToArray() {\n  var len = arguments.length\n  var arr = new Array(len)\n  for (var i = 0; i < len; ++i) {\n    arr[i] = arguments[i]\n  }\n  return arr\n}\n\n},{}]},{},[\"loader\",2,16,5,3,4])\n\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handle = require(\"handle\")\nvar slice = require(30)\nvar ee = require(\"ee\")\nvar loader = require(\"loader\")\nvar getOrSet = require(\"gos\")\nvar origOnerror = window.onerror\nvar handleErrors = false\nvar NR_ERR_PROP = 'nr@seenError'\n\nif (loader.disabled) return\n\n// skipNext counter to keep track of uncaught\n// errors that will be the same as caught errors.\nvar skipNext = 0\n\n// Declare that we are using err instrumentation\nloader.features.err = true\nrequire(1)\n\nwindow.onerror = onerrorHandler\n\ntry {\n  throw new Error()\n} catch (e) {\n  // Only wrap stuff if try/catch gives us useful data. It doesn't in IE < 10.\n  if ('stack' in e) {\n    require(13)\n    require(12)\n\n    if ('addEventListener' in window) {\n      require(6)\n    }\n\n    if (loader.xhrWrappable) {\n      require(14)\n    }\n\n    handleErrors = true\n  }\n}\n\nee.on('fn-start', function (args, obj, methodName) {\n  if (handleErrors) skipNext += 1\n})\n\nee.on('fn-err', function (args, obj, err) {\n  if (handleErrors && !err[NR_ERR_PROP]) {\n    getOrSet(err, NR_ERR_PROP, function getVal () {\n      return true\n    })\n    this.thrown = true\n    notice(err)\n  }\n})\n\nee.on('fn-end', function () {\n  if (!handleErrors) return\n  if (!this.thrown && skipNext > 0) skipNext -= 1\n})\n\nee.on('internal-error', function (e) {\n  handle('ierr', [e, loader.now(), true])\n})\n\n// FF and Android browsers do not provide error info to the 'error' event callback,\n// so we must use window.onerror\nfunction onerrorHandler (message, filename, lineno, column, errorObj) {\n  try {\n    if (skipNext) skipNext -= 1\n    else notice(errorObj || new UncaughtException(message, filename, lineno), true)\n  } catch (e) {\n    try {\n      handle('ierr', [e, loader.now(), true])\n    } catch (err) {\n    }\n  }\n\n  if (typeof origOnerror === 'function') return origOnerror.apply(this, slice(arguments))\n  return false\n}\n\nfunction UncaughtException (message, filename, lineno) {\n  this.message = message || 'Uncaught error with no additional information'\n  this.sourceURL = filename\n  this.line = lineno\n}\n\n// emits 'handle > error' event, which the error aggregator listens on\nfunction notice (err, doNotStamp) {\n  // by default add timestamp, unless specifically told not to\n  // this is to preserve existing behavior\n  var time = (!doNotStamp) ? loader.now() : null\n  handle('err', [err, time])\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Turn on feature\nvar loader = require(\"loader\")\n\nif (loader.disabled) return\nloader.features.ins = true\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar START = '-start'\nvar END = '-end'\nvar BODY = '-body'\nvar FN_START = 'fn' + START\nvar FN_END = 'fn' + END\nvar CB_START = 'cb' + START\nvar CB_END = 'cb' + END\nvar JS_TIME = 'jsTime'\nvar FETCH = 'fetch'\nvar ADD_EVENT_LISTENER = 'addEventListener'\n\nvar win = window\nvar location = win.location\n\nvar loader = require(\"loader\")\n\n// loader.xhrWrappable will be false in chrome for ios, but addEventListener is still available.\n// sauce does not have a browser to test this case against, so be careful when modifying this check\nif (!win[ADD_EVENT_LISTENER] || !loader.xhrWrappable || loader.disabled) return\n\nvar mutationEE = require(10)\nvar promiseEE = require(11)\nvar historyEE = require(8)\nvar eventsEE = require(6)\nvar timerEE = require(13)\nvar fetchEE = require(7)\nvar xhrEE = require(14)\nvar jsonpEE = require(9)\nvar baseEE = require(\"ee\")\nvar tracerEE = baseEE.get('tracer')\n\nrequire(16)\nloader.features.spa = true\n\n// Get after wrapping\nvar depth = 0\nvar startHash\n\nbaseEE.on(FN_START, startTimestamp)\npromiseEE.on(CB_START, startTimestamp)\njsonpEE.on(CB_START, startTimestamp)\n\nfunction startTimestamp () {\n  depth++\n  startHash = location.hash\n  this[FN_START] = loader.now()\n}\n\nbaseEE.on(FN_END, endTimestamp)\npromiseEE.on(CB_END, endTimestamp)\njsonpEE.on(CB_END, endTimestamp)\n\nfunction endTimestamp () {\n  depth--\n  if (location.hash !== startHash) {\n    trackURLChange(0, true)\n  }\n\n  var time = loader.now()\n  this[JS_TIME] = (~~this[JS_TIME]) + time - this[FN_START]\n  this[FN_END] = time\n}\n\nbaseEE.buffer([FN_START, FN_END, 'xhr-done', 'xhr-resolved'])\neventsEE.buffer([FN_START])\ntimerEE.buffer(['setTimeout' + END, 'clearTimeout' + START, FN_START])\nxhrEE.buffer([FN_START, 'new-xhr', 'send-xhr' + START])\nfetchEE.buffer([FETCH + START, FETCH + '-done', FETCH + BODY + START, FETCH + BODY + END])\nhistoryEE.buffer(['newURL'])\nmutationEE.buffer([FN_START])\npromiseEE.buffer(['propagate', CB_START, CB_END, 'executor-err', 'resolve' + START])\ntracerEE.buffer([FN_START, 'no-' + FN_START])\njsonpEE.buffer(['new-jsonp', 'cb-start', 'jsonp-error', 'jsonp-end'])\n\ntimestamp(xhrEE, 'send-xhr' + START)\ntimestamp(baseEE, 'xhr-resolved')\ntimestamp(baseEE, 'xhr-done')\ntimestamp(fetchEE, FETCH + START)\ntimestamp(fetchEE, FETCH + '-done')\ntimestamp(jsonpEE, 'new-jsonp')\ntimestamp(jsonpEE, 'jsonp-end')\ntimestamp(jsonpEE, 'cb-start')\n\nhistoryEE.on('pushState-end', trackURLChange)\nhistoryEE.on('replaceState-end', trackURLChange)\n\nfunction trackURLChange (unusedArgs, hashChangedDuringCb) {\n  historyEE.emit('newURL', ['' + location, hashChangedDuringCb])\n}\n\nwin[ADD_EVENT_LISTENER]('hashchange', trackURLChange, true)\nwin[ADD_EVENT_LISTENER]('load', trackURLChange, true)\n\nwin[ADD_EVENT_LISTENER]('popstate', function () {\n  trackURLChange(0, depth > 1)\n}, true)\n\nfunction timestamp (ee, type) {\n  ee.on(type, function () {\n    this[type] = loader.now()\n  })\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nif (!(window.performance &&\n  window.performance.timing &&\n  window.performance.getEntriesByType\n  )) return\n\nvar ee = require(\"ee\")\nvar handle = require(\"handle\")\nvar timerEE = require(13)\nvar rafEE = require(12)\n\nvar learResourceTimings = 'learResourceTimings'\nvar ADD_EVENT_LISTENER = 'addEventListener'\nvar RESOURCE_TIMING_BUFFER_FULL = 'resourcetimingbufferfull'\nvar BST_RESOURCE = 'bstResource'\nvar RESOURCE = 'resource'\nvar START = '-start'\nvar END = '-end'\nvar FN_START = 'fn' + START\nvar FN_END = 'fn' + END\nvar BST_TIMER = 'bstTimer'\nvar PUSH_STATE = 'pushState'\n\n// Turn on feature harvesting\nvar loader = require(\"loader\")\nif (loader.disabled) return\n\nloader.features.stn = true\n\n// wrap history ap\nrequire(8)\n\n// wrap events\nif ('addEventListener' in window) {\n  require(6)\n}\n\n// Cache the value of window.Event for later instanceof checks, in case someone\n// overwrites it to be a non-function.\nvar origEvent = NREUM.o.EV\n\nee.on(FN_START, function (args, target) {\n  var evt = args[0]\n  if (evt instanceof origEvent) {\n    this.bstStart = loader.now()\n  }\n})\n\nee.on(FN_END, function (args, target) {\n  var evt = args[0]\n  if (evt instanceof origEvent) {\n    handle('bst', [evt, target, this.bstStart, loader.now()])\n  }\n})\n\ntimerEE.on(FN_START, function (args, obj, type) {\n  this.bstStart = loader.now()\n  this.bstType = type\n})\n\ntimerEE.on(FN_END, function (args, target) {\n  handle(BST_TIMER, [target, this.bstStart, loader.now(), this.bstType])\n})\n\nrafEE.on(FN_START, function () {\n  this.bstStart = loader.now()\n})\n\nrafEE.on(FN_END, function (args, target) {\n  handle(BST_TIMER, [target, this.bstStart, loader.now(), 'requestAnimationFrame'])\n})\n\nee.on(PUSH_STATE + START, function (args) {\n  this.time = loader.now()\n  this.startPath = location.pathname + location.hash\n})\nee.on(PUSH_STATE + END, function (args) {\n  handle('bstHist', [location.pathname + location.hash, this.startPath, this.time])\n})\n\nif (ADD_EVENT_LISTENER in window.performance) {\n  if (window.performance['c' + learResourceTimings]) {\n    window.performance[ADD_EVENT_LISTENER](RESOURCE_TIMING_BUFFER_FULL, function (e) {\n      handle(BST_RESOURCE, [window.performance.getEntriesByType(RESOURCE)])\n      window.performance['c' + learResourceTimings]()\n    }, false)\n  } else {\n    window.performance[ADD_EVENT_LISTENER]('webkit' + RESOURCE_TIMING_BUFFER_FULL, function (e) {\n      handle(BST_RESOURCE, [window.performance.getEntriesByType(RESOURCE)])\n      window.performance['webkitC' + learResourceTimings]()\n    }, false)\n  }\n}\n\ndocument[ADD_EVENT_LISTENER]('scroll', noOp, {passive: true})\ndocument[ADD_EVENT_LISTENER]('keypress', noOp, false)\ndocument[ADD_EVENT_LISTENER]('click', noOp, false)\n\nfunction noOp (e) { /* no-op */ }\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('events')\nvar wrapFn = require(\"wrap-function\")(ee, true)\nvar getOrSet = require(\"gos\")\n\nvar XHR = XMLHttpRequest\nvar ADD_EVENT_LISTENER = 'addEventListener'\nvar REMOVE_EVENT_LISTENER = 'removeEventListener'\n\nmodule.exports = ee\n\n// Guard against instrumenting environments w/o necessary features\nif ('getPrototypeOf' in Object) {\n  findAndWrapNode(document)\n  findAndWrapNode(window)\n  findAndWrapNode(XHR.prototype)\n} else if (XHR.prototype.hasOwnProperty(ADD_EVENT_LISTENER)) {\n  wrapNode(window)\n  wrapNode(XHR.prototype)\n}\n\nee.on(ADD_EVENT_LISTENER + '-start', function (args, target) {\n  var originalListener = args[1]\n\n  var wrapped = getOrSet(originalListener, 'nr@wrapped', function () {\n    var listener = {\n      object: wrapHandleEvent,\n      'function': originalListener\n    }[typeof originalListener]\n\n    return listener ? wrapFn(listener, 'fn-', null, (listener.name || 'anonymous')) : originalListener\n\n    function wrapHandleEvent () {\n      if (typeof originalListener.handleEvent !== 'function') return\n      return originalListener.handleEvent.apply(originalListener, arguments)\n    }\n  })\n\n  this.wrapped = args[1] = wrapped\n})\n\nee.on(REMOVE_EVENT_LISTENER + '-start', function (args) {\n  args[1] = this.wrapped || args[1]\n})\n\nfunction findAndWrapNode (object) {\n  var step = object\n  while (step && !step.hasOwnProperty(ADD_EVENT_LISTENER)) { step = Object.getPrototypeOf(step) }\n  if (step) { wrapNode(step) }\n}\n\nfunction wrapNode (node) {\n  wrapFn.inPlace(node, [ADD_EVENT_LISTENER, REMOVE_EVENT_LISTENER], '-', uniqueListener)\n}\n\nfunction uniqueListener (args, obj) {\n  // Context for the listener is stored on itself.\n  return args[1]\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('fetch')\nvar slice = require(30)\nvar mapOwn = require(29)\n\nmodule.exports = ee\n\nvar win = window\nvar prefix = 'fetch-'\nvar bodyPrefix = prefix + 'body-'\nvar bodyMethods = ['arrayBuffer', 'blob', 'json', 'text', 'formData']\nvar Req = win.Request\nvar Res = win.Response\nvar fetch = win.fetch\nvar proto = 'prototype'\nvar ctxId = 'nr@context'\n\nif (!(Req && Res && fetch)) {\n  return\n}\n\nmapOwn(bodyMethods, function (i, name) {\n  wrapPromiseMethod(Req[proto], name, bodyPrefix)\n  wrapPromiseMethod(Res[proto], name, bodyPrefix)\n})\n\nwrapPromiseMethod(win, 'fetch', prefix)\n\nee.on(prefix + 'end', function (err, res) {\n  var ctx = this\n  if (res) {\n    var size = res.headers.get('content-length')\n    if (size !== null) {\n      ctx.rxSize = size\n    }\n    ee.emit(prefix + 'done', [null, res], ctx)\n  } else {\n    ee.emit(prefix + 'done', [err], ctx)\n  }\n})\n\nfunction wrapPromiseMethod (target, name, prefix) {\n  var fn = target[name]\n  if (typeof fn === 'function') {\n    target[name] = function () {\n      var args = slice(arguments)\n\n      var ctx = {}\n      // we are wrapping args in an array so we can preserve the reference\n      ee.emit(prefix + 'before-start', [args], ctx)\n      var dtPayload\n      if (ctx[ctxId] && ctx[ctxId].dt) dtPayload = ctx[ctxId].dt\n\n      var promise = fn.apply(this, args)\n\n      ee.emit(prefix + 'start', [args, dtPayload], promise)\n\n      return promise.then(function (val) {\n        ee.emit(prefix + 'end', [null, val], promise)\n        return val\n      }, function (err) {\n        ee.emit(prefix + 'end', [err], promise)\n        throw err\n      })\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// History pushState wrapper\nvar ee = require(\"ee\").get('history')\nvar wrapFn = require(\"wrap-function\")(ee)\n\nmodule.exports = ee\n\nvar prototype = window.history && window.history.constructor && window.history.constructor.prototype\nvar object = window.history\nif (prototype && prototype.pushState && prototype.replaceState) {\n  object = prototype\n}\nwrapFn.inPlace(object, [ 'pushState', 'replaceState' ], '-')\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('jsonp')\nvar wrapFn = require(\"wrap-function\")(ee)\n\nmodule.exports = ee\n\nif (!shouldWrap()) return\n\nvar CALLBACK_REGEX = /[?&](?:callback|cb)=([^&#]+)/\nvar PARENT_REGEX = /(.*)\\.([^.]+)/\nvar VALUE_REGEX = /^(\\w+)(\\.|$)(.*)$/\nvar domInsertMethods = ['appendChild', 'insertBefore', 'replaceChild']\n\n// JSONP works by dynamically inserting <script> elements - wrap DOM methods for\n// inserting elements to detect insertion of JSONP-specific elements.\nif (Node && Node.prototype && Node.prototype.appendChild) {\n  wrapFn.inPlace(Node.prototype, domInsertMethods, 'dom-')\n} else {\n  wrapFn.inPlace(HTMLElement.prototype, domInsertMethods, 'dom-')\n  wrapFn.inPlace(HTMLHeadElement.prototype, domInsertMethods, 'dom-')\n  wrapFn.inPlace(HTMLBodyElement.prototype, domInsertMethods, 'dom-')\n}\n\nee.on('dom-start', function (args) {\n  wrapElement(args[0])\n})\n\n// subscribe to events on the JSONP <script> element and wrap the JSONP callback\n// in order to track start and end of the interaction node\nfunction wrapElement (el) {\n  var isScript = el && typeof el.nodeName === 'string' &&\n    el.nodeName.toLowerCase() === 'script'\n  if (!isScript) return\n\n  var isValidElement = typeof el.addEventListener === 'function'\n  if (!isValidElement) return\n\n  var callbackName = extractCallbackName(el.src)\n  if (!callbackName) return\n\n  var callback = discoverParent(callbackName)\n  var validCallback = typeof callback.parent[callback.key] === 'function'\n  if (!validCallback) return\n\n  // At this point we know that the element is a valid JSONP script element.\n  // The following events are emitted during the lifetime of a JSONP call:\n  // * immediately emit `new-jsonp` to notify start of the JSONP work\n  // * the wrapped callback will emit `cb-start` and `cb-end` during the execution\n  //   of the callback, here we can inspect the response\n  // * when the element emits the `load` event (script loaded and executed),\n  //   emit `jsonp-end` to notify end of the JSONP work\n  // * if the element emits the `error` event, in response emit `jsonp-error`\n  //   (and `jsonp-end`). Note that the callback in this case will likely not get\n  //   called.\n\n  var context = {}\n  wrapFn.inPlace(callback.parent, [callback.key], 'cb-', context)\n\n  el.addEventListener('load', onLoad, false)\n  el.addEventListener('error', onError, false)\n  ee.emit('new-jsonp', [el.src], context)\n\n  function onLoad () {\n    ee.emit('jsonp-end', [], context)\n    el.removeEventListener('load', onLoad, false)\n    el.removeEventListener('error', onError, false)\n  }\n\n  function onError () {\n    ee.emit('jsonp-error', [], context)\n    ee.emit('jsonp-end', [], context)\n    el.removeEventListener('load', onLoad, false)\n    el.removeEventListener('error', onError, false)\n  }\n}\n\nfunction shouldWrap () {\n  return 'addEventListener' in window\n}\n\nfunction extractCallbackName (src) {\n  var matches = src.match(CALLBACK_REGEX)\n  return matches ? matches[1] : null\n}\n\nfunction discoverValue (longKey, obj) {\n  var matches = longKey.match(VALUE_REGEX)\n  var key = matches[1]\n  var remaining = matches[3]\n  if (!remaining) {\n    return obj[key]\n  }\n  return discoverValue(remaining, obj[key])\n}\n\nfunction discoverParent (key) {\n  var matches = key.match(PARENT_REGEX)\n  if (matches && matches.length >= 3) {\n    return {\n      key: matches[2],\n      parent: discoverValue(matches[1], window)\n    }\n  }\n  return {\n    key: key,\n    parent: window\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('mutation')\nvar wrapFn = require(\"wrap-function\")(ee)\nvar OriginalObserver = NREUM.o.MO\n\nmodule.exports = ee\n\nif (OriginalObserver) {\n  window.MutationObserver = function WrappedMutationObserver (cb) {\n    if (this instanceof OriginalObserver) {\n      return new OriginalObserver(wrapFn(cb, 'fn-'))\n    } else {\n      return OriginalObserver.apply(this, arguments)\n    }\n  }\n\n  MutationObserver.prototype = OriginalObserver.prototype\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar wrapFn = require(\"wrap-function\")\nvar promiseEE = require(\"ee\").get('promise')\nvar getContext = require(\"ee\").getOrSetContext\nvar promiseWrapper = wrapFn(promiseEE)\nvar mapOwn = require(29)\nvar OriginalPromise = NREUM.o.PR\n\nmodule.exports = promiseEE\n\nif (!OriginalPromise) return\n\nwindow.Promise = WrappedPromise\n\n;['all', 'race'].forEach(function (method) {\n  var original = OriginalPromise[method]\n  OriginalPromise[method] = function (subPromises) {\n    var finalized = false\n    mapOwn(subPromises, function (i, sub) {\n      Promise.resolve(sub).then(setNrId(method === 'all'), setNrId(false))\n    })\n\n    var originalReturnValue = original.apply(OriginalPromise, arguments)\n    var promise = OriginalPromise.resolve(originalReturnValue)\n\n    return promise\n\n    function setNrId (overwrite) {\n      return function () {\n        promiseEE.emit('propagate', [null, !finalized], originalReturnValue, false, false)\n        finalized = finalized || !overwrite\n      }\n    }\n  }\n})\n\n;['resolve', 'reject'].forEach(function (method) {\n  var original = OriginalPromise[method]\n  OriginalPromise[method] = function (val) {\n    var returnVal = original.apply(OriginalPromise, arguments)\n    if (val !== returnVal) {\n      promiseEE.emit('propagate', [val, true], returnVal, false, false)\n    }\n\n    return returnVal\n  }\n})\n\nOriginalPromise.prototype['catch'] = function wrappedCatch (fn) {\n  return this.then(null, fn)\n}\n\nOriginalPromise.prototype = Object.create(OriginalPromise.prototype, {\n  constructor: {value: WrappedPromise}\n})\n\nmapOwn(Object.getOwnPropertyNames(OriginalPromise), function copy (i, key) {\n  try {\n    WrappedPromise[key] = OriginalPromise[key]\n  } catch (err) {\n    // ignore properties we can't copy\n  }\n})\n\nfunction WrappedPromise (executor) {\n  var ctx = promiseEE.context()\n  var wrappedExecutor = promiseWrapper(executor, 'executor-', ctx, null, false)\n\n  var promise = new OriginalPromise(wrappedExecutor)\n\n  promiseEE.context(promise).getCtx = function () {\n    return ctx\n  }\n\n  return promise\n}\n\nwrapFn.wrapInPlace(OriginalPromise.prototype, 'then', function wrapThen(original) {\n  return function wrappedThen() {\n    var originalThis = this\n    var args = wrapFn.argsToArray.apply(this, arguments)\n\n    var ctx = getContext(originalThis)\n    ctx.promise = originalThis\n    args[0] = promiseWrapper(args[0], 'cb-', ctx, null, false)\n    args[1] = promiseWrapper(args[1], 'cb-', ctx, null, false)\n\n    var result = original.apply(this, args)\n\n    ctx.nextPromise = result\n    promiseEE.emit('propagate', [originalThis, true], result, false, false)\n\n    return result\n  }\n})\n\npromiseEE.on('executor-start', function (args) {\n  args[0] = promiseWrapper(args[0], 'resolve-', this, null, false)\n  args[1] = promiseWrapper(args[1], 'resolve-', this, null, false)\n})\n\npromiseEE.on('executor-err', function (args, originalThis, err) {\n  args[1](err)\n})\n\npromiseEE.on('cb-end', function (args, originalThis, result) {\n  promiseEE.emit('propagate', [result, true], this.nextPromise, false, false)\n})\n\npromiseEE.on('propagate', function (val, overwrite, trigger) {\n  if (!this.getCtx || overwrite) {\n    this.getCtx = function () {\n      if (val instanceof Promise) {\n        var store = promiseEE.context(val)\n      }\n\n      return store && store.getCtx ? store.getCtx() : this\n    }\n  }\n})\n\nWrappedPromise.toString = function () {\n  return '' + OriginalPromise\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Request Animation Frame wrapper\nvar ee = require(\"ee\").get('raf')\nvar wrapFn = require(\"wrap-function\")(ee)\n\nvar equestAnimationFrame = 'equestAnimationFrame'\n\nmodule.exports = ee\n\nwrapFn.inPlace(window, [\n  'r' + equestAnimationFrame,\n  'mozR' + equestAnimationFrame,\n  'webkitR' + equestAnimationFrame,\n  'msR' + equestAnimationFrame\n], 'raf-')\n\nee.on('raf-start', function (args) {\n  // Wrap the callback handed to requestAnimationFrame\n  args[0] = wrapFn(args[0], 'fn-')\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('timer')\nvar wrapFn = require(\"wrap-function\")(ee)\n\nvar SET_TIMEOUT = 'setTimeout'\nvar SET_INTERVAL = 'setInterval'\nvar CLEAR_TIMEOUT = 'clearTimeout'\nvar START = '-start'\nvar DASH = '-'\n\nmodule.exports = ee\n\nwrapFn.inPlace(window, [SET_TIMEOUT, 'setImmediate'], SET_TIMEOUT + DASH)\nwrapFn.inPlace(window, [SET_INTERVAL], SET_INTERVAL + DASH)\nwrapFn.inPlace(window, [CLEAR_TIMEOUT, 'clearImmediate'], CLEAR_TIMEOUT + DASH)\n\nee.on(SET_INTERVAL + START, interval)\nee.on(SET_TIMEOUT + START, timer)\n\nfunction interval (args, obj, type) {\n  args[0] = wrapFn(args[0], 'fn-', null, type)\n}\n\nfunction timer (args, obj, type) {\n  this.method = type\n  this.timerDuration = isNaN(args[1]) ? 0 : +args[1]\n  args[0] = wrapFn(args[0], 'fn-', this, type)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// wrap-events patches XMLHttpRequest.prototype.addEventListener for us.\nrequire(6)\n\nvar baseEE = require(\"ee\")\nvar ee = baseEE.get('xhr')\nvar wrapFn = require(\"wrap-function\")(ee)\nvar originals = NREUM.o\nvar OrigXHR = originals.XHR\nvar MutationObserver = originals.MO\nvar Promise = originals.PR\nvar setImmediate = originals.SI\n\nvar READY_STATE_CHANGE = 'readystatechange'\n\nvar handlers = ['onload', 'onerror', 'onabort', 'onloadstart', 'onloadend', 'onprogress', 'ontimeout']\nvar pendingXhrs = []\n\nmodule.exports = ee\n\nvar XHR = window.XMLHttpRequest = function (opts) {\n  var xhr = new OrigXHR(opts)\n  try {\n    ee.emit('new-xhr', [xhr], xhr)\n    xhr.addEventListener(READY_STATE_CHANGE, wrapXHR, false)\n  } catch (e) {\n    try {\n      ee.emit('internal-error', [e])\n    } catch (err) {}\n  }\n  return xhr\n}\n\ncopy(OrigXHR, XHR)\n\nXHR.prototype = OrigXHR.prototype\n\nwrapFn.inPlace(XHR.prototype, ['open', 'send'], '-xhr-', getObject)\n\nee.on('send-xhr-start', function (args, xhr) {\n  wrapOnreadystatechange(args, xhr)\n  enqueuePendingXhr(xhr)\n})\nee.on('open-xhr-start', wrapOnreadystatechange)\n\nfunction wrapOnreadystatechange (args, xhr) {\n  wrapFn.inPlace(xhr, ['onreadystatechange'], 'fn-', getObject)\n}\n\nfunction wrapXHR () {\n  var xhr = this\n  var ctx = ee.context(xhr)\n\n  if (xhr.readyState > 3 && !ctx.resolved) {\n    ctx.resolved = true\n    ee.emit('xhr-resolved', [], xhr)\n  }\n\n  wrapFn.inPlace(xhr, handlers, 'fn-', getObject)\n}\n\n// Wrapping the onreadystatechange property of XHRs takes some special tricks.\n//\n// The issue is that the onreadystatechange property may be assigned *after*\n// send() is called against an XHR. This is of particular importance because\n// jQuery uses a single onreadystatechange handler to implement all of the XHR\n// callbacks thtat it provides, and it assigns that property after calling send.\n//\n// There are several 'obvious' approaches to wrapping the onreadystatechange\n// when it's assigned after send:\n//\n// 1. Try to wrap the onreadystatechange handler from a readystatechange\n//    addEventListener callback (the addEventListener callback will fire before\n//    the onreadystatechange callback).\n//\n//      Caveat: this doesn't work in Chrome or Safari, and in fact will cause\n//      the onreadystatechange handler to not be invoked at all during the\n//      firing cycle in which it is wrapped, which may break applications :(\n//\n// 2. Use Object.defineProperty to create a setter for the onreadystatechange\n//    property, and wrap from that setter.\n//\n//      Caveat: onreadystatechange is not a configurable property in Safari or\n//      older versions of the Android browser.\n//\n// 3. Schedule wrapping of the onreadystatechange property using a setTimeout\n//    call issued just before the call to send.\n//\n//      Caveat: sometimes, the onreadystatechange handler fires before the\n//      setTimeout, meaning the wrapping happens too late.\n//\n// The setTimeout approach is closest to what we use here: we want to schedule\n// the wrapping of the onreadystatechange property when send is called, but\n// ensure that our wrapping happens before onreadystatechange has a chance to\n// fire.\n//\n// We achieve this using a hybrid approach:\n//\n// * In browsers that support MutationObserver, we use that to schedule wrapping\n//   of onreadystatechange.\n//\n// * We have discovered that MutationObserver in IE causes a memory leak, so we\n//   now will prefer setImmediate for IE, and use a resolved promise to schedule\n//   the wrapping in Edge (and other browsers that support promises)\n//\n// * In older browsers that don't support MutationObserver, we rely on the fact\n//   that the call to send is probably happening within a callback that we've\n//   already wrapped, and use our existing fn-end event callback to wrap the\n//   onreadystatechange at the end of the current callback.\n//\n\nif (MutationObserver) {\n  var resolved = Promise && Promise.resolve()\n  if (!setImmediate && !Promise) {\n    var toggle = 1\n    var dummyNode = document.createTextNode(toggle)\n    new MutationObserver(drainPendingXhrs).observe(dummyNode, { characterData: true })\n  }\n} else {\n  baseEE.on('fn-end', function (args) {\n    // We don't want to try to wrap onreadystatechange from within a\n    // readystatechange callback.\n    if (args[0] && args[0].type === READY_STATE_CHANGE) return\n    drainPendingXhrs()\n  })\n}\n\nfunction enqueuePendingXhr (xhr) {\n  pendingXhrs.push(xhr)\n  if (MutationObserver) {\n    if (resolved) {\n      resolved.then(drainPendingXhrs)\n    } else if (setImmediate) {\n      setImmediate(drainPendingXhrs)\n    } else {\n      toggle = -toggle\n      dummyNode.data = toggle\n    }\n  }\n}\n\nfunction drainPendingXhrs () {\n  for (var i = 0; i < pendingXhrs.length; i++) {\n    wrapOnreadystatechange([], pendingXhrs[i])\n  }\n  if (pendingXhrs.length) pendingXhrs = []\n}\n\n// Use the object these methods are on as their\n// context store for the event emitter\nfunction getObject (args, obj) {\n  return obj\n}\n\nfunction copy (from, to) {\n  for (var i in from) {\n    to[i] = from[i]\n  }\n  return to\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar uniqueId = require(26)\nvar parseUrl = require(17)\n\nmodule.exports = {\n  generateTracePayload: generateTracePayload,\n  shouldGenerateTrace: shouldGenerateTrace\n}\n\nfunction generateTracePayload (parsedOrigin) {\n  if (!shouldGenerateTrace(parsedOrigin)) {\n    return null\n  }\n\n  var nr = window.NREUM\n  if (!nr.loader_config) {\n    return null\n  }\n\n  var accountId = (nr.loader_config.accountID || '').toString() || null\n  var agentId = (nr.loader_config.agentID || '').toString() || null\n  var trustKey = (nr.loader_config.trustKey || '').toString() || null\n\n  if (!accountId || !agentId) {\n    return null\n  }\n\n  var spanId = uniqueId.generateSpanId()\n  var traceId = uniqueId.generateTraceId()\n  var timestamp = Date.now()\n\n  var payload = {\n    spanId: spanId,\n    traceId: traceId,\n    timestamp: timestamp\n  }\n\n  if (parsedOrigin.sameOrigin ||\n      (isAllowedOrigin(parsedOrigin) && useTraceContextHeadersForCors())) {\n    payload.traceContextParentHeader = generateTraceContextParentHeader(spanId, traceId)\n    payload.traceContextStateHeader = generateTraceContextStateHeader(spanId, timestamp,\n      accountId, agentId, trustKey)\n  }\n\n  if ((parsedOrigin.sameOrigin && !excludeNewrelicHeader()) ||\n      (!parsedOrigin.sameOrigin && isAllowedOrigin(parsedOrigin) && useNewrelicHeaderForCors())) {\n    payload.newrelicHeader = generateTraceHeader(spanId, traceId, timestamp, accountId,\n      agentId, trustKey)\n  }\n\n  return payload\n}\n\nfunction generateTraceContextParentHeader(spanId, traceId) {\n  return '00-' + traceId + '-' + spanId + '-01'\n}\n\nfunction generateTraceContextStateHeader(spanId, timestamp, accountId, appId, trustKey) {\n  var version = 0\n  var transactionId = ''\n  var parentType = 1\n  var sampled = ''\n  var priority = ''\n\n  return trustKey + '@nr=' + version + '-' + parentType + '-' + accountId +\n    '-' + appId + '-' + spanId + '-' + transactionId + '-' + sampled + '-' + priority + '-' + timestamp\n}\n\nfunction generateTraceHeader (spanId, traceId, timestamp, accountId, appId, trustKey) {\n  var hasBtoa = ('btoa' in window && typeof window.btoa === 'function')\n  if (!hasBtoa) {\n    return null\n  }\n\n  var payload = {\n    v: [0, 1],\n    d: {\n      ty: 'Browser',\n      ac: accountId,\n      ap: appId,\n      id: spanId,\n      tr: traceId,\n      ti: timestamp\n    }\n  }\n  if (trustKey && accountId !== trustKey) {\n    payload.d.tk = trustKey\n  }\n\n  return btoa(JSON.stringify(payload))\n}\n\n// return true if DT is enabled and the origin is allowed, either by being\n// same-origin, or included in the allowed list\nfunction shouldGenerateTrace (parsedOrigin) {\n  return isDtEnabled() && isAllowedOrigin(parsedOrigin)\n}\n\nfunction isAllowedOrigin(parsedOrigin) {\n  var allowed = false\n  var dtConfig = {}\n\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    dtConfig = NREUM.init.distributed_tracing\n  }\n\n  if (parsedOrigin.sameOrigin) {\n    allowed = true\n  } else if (dtConfig.allowed_origins instanceof Array) {\n    for (var i = 0; i < dtConfig.allowed_origins.length; i++) {\n      var allowedOrigin = parseUrl(dtConfig.allowed_origins[i])\n      if (parsedOrigin.hostname === allowedOrigin.hostname &&\n          parsedOrigin.protocol === allowedOrigin.protocol &&\n          parsedOrigin.port === allowedOrigin.port) {\n        allowed = true\n        break\n      }\n    }\n  }\n  return allowed\n}\n\nfunction isDtEnabled() {\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    return !!NREUM.init.distributed_tracing.enabled\n  }\n  return false\n}\n\n// exclude the newrelic header for same-origin calls\nfunction excludeNewrelicHeader() {\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    return !!NREUM.init.distributed_tracing.exclude_newrelic_header\n  }\n  return false\n}\n\nfunction useNewrelicHeaderForCors() {\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    return NREUM.init.distributed_tracing.cors_use_newrelic_header !== false\n  }\n  return false\n}\n\nfunction useTraceContextHeadersForCors() {\n  if ('init' in NREUM && 'distributed_tracing' in NREUM.init) {\n    return !!NREUM.init.distributed_tracing.cors_use_tracecontext_headers\n  }\n  return false\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar loader = require(\"loader\")\n\n// Don't instrument Chrome for iOS, it is buggy and acts like there are URL verification issues\nif (!loader.xhrWrappable || loader.disabled) return\n\nvar handle = require(\"handle\")\nvar parseUrl = require(17)\nvar generateTracePayload = require(15).generateTracePayload\nvar ee = require(\"ee\")\nvar handlers = [ 'load', 'error', 'abort', 'timeout' ]\nvar handlersLen = handlers.length\nvar id = require(\"id\")\nvar ffVersion = require(22)\nvar dataSize = require(21)\nvar responseSizeFromXhr = require(18)\n\nvar origXHR = window.XMLHttpRequest\n\n// Declare that we are using xhr instrumentation\nloader.features.xhr = true\n\nrequire(14)\nrequire(7)\n\n// Setup the context for each new xhr object\nee.on('new-xhr', function (xhr) {\n  var ctx = this\n  ctx.totalCbs = 0\n  ctx.called = 0\n  ctx.cbTime = 0\n  ctx.end = end\n  ctx.ended = false\n  ctx.xhrGuids = {}\n  ctx.lastSize = null\n  ctx.loadCaptureCalled = false\n\n  xhr.addEventListener('load', function (event) {\n    captureXhrData(ctx, xhr)\n  }, false)\n\n  // In Firefox 34+, XHR ProgressEvents report pre-content-decoding sizes via\n  // their 'loaded' property, rather than post-decoding sizes. We want\n  // post-decoding sizes for consistency with browsers where that's all we have.\n  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1227674\n  //\n  // In really old versions of Firefox (older than somewhere between 5 and 10),\n  // we don't reliably get a final XHR ProgressEvent which reflects the full\n  // size of the transferred resource.\n  //\n  // So, in both of these cases, we fall back to not using ProgressEvents to\n  // measure XHR sizes.\n\n  if (ffVersion && (ffVersion > 34 || ffVersion < 10)) return\n\n  // In Opera, ProgressEvents report loaded values that are too high.\n  if (window.opera) return\n\n  xhr.addEventListener('progress', function (event) {\n    ctx.lastSize = event.loaded\n  }, false)\n})\n\nee.on('open-xhr-start', function (args) {\n  this.params = { method: args[0] }\n  addUrl(this, args[1])\n  this.metrics = {}\n})\n\nee.on('open-xhr-end', function (args, xhr) {\n  if ('loader_config' in NREUM && 'xpid' in NREUM.loader_config && this.sameOrigin) {\n    xhr.setRequestHeader('X-NewRelic-ID', NREUM.loader_config.xpid)\n  }\n\n  var payload = generateTracePayload(this.parsedOrigin)\n  if (payload) {\n    var added = false\n    if (payload.newrelicHeader) {\n      xhr.setRequestHeader('newrelic', payload.newrelicHeader)\n      added = true\n    }\n    if (payload.traceContextParentHeader) {\n      xhr.setRequestHeader('traceparent', payload.traceContextParentHeader)\n      if (payload.traceContextStateHeader) {\n        xhr.setRequestHeader('tracestate', payload.traceContextStateHeader)\n      }\n      added = true\n    }\n    if (added) {\n      this.dt = payload\n    }\n  }\n})\n\nee.on('send-xhr-start', function (args, xhr) {\n  var metrics = this.metrics\n  var data = args[0]\n  var context = this\n\n  if (metrics && data) {\n    var size = dataSize(data)\n    if (size) metrics.txSize = size\n  }\n\n  this.startTime = loader.now()\n\n  this.listener = function (evt) {\n    try {\n      if (evt.type === 'abort' && !(context.loadCaptureCalled)) {\n        context.params.aborted = true\n      }\n      if (evt.type !== 'load' || (context.called === context.totalCbs) && (context.onloadCalled || typeof (xhr.onload) !== 'function')) context.end(xhr)\n    } catch (e) {\n      try {\n        ee.emit('internal-error', [e])\n      } catch (err) {}\n    }\n  }\n\n  for (var i = 0; i < handlersLen; i++) {\n    xhr.addEventListener(handlers[i], this.listener, false)\n  }\n})\n\nee.on('xhr-cb-time', function (time, onload, xhr) {\n  this.cbTime += time\n  if (onload) this.onloadCalled = true\n  else this.called += 1\n  if ((this.called === this.totalCbs) && (this.onloadCalled || typeof (xhr.onload) !== 'function')) this.end(xhr)\n})\n\nee.on('xhr-load-added', function (cb, useCapture) {\n  // Ignore if the same arguments are passed to addEventListener twice\n  var idString = '' + id(cb) + !!useCapture\n  if (!this.xhrGuids || this.xhrGuids[idString]) return\n  this.xhrGuids[idString] = true\n\n  this.totalCbs += 1\n})\n\nee.on('xhr-load-removed', function (cb, useCapture) {\n  // Ignore if event listener didn't exist for this xhr object\n  var idString = '' + id(cb) + !!useCapture\n  if (!this.xhrGuids || !this.xhrGuids[idString]) return\n  delete this.xhrGuids[idString]\n\n  this.totalCbs -= 1\n})\n\n// Listen for load listeners to be added to xhr objects\nee.on('addEventListener-end', function (args, xhr) {\n  if (xhr instanceof origXHR && args[0] === 'load') ee.emit('xhr-load-added', [args[1], args[2]], xhr)\n})\n\nee.on('removeEventListener-end', function (args, xhr) {\n  if (xhr instanceof origXHR && args[0] === 'load') ee.emit('xhr-load-removed', [args[1], args[2]], xhr)\n})\n\n// Listen for those load listeners to be called.\nee.on('fn-start', function (args, xhr, methodName) {\n  if (xhr instanceof origXHR) {\n    if (methodName === 'onload') this.onload = true\n    if ((args[0] && args[0].type) === 'load' || this.onload) this.xhrCbStart = loader.now()\n  }\n})\n\nee.on('fn-end', function (args, xhr) {\n  if (this.xhrCbStart) ee.emit('xhr-cb-time', [loader.now() - this.xhrCbStart, this.onload, xhr], xhr)\n})\n\nee.on('fetch-before-start', function (args) {\n  var opts = args[1] || {}\n  var url\n  // argument is USVString\n  if (typeof args[0] === 'string') {\n    url = args[0]\n  // argument is Request object\n  } else if (args[0] && args[0].url) {\n    url = args[0].url\n  // argument is URL object\n  } else if (window.URL && args[0] && args[0] instanceof URL) {\n    url = args[0].href\n  }\n\n  if (url) {\n    this.parsedOrigin = parseUrl(url)\n    this.sameOrigin = this.parsedOrigin.sameOrigin\n  }\n\n  var payload = generateTracePayload(this.parsedOrigin)\n  if (!payload || (!payload.newrelicHeader && !payload.traceContextParentHeader)) {\n    return\n  }\n\n  if (typeof args[0] === 'string' || (window.URL && args[0] && args[0] instanceof URL)) {\n    var clone = {}\n\n    for (var key in opts) {\n      clone[key] = opts[key]\n    }\n\n    clone.headers = new Headers(opts.headers || {})\n    if (addHeaders(clone.headers, payload)) {\n      this.dt = payload\n    }\n\n    if (args.length > 1) {\n      args[1] = clone\n    } else {\n      args.push(clone)\n    }\n  } else if (args[0] && args[0].headers) {\n    if (addHeaders(args[0].headers, payload)) {\n      this.dt = payload\n    }\n  }\n\n  function addHeaders(headersObj, payload) {\n    var added = false\n    if (payload.newrelicHeader) {\n      headersObj.set('newrelic', payload.newrelicHeader)\n      added = true\n    }\n    if (payload.traceContextParentHeader) {\n      headersObj.set('traceparent', payload.traceContextParentHeader)\n      if (payload.traceContextStateHeader) {\n        headersObj.set('tracestate', payload.traceContextStateHeader)\n      }\n      added = true\n    }\n    return added\n  }\n})\n\n// Create report for XHR request that has finished\nfunction end (xhr) {\n  var params = this.params\n  var metrics = this.metrics\n\n  if (this.ended) return\n  this.ended = true\n\n  for (var i = 0; i < handlersLen; i++) {\n    xhr.removeEventListener(handlers[i], this.listener, false)\n  }\n\n  if (params.aborted) return\n  metrics.duration = loader.now() - this.startTime\n  if (!this.loadCaptureCalled && xhr.readyState === 4) {\n    captureXhrData(this, xhr)\n  } else if (params.status == null) {\n    params.status = 0\n  }\n\n  // Always send cbTime, even if no noticeable time was taken.\n  metrics.cbTime = this.cbTime\n  ee.emit('xhr-done', [xhr], xhr)\n  handle('xhr', [params, metrics, this.startTime])\n}\n\nfunction addUrl (ctx, url) {\n  var parsed = parseUrl(url)\n  var params = ctx.params\n\n  params.host = parsed.hostname + ':' + parsed.port\n  params.pathname = parsed.pathname\n  ctx.parsedOrigin = parseUrl(url)\n  ctx.sameOrigin = ctx.parsedOrigin.sameOrigin\n}\n\nfunction captureXhrData (ctx, xhr) {\n  ctx.params.status = xhr.status\n\n  var size = responseSizeFromXhr(xhr, ctx.lastSize)\n  if (size) ctx.metrics.rxSize = size\n\n  if (ctx.sameOrigin) {\n    var header = xhr.getResponseHeader('X-NewRelic-App-Data')\n    if (header) {\n      ctx.params.cat = header.split(', ').pop()\n    }\n  }\n\n  ctx.loadCaptureCalled = true\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stringsToParsedUrls = {}\n\nmodule.exports = function parseUrl (url) {\n  if (url in stringsToParsedUrls) {\n    return stringsToParsedUrls[url]\n  }\n\n  var urlEl = document.createElement('a')\n  var location = window.location\n  var ret = {}\n\n  // Use an anchor dom element to resolve the url natively.\n  urlEl.href = url\n\n  ret.port = urlEl.port\n\n  var firstSplit = urlEl.href.split('://')\n\n  if (!ret.port && firstSplit[1]) {\n    ret.port = firstSplit[1].split('/')[0].split('@').pop().split(':')[1]\n  }\n  if (!ret.port || ret.port === '0') ret.port = (firstSplit[0] === 'https' ? '443' : '80')\n\n  // Host not provided in IE for relative urls\n  ret.hostname = (urlEl.hostname || location.hostname)\n\n  ret.pathname = urlEl.pathname\n\n  ret.protocol = firstSplit[0]\n\n  // Pathname sometimes doesn't have leading slash (IE 8 and 9)\n  if (ret.pathname.charAt(0) !== '/') ret.pathname = '/' + ret.pathname\n\n  // urlEl.protocol is ':' in old ie when protocol is not specified\n  var sameProtocol = !urlEl.protocol || urlEl.protocol === ':' || urlEl.protocol === location.protocol\n  var sameDomain = urlEl.hostname === document.domain && urlEl.port === location.port\n\n  // urlEl.hostname is not provided by IE for relative urls, but relative urls are also same-origin\n  ret.sameOrigin = sameProtocol && (!urlEl.hostname || sameDomain)\n\n  // Only cache if url doesn't have a path\n  if (ret.pathname === '/') {\n    stringsToParsedUrls[url] = ret\n  }\n\n  return ret\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar dataSize = require(21)\n\nmodule.exports = responseSizeFromXhr\n\nfunction responseSizeFromXhr (xhr, lastSize) {\n  var type = xhr.responseType\n  if (type === 'json' && lastSize !== null) return lastSize\n  // Caution! Chrome throws an error if you try to access xhr.responseText for binary data\n  if (type === 'arraybuffer' || type === 'blob' || type === 'json') {\n    return dataSize(xhr.response)\n  } else if (type === 'text' || type === '' || type === undefined) {  // empty string type defaults to 'text'\n    return dataSize(xhr.responseText)\n  } else {  // e.g. ms-stream and document (we do not currently determine the size of Document objects)\n    return undefined\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handle = require(\"handle\")\nvar mapOwn = require(29)\nvar slice = require(30)\nvar tracerEE = require(\"ee\").get('tracer')\nvar loader = require(\"loader\")\n\nvar nr = NREUM\nif (typeof (window.newrelic) === 'undefined') newrelic = nr\n\nvar asyncApiFns = [\n  'setPageViewName',\n  'setCustomAttribute',\n  'setErrorHandler',\n  'finished',\n  'addToTrace',\n  'inlineHit',\n  'addRelease'\n]\n\nvar prefix = 'api-'\nvar spaPrefix = prefix + 'ixn-'\n\n// Setup stub functions that queue calls for later processing.\nmapOwn(asyncApiFns, function (num, fnName) {\n  nr[fnName] = apiCall(prefix + fnName, true, 'api')\n})\n\nnr.addPageAction = apiCall(prefix + 'addPageAction', true)\nnr.setCurrentRouteName = apiCall(prefix + 'routeName', true)\n\nmodule.exports = newrelic\n\nnr.interaction = function () {\n  return new InteractionHandle().get()\n}\n\nfunction InteractionHandle () {}\n\nvar InteractionApiProto = InteractionHandle.prototype = {\n  createTracer: function (name, cb) {\n    var contextStore = {}\n    var ixn = this\n    var hasCb = typeof cb === 'function'\n    handle(spaPrefix + 'tracer', [loader.now(), name, contextStore], ixn)\n    return function () {\n      tracerEE.emit((hasCb ? '' : 'no-') + 'fn-start', [loader.now(), ixn, hasCb], contextStore)\n      if (hasCb) {\n        try {\n          return cb.apply(this, arguments)\n        } catch (err) {\n          tracerEE.emit('fn-err', [arguments, this, err], contextStore)\n          // the error came from outside the agent, so don't swallow\n          throw err\n        } finally {\n          tracerEE.emit('fn-end', [loader.now()], contextStore)\n        }\n      }\n    }\n  }\n}\n\nmapOwn('actionText,setName,setAttribute,save,ignore,onEnd,getContext,end,get'.split(','), function addApi (n, name) {\n  InteractionApiProto[name] = apiCall(spaPrefix + name)\n})\n\nfunction apiCall (name, notSpa, bufferGroup) {\n  return function () {\n    handle(name, [loader.now()].concat(slice(arguments)), notSpa ? null : this, bufferGroup)\n    return notSpa ? void 0 : this\n  }\n}\n\nnewrelic.noticeError = function (err, customAttributes) {\n  if (typeof err === 'string') err = new Error(err)\n  handle('err', [err, loader.now(), false, customAttributes])\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getConfiguration: getConfiguration\n}\n\nfunction getConfiguration(path) {\n  if (!NREUM.init) return\n  var val = NREUM.init\n  var parts = path.split('.')\n  for (var i = 0; i < parts.length - 1; i++) {\n    val = val[parts[i]]\n    if (typeof val !== 'object') return\n  }\n  val = val[parts[parts.length - 1]]\n  return val\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = function dataSize (data) {\n  if (typeof data === 'string' && data.length) return data.length\n  if (typeof data !== 'object') return undefined\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer && data.byteLength) return data.byteLength\n  if (typeof Blob !== 'undefined' && data instanceof Blob && data.size) return data.size\n  if (typeof FormData !== 'undefined' && data instanceof FormData) return undefined\n\n  try {\n    return JSON.stringify(data).length\n  } catch (e) {\n    return undefined\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = 0\nvar match = navigator.userAgent.match(/Firefox[\\/\\s](\\d+\\.\\d+)/)\nif (match) ffVersion = +match[1]\n\nmodule.exports = ffVersion\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar lastTimestamp = new Date().getTime()\nvar offset = lastTimestamp\n\nvar performanceCheck = require(31)\n\nmodule.exports = now\nmodule.exports.offset = offset\nmodule.exports.getLastTimestamp = getLastTimestamp\n\nfunction now () {\n  if (performanceCheck.exists && performance.now) {\n    return Math.round(performance.now())\n  }\n  // ensure a new timestamp is never smaller than a previous timestamp\n  return (lastTimestamp = Math.max(new Date().getTime(), lastTimestamp)) - offset\n}\n\nfunction getLastTimestamp() {\n  return lastTimestamp\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = protocolAllowed\n\nfunction protocolAllowed (location) {\n  return !!(location && location.protocol && location.protocol !== 'file:')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// collect page view timings unless the feature is explicitly disabled\nif ('init' in NREUM && 'page_view_timing' in NREUM.init &&\n  'enabled' in NREUM.init.page_view_timing &&\n  NREUM.init.page_view_timing.enabled === false) {\n  return\n}\n\nvar handle = require(\"handle\")\nvar loader = require(\"loader\")\nvar subscribeToVisibilityChange = require(28)\n\nvar origEvent = NREUM.o.EV\n\n// paint metrics\nfunction perfObserver(list, observer) {\n  var entries = list.getEntries()\n  entries.forEach(function (entry) {\n    if (entry.name === 'first-paint') {\n      handle('timing', ['fp', Math.floor(entry.startTime)])\n    } else if (entry.name === 'first-contentful-paint') {\n      handle('timing', ['fcp', Math.floor(entry.startTime)])\n    }\n  })\n}\n\n// largest contentful paint\nfunction lcpObserver(list, observer) {\n  var entries = list.getEntries()\n  if (entries.length > 0) {\n    handle('lcp', [entries[entries.length - 1]])\n  }\n}\n\nfunction clsObserver(list) {\n  list.getEntries().forEach(function(entry) {\n    if (!entry.hadRecentInput) {\n      handle('cls', [entry])\n    }\n  })\n}\n\nvar performanceObserver\nvar lcpPerformanceObserver\nvar clsPerformanceObserver\nif ('PerformanceObserver' in window && typeof window.PerformanceObserver === 'function') {\n  // passing in an unknown entry type to observer could throw an exception\n  performanceObserver = new PerformanceObserver(perfObserver) // eslint-disable-line no-undef\n  try {\n    performanceObserver.observe({entryTypes: ['paint']})\n  } catch (e) {}\n\n  lcpPerformanceObserver = new PerformanceObserver(lcpObserver) // eslint-disable-line no-undef\n  try {\n    lcpPerformanceObserver.observe({entryTypes: ['largest-contentful-paint']})\n  } catch (e) {}\n\n  clsPerformanceObserver = new PerformanceObserver(clsObserver) // eslint-disable-line no-undef\n  try {\n    clsPerformanceObserver.observe({type: 'layout-shift', buffered: true})\n  } catch (e) {}\n}\n\n// first interaction and first input delay\nif ('addEventListener' in document) {\n  var fiRecorded = false\n  var allowedEventTypes = ['click', 'keydown', 'mousedown', 'pointerdown', 'touchstart']\n  allowedEventTypes.forEach(function (e) {\n    document.addEventListener(e, captureInteraction, false)\n  })\n}\n\nfunction captureInteraction(evt) {\n  if (evt instanceof origEvent && !fiRecorded) {\n    var fi = Math.round(evt.timeStamp)\n    var attributes = {\n      type: evt.type\n    }\n\n    // The value of Event.timeStamp is epoch time in some old browser, and relative\n    // timestamp in newer browsers. We assume that large numbers represent epoch time.\n    if (fi <= loader.now()) {\n      attributes['fid'] = loader.now() - fi\n    } else if (fi > loader.offset && fi <= Date.now()) {\n      fi = fi - loader.offset\n      attributes['fid'] = loader.now() - fi\n    } else {\n      fi = loader.now()\n    }\n\n    fiRecorded = true\n    handle('timing', ['fi', fi, attributes])\n  }\n}\n\n// page visibility events\nsubscribeToVisibilityChange(captureVisibilityChange)\n\nfunction captureVisibilityChange(state) {\n  handle('pageHide', [loader.now(), state])\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  generateUuid: generateUuid,\n  generateSpanId: generateSpanId,\n  generateTraceId: generateTraceId\n}\n\nfunction generateUuid () {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n\n  // v4 UUID\n  var template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  var id = ''\n  var c\n  for (var i = 0; i < template.length; i++) {\n    c = template[i]\n    if (c === 'x') {\n      id += getRandomValue().toString(16)\n    } else if (c === 'y') {\n      // this is the uuid variant per spec (8, 9, a, b)\n      // % 4, then shift to get values 8-11\n      c = getRandomValue() & 0x3 | 0x8\n      id += c.toString(16)\n    } else {\n      id += c\n    }\n  }\n\n  return id\n}\n\n// 16-character hex string (per DT spec)\nfunction generateSpanId () {\n  return generateRandomHexString(16)\n}\n\n// 32-character hex string (per DT spec)\nfunction generateTraceId() {\n  return generateRandomHexString(32)\n}\n\nfunction generateRandomHexString(length) {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues && Uint8Array) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  var chars = []\n  for (var i = 0; i < length; i++) {\n    chars.push(getRandomValue().toString(16))\n  }\n  return chars.join('')\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Feature-detection is much preferred over using User Agent to detect browser.\n// However, there are cases where feature detection is not possible, for example\n// when a specific version of a browser has a bug that requires a workaround in just\n// that version.\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Browser_Name\nvar agentName = null\nvar agentVersion = null\nvar safari = /Version\\/(\\S+)\\s+Safari/\n\nif (navigator.userAgent) {\n  var userAgent = navigator.userAgent\n  var parts = userAgent.match(safari)\n\n  if (parts && userAgent.indexOf('Chrome') === -1 &&\n      userAgent.indexOf('Chromium') === -1) {\n    agentName = 'Safari'\n    agentVersion = parts[1]\n  }\n}\n\nmodule.exports = {\n  agent: agentName,\n  version: agentVersion,\n  match: match\n}\n\nfunction match (name, version) {\n  if (!agentName) {\n    return false\n  }\n\n  if (name !== agentName) {\n    return false\n  }\n\n  // version not provided, only match by name\n  if (!version) {\n    return true\n  }\n\n  // version provided, but not detected - not reliable match\n  if (!agentVersion) {\n    return false\n  }\n\n  var detectedParts = agentVersion.split('.')\n  var requestedParts = version.split('.')\n  for (var i = 0; i < requestedParts.length; i++) {\n    if (requestedParts[i] !== detectedParts[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = subscribeToVisibilityChange\n\nvar hidden, eventName, state\n\nif (typeof document.hidden !== 'undefined') {\n  hidden = 'hidden'\n  eventName = 'visibilitychange'\n  state = 'visibilityState'\n} else if (typeof document.msHidden !== 'undefined') {\n  hidden = 'msHidden'\n  eventName = 'msvisibilitychange'\n} else if (typeof document.webkitHidden !== 'undefined') {\n  hidden = 'webkitHidden'\n  eventName = 'webkitvisibilitychange'\n  state = 'webkitVisibilityState'\n}\n\nfunction subscribeToVisibilityChange(cb) {\n  if ('addEventListener' in document && eventName) {\n    document.addEventListener(eventName, handleVisibilityChange, false)\n  }\n\n  function handleVisibilityChange() {\n    if (state && document[state]) {\n      cb(document[state])\n    } else if (document[hidden]) {\n      cb('hidden')\n    } else {\n      cb('visible')\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = mapOwn\n\nfunction mapOwn (obj, fn) {\n  var results = []\n  var key = ''\n  var i = 0\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      results[i] = fn(key, obj[key])\n      i += 1\n    }\n  }\n\n  return results\n}\n","/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  exists: typeof (window.performance) !== 'undefined' && window.performance.timing && typeof (window.performance.timing.navigationStart) !== 'undefined'\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ctxId = 'nr@context'\nvar getOrSet = require(\"gos\")\nvar mapOwn = require(29)\n\nvar eventBuffer = {}\nvar emitters = {}\n\nvar baseEE = module.exports = ee()\nmodule.exports.getOrSetContext = getOrSetContext\n\nbaseEE.backlog = eventBuffer\n\nfunction EventContext () {}\n\nfunction ee (old) {\n  var handlers = {}\n  var bufferGroupMap = {}\n\n  var emitter = {\n    on: addEventListener,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    emit: emit,\n    get: getOrCreate,\n    listeners: listeners,\n    context: context,\n    buffer: bufferEventsByGroup,\n    abort: abortIfNotLoaded,\n    aborted: false\n  }\n\n  return emitter\n\n  function context (contextOrStore) {\n    if (contextOrStore && contextOrStore instanceof EventContext) {\n      return contextOrStore\n    } else if (contextOrStore) {\n      return getOrSet(contextOrStore, ctxId, getNewContext)\n    } else {\n      return getNewContext()\n    }\n  }\n\n  function emit (type, args, contextOrStore, force, bubble) {\n    if (bubble !== false) bubble = true\n    if (baseEE.aborted && !force) { return }\n    if (old && bubble) old(type, args, contextOrStore)\n\n    var ctx = context(contextOrStore)\n    var handlersArray = listeners(type)\n    var len = handlersArray.length\n\n    // Extremely verbose debug logging\n    // if ([/^xhr/].map(function (match) {return type.match(match)}).filter(Boolean).length) {\n    //  console.log(type + ' args:')\n    //  console.log(args)\n    //  console.log(type + ' handlers array:')\n    //  console.log(handlersArray)\n    //  console.log(type + ' context:')\n    //  console.log(ctx)\n    //  console.log(type + ' ctxStore:')\n    //  console.log(ctxStore)\n    // }\n\n    // Apply each handler function in the order they were added\n    // to the context with the arguments\n\n    for (var i = 0; i < len; i++) handlersArray[i].apply(ctx, args)\n\n    // Buffer after emitting for consistent ordering\n    var bufferGroup = eventBuffer[bufferGroupMap[type]]\n    if (bufferGroup) {\n      bufferGroup.push([emitter, type, args, ctx])\n    }\n\n    // Return the context so that the module that emitted can see what was done.\n    return ctx\n  }\n\n  function addEventListener (type, fn) {\n    // Retrieve type from handlers, if it doesn't exist assign the default and retrieve it.\n    handlers[type] = listeners(type).concat(fn)\n  }\n\n  function removeEventListener (type, fn) {\n    var listeners = handlers[type]\n    if (!listeners) return\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1)\n      }\n    }\n  }\n\n  function listeners (type) {\n    return handlers[type] || []\n  }\n\n  function getOrCreate (name) {\n    return (emitters[name] = emitters[name] || ee(emit))\n  }\n\n  function bufferEventsByGroup (types, group) {\n    mapOwn(types, function (i, type) {\n      group = group || 'feature'\n      bufferGroupMap[type] = group\n      if (!(group in eventBuffer)) {\n        eventBuffer[group] = []\n      }\n    })\n  }\n}\n\n// get context object from store object, or create if does not exist\nfunction getOrSetContext(obj) {\n  return getOrSet(obj, ctxId, getNewContext)\n}\n\nfunction getNewContext () {\n  return new EventContext()\n}\n\n// abort should be called 30 seconds after the page has started running\n// We should drop our data and stop collecting if we still have a backlog, which\n// signifies the rest of the agent wasn't loaded\nfunction abortIfNotLoaded () {\n  if (eventBuffer.api || eventBuffer.feature) {\n    baseEE.aborted = true\n    eventBuffer = baseEE.backlog = {}\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = getOrSet\n\n// Always returns the current value of obj[prop], even if it has to set it first\nfunction getOrSet (obj, prop, getVal) {\n  // If the value exists return it.\n  if (has.call(obj, prop)) return obj[prop]\n\n  var val = getVal()\n\n  // Attempt to set the property so it's not enumerable\n  if (Object.defineProperty && Object.keys) {\n    try {\n      Object.defineProperty(obj, prop, {\n        value: val, // old IE inherits non-write-ability\n        writable: true,\n        enumerable: false\n      })\n\n      return val\n    } catch (e) {\n      // Can't report internal errors,\n      // because GOS is a dependency of the reporting mechanisms\n    }\n  }\n\n  // fall back to setting normally\n  obj[prop] = val\n  return val\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('handle')\n\n// Exported for register-handler to attach to.\nmodule.exports = handle\nhandle.ee = ee\n\nfunction handle (type, args, ctx, group) {\n  ee.buffer([type], group)\n  ee.emit(type, args, ctx)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Start assigning ids at 1 so 0 can always be used for window, without\n// actually setting it (which would create a global variable).\nvar index = 1\nvar prop = 'nr@id'\nvar getOrSet = require(\"gos\")\n\nmodule.exports = id\n\n// Always returns id of obj, may tag obj with an id in the process.\nfunction id (obj) {\n  var type = typeof obj\n  // We can only tag objects, functions, and arrays with ids.\n  // For all primitive values we instead return -1.\n  if (!obj || !(type === 'object' || type === 'function')) return -1\n  if (obj === window) return 0\n\n  return getOrSet(obj, prop, function () { return index++ })\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar now = require(23)\nvar handle = require(\"handle\")\nvar mapOwn = require(29)\nvar ee = require(\"ee\")\nvar userAgent = require(27)\nvar protocolAllowed = require(24)\nvar config = require(20)\n\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\nvar win = window\nvar doc = win.document\n\nvar ADD_EVENT_LISTENER = 'addEventListener'\nvar ATTACH_EVENT = 'attachEvent'\nvar XHR = win.XMLHttpRequest\nvar XHR_PROTO = XHR && XHR.prototype\n\nvar disabled = !protocolAllowed(win.location)\n\nNREUM.o = {\n  ST: setTimeout,\n  SI: win.setImmediate,\n  CT: clearTimeout,\n  XHR: XHR,\n  REQ: win.Request,\n  EV: win.Event,\n  PR: win.Promise,\n  MO: win.MutationObserver\n}\n\nvar origin = '' + location\nvar defInfo = {\n  beacon: 'bam.nr-data.net',\n  errorBeacon: 'bam.nr-data.net',\n  agent: 'js-agent.newrelic.com/nr-dev.min.js'\n}\n\nvar xhrWrappable = XHR &&\n  XHR_PROTO &&\n  XHR_PROTO[ADD_EVENT_LISTENER] &&\n  !/CriOS/.test(navigator.userAgent)\n\nvar exp = module.exports = {\n  offset: now.getLastTimestamp(),\n  now: now,\n  origin: origin,\n  features: {},\n  xhrWrappable: xhrWrappable,\n  userAgent: userAgent,\n  disabled: disabled\n}\n\nif (!protocolAllowed(win.location)) return\n\n// api loads registers several event listeners, but does not have any exports\nrequire(19)\n\n// paint timings\nrequire(25)\n\nif (doc[ADD_EVENT_LISTENER]) {\n  doc[ADD_EVENT_LISTENER]('DOMContentLoaded', loaded, false)\n  win[ADD_EVENT_LISTENER]('load', windowLoaded, false)\n} else {\n  doc[ATTACH_EVENT]('onreadystatechange', stateChange)\n  win[ATTACH_EVENT]('onload', windowLoaded)\n}\n\nhandle('mark', ['firstbyte', now.getLastTimestamp()], null, 'api')\n\nvar loadFired = 0\nfunction windowLoaded () {\n  if (loadFired++) return\n  var info = exp.info = NREUM.info\n\n  var firstScript = doc.getElementsByTagName('script')[0]\n  setTimeout(ee.abort, 30000)\n\n  if (!(info && info.licenseKey && info.applicationID && firstScript)) {\n    return ee.abort()\n  }\n\n  mapOwn(defInfo, function (key, val) {\n    // this will overwrite any falsy value in config\n    // This is intentional because agents may write an empty string to\n    // the agent key in the config, in which case we want to use the default\n    if (!info[key]) info[key] = val\n  })\n\n  var ts = now()\n  handle('mark', ['onload', ts + exp.offset], null, 'api')\n  handle('timing', ['load', ts])\n\n  var agent = doc.createElement('script')\n  agent.src = scheme + '://' + info.agent\n  firstScript.parentNode.insertBefore(agent, firstScript)\n}\n\nfunction stateChange () {\n  if (doc.readyState === 'complete') loaded()\n}\n\nfunction loaded () {\n  handle('mark', ['domContent', now() + exp.offset], null, 'api')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar slice = require(30)\nvar flag = 'nr@original'\nvar has = Object.prototype.hasOwnProperty\nvar inWrapper = false\n\nmodule.exports = createWrapperWithEmitter\nmodule.exports.wrapFunction = wrapFunction\nmodule.exports.wrapInPlace = wrapInPlace\nmodule.exports.argsToArray = argsToArray\n\nfunction createWrapperWithEmitter(emitter, always) {\n  emitter || (emitter = ee)\n\n  wrapFn.inPlace = inPlace\n  wrapFn.flag = flag\n\n  return wrapFn\n\n  function wrapFn (fn, prefix, getContext, methodName, bubble) {\n    // Unless fn is both wrappable and unwrapped, return it unchanged.\n    if (notWrappable(fn)) return fn\n\n    if (!prefix) prefix = ''\n\n    nrWrapper[flag] = fn\n    copy(fn, nrWrapper, emitter)\n    return nrWrapper\n\n    function nrWrapper () {\n      var args\n      var originalThis\n      var ctx\n      var result\n\n      try {\n        originalThis = this\n        args = slice(arguments)\n\n        if (typeof getContext === 'function') {\n          ctx = getContext(args, originalThis)\n        } else {\n          ctx = getContext || {}\n        }\n      } catch (e) {\n        report([e, '', [args, originalThis, methodName], ctx], emitter)\n      }\n\n      // Warning: start events may mutate args!\n      safeEmit(prefix + 'start', [args, originalThis, methodName], ctx, bubble)\n\n      try {\n        result = fn.apply(originalThis, args)\n        return result\n      } catch (err) {\n        safeEmit(prefix + 'err', [args, originalThis, err], ctx, bubble)\n\n        // rethrow error so we don't effect execution by observing.\n        throw err\n      } finally {\n        // happens no matter what.\n        safeEmit(prefix + 'end', [args, originalThis, result], ctx, bubble)\n      }\n    }\n  }\n\n  function inPlace (obj, methods, prefix, getContext, bubble) {\n    if (!prefix) prefix = ''\n    // If prefix starts with '-' set this boolean to add the method name to\n    // the prefix before passing each one to wrap.\n    var prependMethodPrefix = (prefix.charAt(0) === '-')\n    var fn\n    var method\n    var i\n\n    for (i = 0; i < methods.length; i++) {\n      method = methods[i]\n      fn = obj[method]\n\n      // Unless fn is both wrappable and unwrapped bail,\n      // so we don't add extra properties with undefined values.\n      if (notWrappable(fn)) continue\n\n      obj[method] = wrapFn(fn, (prependMethodPrefix ? method + prefix : prefix), getContext, method, bubble)\n    }\n  }\n\n  function safeEmit (evt, arr, store, bubble) {\n    if (inWrapper && !always) return\n    var prev = inWrapper\n    inWrapper = true\n    try {\n      emitter.emit(evt, arr, store, always, bubble)\n    } catch (e) {\n      report([e, evt, arr, store], emitter)\n    }\n    inWrapper = prev\n  }\n}\n\nfunction report (args, emitter) {\n  emitter || (emitter = ee)\n  try {\n    emitter.emit('internal-error', args)\n  } catch (err) {}\n}\n\nfunction copy (from, to, emitter) {\n  if (Object.defineProperty && Object.keys) {\n    // Create accessors that proxy to actual function\n    try {\n      var keys = Object.keys(from)\n      keys.forEach(function (key) {\n        Object.defineProperty(to, key, {\n          get: function () { return from[key] },\n          set: function (val) { from[key] = val; return val }\n        })\n      })\n      return to\n    } catch (e) {\n      report([e], emitter)\n    }\n  }\n  // fall back to copying properties\n  for (var i in from) {\n    if (has.call(from, i)) {\n      to[i] = from[i]\n    }\n  }\n  return to\n}\n\nfunction notWrappable (fn) {\n  return !(fn && fn instanceof Function && fn.apply && !fn[flag])\n}\n\nfunction wrapFunction(fn, wrapper) {\n  var wrapped = wrapper(fn)\n  wrapped[flag] = fn\n  copy(fn, wrapped, ee)\n  return wrapped\n}\n\nfunction wrapInPlace(obj, fnName, wrapper) {\n  var fn = obj[fnName]\n  obj[fnName] = wrapFunction(fn, wrapper)\n}\n\nfunction argsToArray() {\n  var len = arguments.length\n  var arr = new Array(len)\n  for (var i = 0; i < len; ++i) {\n    arr[i] = arguments[i]\n  }\n  return arr\n}\n"],"sourceRoot":"/source/"}