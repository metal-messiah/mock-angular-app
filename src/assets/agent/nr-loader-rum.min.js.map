{"version":3,"sources":["node_modules/browser-pack/_prelude.js","loader/api.js","nr-loader-rum.min.js","loader/config.js","loader/now.js","loader/protocol-allowed.js","loader/timings.js","loader/user-agent.js","loader/visibility.js","map-own/index.js","node_modules/lodash._slice/index.js","performance-check/index.js","ee","gos","handle","id","loader","wrap-function"],"names":["window","NREUM","__nr_require","modules","cache","entry","newRequire","name","m","exports","call","x","id","i","length","1","require","module","InteractionHandle","apiCall","notSpa","bufferGroup","handle","loader","now","concat","slice","arguments","this","mapOwn","tracerEE","get","nr","newrelic","asyncApiFns","prefix","spaPrefix","num","fnName","addPageAction","setCurrentRouteName","interaction","InteractionApiProto","prototype","createTracer","cb","contextStore","ixn","hasCb","emit","apply","err","split","n","noticeError","customAttributes","Error","2","getConfiguration","path","init","val","parts","3","performanceCheck","exists","performance","Math","round","lastTimestamp","max","Date","getTime","offset","getLastTimestamp","4","protocolAllowed","location","protocol","5","perfObserver","list","observer","entries","getEntries","forEach","floor","startTime","lcpObserver","clsObserver","hadRecentInput","captureInteraction","evt","origEvent","fiRecorded","fi","timeStamp","attributes","type","captureVisibilityChange","state","page_view_timing","enabled","performanceObserver","lcpPerformanceObserver","clsPerformanceObserver","subscribeToVisibilityChange","o","EV","PerformanceObserver","observe","entryTypes","e","buffered","document","allowedEventTypes","addEventListener","6","match","version","agentName","agentVersion","detectedParts","requestedParts","safari","navigator","userAgent","indexOf","agent","7","handleVisibilityChange","hidden","eventName","msHidden","webkitHidden","8","obj","fn","results","key","has","Object","hasOwnProperty","9","array","start","end","index","result","Array","10","timing","ee","EventContext","old","context","contextOrStore","getOrSet","ctxId","getNewContext","args","force","bubble","baseEE","aborted","ctx","handlersArray","listeners","len","eventBuffer","bufferGroupMap","push","emitter","handlers","removeEventListener","splice","getOrCreate","emitters","bufferEventsByGroup","types","group","on","buffer","abort","abortIfNotLoaded","getOrSetContext","api","feature","backlog","gos","prop","getVal","defineProperty","keys","value","writable","enumerable","windowLoaded","loadFired","info","exp","firstScript","doc","getElementsByTagName","setTimeout","licenseKey","applicationID","defInfo","ts","createElement","src","scheme","parentNode","insertBefore","stateChange","readyState","loaded","config","win","ADD_EVENT_LISTENER","ATTACH_EVENT","XHR","XMLHttpRequest","XHR_PROTO","disabled","ST","SI","setImmediate","CT","clearTimeout","REQ","Request","Event","PR","Promise","MO","MutationObserver","origin","beacon","errorBeacon","xhrWrappable","test","features","wrap-function","createWrapperWithEmitter","always","wrapFn","getContext","methodName","nrWrapper","originalThis","report","safeEmit","notWrappable","flag","copy","inPlace","methods","method","prependMethodPrefix","charAt","arr","store","inWrapper","prev","from","to","set","Function","wrapFunction","wrapper","wrapped","wrapInPlace","argsToArray"],"mappings":"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","file":"nr-loader-rum.min.js","sourcesContent":["// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requireuires ]\n//\n// map of requireuires is short require name -> numeric require\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  function newRequire (name) {\n    if (!cache[name]) {\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n\n  // If there is already an agent on the page, use it instead.\n  if (typeof __nr_require === 'function') return __nr_require\n\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  return newRequire\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handle = require(\"handle\")\nvar mapOwn = require(8)\nvar slice = require(9)\nvar tracerEE = require(\"ee\").get('tracer')\nvar loader = require(\"loader\")\n\nvar nr = NREUM\nif (typeof (window.newrelic) === 'undefined') newrelic = nr\n\nvar asyncApiFns = [\n  'setPageViewName',\n  'setCustomAttribute',\n  'setErrorHandler',\n  'finished',\n  'addToTrace',\n  'inlineHit',\n  'addRelease'\n]\n\nvar prefix = 'api-'\nvar spaPrefix = prefix + 'ixn-'\n\n// Setup stub functions that queue calls for later processing.\nmapOwn(asyncApiFns, function (num, fnName) {\n  nr[fnName] = apiCall(prefix + fnName, true, 'api')\n})\n\nnr.addPageAction = apiCall(prefix + 'addPageAction', true)\nnr.setCurrentRouteName = apiCall(prefix + 'routeName', true)\n\nmodule.exports = newrelic\n\nnr.interaction = function () {\n  return new InteractionHandle().get()\n}\n\nfunction InteractionHandle () {}\n\nvar InteractionApiProto = InteractionHandle.prototype = {\n  createTracer: function (name, cb) {\n    var contextStore = {}\n    var ixn = this\n    var hasCb = typeof cb === 'function'\n    handle(spaPrefix + 'tracer', [loader.now(), name, contextStore], ixn)\n    return function () {\n      tracerEE.emit((hasCb ? '' : 'no-') + 'fn-start', [loader.now(), ixn, hasCb], contextStore)\n      if (hasCb) {\n        try {\n          return cb.apply(this, arguments)\n        } catch (err) {\n          tracerEE.emit('fn-err', [arguments, this, err], contextStore)\n          // the error came from outside the agent, so don't swallow\n          throw err\n        } finally {\n          tracerEE.emit('fn-end', [loader.now()], contextStore)\n        }\n      }\n    }\n  }\n}\n\nmapOwn('actionText,setName,setAttribute,save,ignore,onEnd,getContext,end,get'.split(','), function addApi (n, name) {\n  InteractionApiProto[name] = apiCall(spaPrefix + name)\n})\n\nfunction apiCall (name, notSpa, bufferGroup) {\n  return function () {\n    handle(name, [loader.now()].concat(slice(arguments)), notSpa ? null : this, bufferGroup)\n    return notSpa ? void 0 : this\n  }\n}\n\nnewrelic.noticeError = function (err, customAttributes) {\n  if (typeof err === 'string') err = new Error(err)\n  handle('err', [err, loader.now(), false, customAttributes])\n}\n","window.NREUM || (NREUM={});__nr_require=// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requireuires ]\n//\n// map of requireuires is short require name -> numeric require\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  function newRequire (name) {\n    if (!cache[name]) {\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n\n  // If there is already an agent on the page, use it instead.\n  if (typeof __nr_require === 'function') return __nr_require\n\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  return newRequire\n})\n({1:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handle = require(\"handle\")\nvar mapOwn = require(8)\nvar slice = require(9)\nvar tracerEE = require(\"ee\").get('tracer')\nvar loader = require(\"loader\")\n\nvar nr = NREUM\nif (typeof (window.newrelic) === 'undefined') newrelic = nr\n\nvar asyncApiFns = [\n  'setPageViewName',\n  'setCustomAttribute',\n  'setErrorHandler',\n  'finished',\n  'addToTrace',\n  'inlineHit',\n  'addRelease'\n]\n\nvar prefix = 'api-'\nvar spaPrefix = prefix + 'ixn-'\n\n// Setup stub functions that queue calls for later processing.\nmapOwn(asyncApiFns, function (num, fnName) {\n  nr[fnName] = apiCall(prefix + fnName, true, 'api')\n})\n\nnr.addPageAction = apiCall(prefix + 'addPageAction', true)\nnr.setCurrentRouteName = apiCall(prefix + 'routeName', true)\n\nmodule.exports = newrelic\n\nnr.interaction = function () {\n  return new InteractionHandle().get()\n}\n\nfunction InteractionHandle () {}\n\nvar InteractionApiProto = InteractionHandle.prototype = {\n  createTracer: function (name, cb) {\n    var contextStore = {}\n    var ixn = this\n    var hasCb = typeof cb === 'function'\n    handle(spaPrefix + 'tracer', [loader.now(), name, contextStore], ixn)\n    return function () {\n      tracerEE.emit((hasCb ? '' : 'no-') + 'fn-start', [loader.now(), ixn, hasCb], contextStore)\n      if (hasCb) {\n        try {\n          return cb.apply(this, arguments)\n        } catch (err) {\n          tracerEE.emit('fn-err', [arguments, this, err], contextStore)\n          // the error came from outside the agent, so don't swallow\n          throw err\n        } finally {\n          tracerEE.emit('fn-end', [loader.now()], contextStore)\n        }\n      }\n    }\n  }\n}\n\nmapOwn('actionText,setName,setAttribute,save,ignore,onEnd,getContext,end,get'.split(','), function addApi (n, name) {\n  InteractionApiProto[name] = apiCall(spaPrefix + name)\n})\n\nfunction apiCall (name, notSpa, bufferGroup) {\n  return function () {\n    handle(name, [loader.now()].concat(slice(arguments)), notSpa ? null : this, bufferGroup)\n    return notSpa ? void 0 : this\n  }\n}\n\nnewrelic.noticeError = function (err, customAttributes) {\n  if (typeof err === 'string') err = new Error(err)\n  handle('err', [err, loader.now(), false, customAttributes])\n}\n\n},{}],2:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getConfiguration: getConfiguration\n}\n\nfunction getConfiguration(path) {\n  if (!NREUM.init) return\n  var val = NREUM.init\n  var parts = path.split('.')\n  for (var i = 0; i < parts.length - 1; i++) {\n    val = val[parts[i]]\n    if (typeof val !== 'object') return\n  }\n  val = val[parts[parts.length - 1]]\n  return val\n}\n\n},{}],3:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar lastTimestamp = new Date().getTime()\nvar offset = lastTimestamp\n\nvar performanceCheck = require(10)\n\nmodule.exports = now\nmodule.exports.offset = offset\nmodule.exports.getLastTimestamp = getLastTimestamp\n\nfunction now () {\n  if (performanceCheck.exists && performance.now) {\n    return Math.round(performance.now())\n  }\n  // ensure a new timestamp is never smaller than a previous timestamp\n  return (lastTimestamp = Math.max(new Date().getTime(), lastTimestamp)) - offset\n}\n\nfunction getLastTimestamp() {\n  return lastTimestamp\n}\n\n},{}],4:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = protocolAllowed\n\nfunction protocolAllowed (location) {\n  return !!(location && location.protocol && location.protocol !== 'file:')\n}\n\n},{}],5:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// collect page view timings unless the feature is explicitly disabled\nif ('init' in NREUM && 'page_view_timing' in NREUM.init &&\n  'enabled' in NREUM.init.page_view_timing &&\n  NREUM.init.page_view_timing.enabled === false) {\n  return\n}\n\nvar handle = require(\"handle\")\nvar loader = require(\"loader\")\nvar subscribeToVisibilityChange = require(7)\n\nvar origEvent = NREUM.o.EV\n\n// paint metrics\nfunction perfObserver(list, observer) {\n  var entries = list.getEntries()\n  entries.forEach(function (entry) {\n    if (entry.name === 'first-paint') {\n      handle('timing', ['fp', Math.floor(entry.startTime)])\n    } else if (entry.name === 'first-contentful-paint') {\n      handle('timing', ['fcp', Math.floor(entry.startTime)])\n    }\n  })\n}\n\n// largest contentful paint\nfunction lcpObserver(list, observer) {\n  var entries = list.getEntries()\n  if (entries.length > 0) {\n    handle('lcp', [entries[entries.length - 1]])\n  }\n}\n\nfunction clsObserver(list) {\n  list.getEntries().forEach(function(entry) {\n    if (!entry.hadRecentInput) {\n      handle('cls', [entry])\n    }\n  })\n}\n\nvar performanceObserver\nvar lcpPerformanceObserver\nvar clsPerformanceObserver\nif ('PerformanceObserver' in window && typeof window.PerformanceObserver === 'function') {\n  // passing in an unknown entry type to observer could throw an exception\n  performanceObserver = new PerformanceObserver(perfObserver) // eslint-disable-line no-undef\n  try {\n    performanceObserver.observe({entryTypes: ['paint']})\n  } catch (e) {}\n\n  lcpPerformanceObserver = new PerformanceObserver(lcpObserver) // eslint-disable-line no-undef\n  try {\n    lcpPerformanceObserver.observe({entryTypes: ['largest-contentful-paint']})\n  } catch (e) {}\n\n  clsPerformanceObserver = new PerformanceObserver(clsObserver) // eslint-disable-line no-undef\n  try {\n    clsPerformanceObserver.observe({type: 'layout-shift', buffered: true})\n  } catch (e) {}\n}\n\n// first interaction and first input delay\nif ('addEventListener' in document) {\n  var fiRecorded = false\n  var allowedEventTypes = ['click', 'keydown', 'mousedown', 'pointerdown', 'touchstart']\n  allowedEventTypes.forEach(function (e) {\n    document.addEventListener(e, captureInteraction, false)\n  })\n}\n\nfunction captureInteraction(evt) {\n  if (evt instanceof origEvent && !fiRecorded) {\n    var fi = Math.round(evt.timeStamp)\n    var attributes = {\n      type: evt.type\n    }\n\n    // The value of Event.timeStamp is epoch time in some old browser, and relative\n    // timestamp in newer browsers. We assume that large numbers represent epoch time.\n    if (fi <= loader.now()) {\n      attributes['fid'] = loader.now() - fi\n    } else if (fi > loader.offset && fi <= Date.now()) {\n      fi = fi - loader.offset\n      attributes['fid'] = loader.now() - fi\n    } else {\n      fi = loader.now()\n    }\n\n    fiRecorded = true\n    handle('timing', ['fi', fi, attributes])\n  }\n}\n\n// page visibility events\nsubscribeToVisibilityChange(captureVisibilityChange)\n\nfunction captureVisibilityChange(state) {\n  handle('pageHide', [loader.now(), state])\n}\n\n},{}],6:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Feature-detection is much preferred over using User Agent to detect browser.\n// However, there are cases where feature detection is not possible, for example\n// when a specific version of a browser has a bug that requires a workaround in just\n// that version.\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Browser_Name\nvar agentName = null\nvar agentVersion = null\nvar safari = /Version\\/(\\S+)\\s+Safari/\n\nif (navigator.userAgent) {\n  var userAgent = navigator.userAgent\n  var parts = userAgent.match(safari)\n\n  if (parts && userAgent.indexOf('Chrome') === -1 &&\n      userAgent.indexOf('Chromium') === -1) {\n    agentName = 'Safari'\n    agentVersion = parts[1]\n  }\n}\n\nmodule.exports = {\n  agent: agentName,\n  version: agentVersion,\n  match: match\n}\n\nfunction match (name, version) {\n  if (!agentName) {\n    return false\n  }\n\n  if (name !== agentName) {\n    return false\n  }\n\n  // version not provided, only match by name\n  if (!version) {\n    return true\n  }\n\n  // version provided, but not detected - not reliable match\n  if (!agentVersion) {\n    return false\n  }\n\n  var detectedParts = agentVersion.split('.')\n  var requestedParts = version.split('.')\n  for (var i = 0; i < requestedParts.length; i++) {\n    if (requestedParts[i] !== detectedParts[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n},{}],7:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = subscribeToVisibilityChange\n\nvar hidden, eventName, state\n\nif (typeof document.hidden !== 'undefined') {\n  hidden = 'hidden'\n  eventName = 'visibilitychange'\n  state = 'visibilityState'\n} else if (typeof document.msHidden !== 'undefined') {\n  hidden = 'msHidden'\n  eventName = 'msvisibilitychange'\n} else if (typeof document.webkitHidden !== 'undefined') {\n  hidden = 'webkitHidden'\n  eventName = 'webkitvisibilitychange'\n  state = 'webkitVisibilityState'\n}\n\nfunction subscribeToVisibilityChange(cb) {\n  if ('addEventListener' in document && eventName) {\n    document.addEventListener(eventName, handleVisibilityChange, false)\n  }\n\n  function handleVisibilityChange() {\n    if (state && document[state]) {\n      cb(document[state])\n    } else if (document[hidden]) {\n      cb('hidden')\n    } else {\n      cb('visible')\n    }\n  }\n}\n\n},{}],8:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = mapOwn\n\nfunction mapOwn (obj, fn) {\n  var results = []\n  var key = ''\n  var i = 0\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      results[i] = fn(key, obj[key])\n      i += 1\n    }\n  }\n\n  return results\n}\n\n},{}],9:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n\n},{}],10:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  exists: typeof (window.performance) !== 'undefined' && window.performance.timing && typeof (window.performance.timing.navigationStart) !== 'undefined'\n}\n\n},{}],\"ee\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ctxId = 'nr@context'\nvar getOrSet = require(\"gos\")\nvar mapOwn = require(8)\n\nvar eventBuffer = {}\nvar emitters = {}\n\nvar baseEE = module.exports = ee()\nmodule.exports.getOrSetContext = getOrSetContext\n\nbaseEE.backlog = eventBuffer\n\nfunction EventContext () {}\n\nfunction ee (old) {\n  var handlers = {}\n  var bufferGroupMap = {}\n\n  var emitter = {\n    on: addEventListener,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    emit: emit,\n    get: getOrCreate,\n    listeners: listeners,\n    context: context,\n    buffer: bufferEventsByGroup,\n    abort: abortIfNotLoaded,\n    aborted: false\n  }\n\n  return emitter\n\n  function context (contextOrStore) {\n    if (contextOrStore && contextOrStore instanceof EventContext) {\n      return contextOrStore\n    } else if (contextOrStore) {\n      return getOrSet(contextOrStore, ctxId, getNewContext)\n    } else {\n      return getNewContext()\n    }\n  }\n\n  function emit (type, args, contextOrStore, force, bubble) {\n    if (bubble !== false) bubble = true\n    if (baseEE.aborted && !force) { return }\n    if (old && bubble) old(type, args, contextOrStore)\n\n    var ctx = context(contextOrStore)\n    var handlersArray = listeners(type)\n    var len = handlersArray.length\n\n    // Extremely verbose debug logging\n    // if ([/^xhr/].map(function (match) {return type.match(match)}).filter(Boolean).length) {\n    //  console.log(type + ' args:')\n    //  console.log(args)\n    //  console.log(type + ' handlers array:')\n    //  console.log(handlersArray)\n    //  console.log(type + ' context:')\n    //  console.log(ctx)\n    //  console.log(type + ' ctxStore:')\n    //  console.log(ctxStore)\n    // }\n\n    // Apply each handler function in the order they were added\n    // to the context with the arguments\n\n    for (var i = 0; i < len; i++) handlersArray[i].apply(ctx, args)\n\n    // Buffer after emitting for consistent ordering\n    var bufferGroup = eventBuffer[bufferGroupMap[type]]\n    if (bufferGroup) {\n      bufferGroup.push([emitter, type, args, ctx])\n    }\n\n    // Return the context so that the module that emitted can see what was done.\n    return ctx\n  }\n\n  function addEventListener (type, fn) {\n    // Retrieve type from handlers, if it doesn't exist assign the default and retrieve it.\n    handlers[type] = listeners(type).concat(fn)\n  }\n\n  function removeEventListener (type, fn) {\n    var listeners = handlers[type]\n    if (!listeners) return\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1)\n      }\n    }\n  }\n\n  function listeners (type) {\n    return handlers[type] || []\n  }\n\n  function getOrCreate (name) {\n    return (emitters[name] = emitters[name] || ee(emit))\n  }\n\n  function bufferEventsByGroup (types, group) {\n    mapOwn(types, function (i, type) {\n      group = group || 'feature'\n      bufferGroupMap[type] = group\n      if (!(group in eventBuffer)) {\n        eventBuffer[group] = []\n      }\n    })\n  }\n}\n\n// get context object from store object, or create if does not exist\nfunction getOrSetContext(obj) {\n  return getOrSet(obj, ctxId, getNewContext)\n}\n\nfunction getNewContext () {\n  return new EventContext()\n}\n\n// abort should be called 30 seconds after the page has started running\n// We should drop our data and stop collecting if we still have a backlog, which\n// signifies the rest of the agent wasn't loaded\nfunction abortIfNotLoaded () {\n  if (eventBuffer.api || eventBuffer.feature) {\n    baseEE.aborted = true\n    eventBuffer = baseEE.backlog = {}\n  }\n}\n\n},{}],\"gos\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = getOrSet\n\n// Always returns the current value of obj[prop], even if it has to set it first\nfunction getOrSet (obj, prop, getVal) {\n  // If the value exists return it.\n  if (has.call(obj, prop)) return obj[prop]\n\n  var val = getVal()\n\n  // Attempt to set the property so it's not enumerable\n  if (Object.defineProperty && Object.keys) {\n    try {\n      Object.defineProperty(obj, prop, {\n        value: val, // old IE inherits non-write-ability\n        writable: true,\n        enumerable: false\n      })\n\n      return val\n    } catch (e) {\n      // Can't report internal errors,\n      // because GOS is a dependency of the reporting mechanisms\n    }\n  }\n\n  // fall back to setting normally\n  obj[prop] = val\n  return val\n}\n\n},{}],\"handle\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('handle')\n\n// Exported for register-handler to attach to.\nmodule.exports = handle\nhandle.ee = ee\n\nfunction handle (type, args, ctx, group) {\n  ee.buffer([type], group)\n  ee.emit(type, args, ctx)\n}\n\n},{}],\"id\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Start assigning ids at 1 so 0 can always be used for window, without\n// actually setting it (which would create a global variable).\nvar index = 1\nvar prop = 'nr@id'\nvar getOrSet = require(\"gos\")\n\nmodule.exports = id\n\n// Always returns id of obj, may tag obj with an id in the process.\nfunction id (obj) {\n  var type = typeof obj\n  // We can only tag objects, functions, and arrays with ids.\n  // For all primitive values we instead return -1.\n  if (!obj || !(type === 'object' || type === 'function')) return -1\n  if (obj === window) return 0\n\n  return getOrSet(obj, prop, function () { return index++ })\n}\n\n},{}],\"loader\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar now = require(3)\nvar handle = require(\"handle\")\nvar mapOwn = require(8)\nvar ee = require(\"ee\")\nvar userAgent = require(6)\nvar protocolAllowed = require(4)\nvar config = require(2)\n\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\nvar win = window\nvar doc = win.document\n\nvar ADD_EVENT_LISTENER = 'addEventListener'\nvar ATTACH_EVENT = 'attachEvent'\nvar XHR = win.XMLHttpRequest\nvar XHR_PROTO = XHR && XHR.prototype\n\nvar disabled = !protocolAllowed(win.location)\n\nNREUM.o = {\n  ST: setTimeout,\n  SI: win.setImmediate,\n  CT: clearTimeout,\n  XHR: XHR,\n  REQ: win.Request,\n  EV: win.Event,\n  PR: win.Promise,\n  MO: win.MutationObserver\n}\n\nvar origin = '' + location\nvar defInfo = {\n  beacon: 'bam.nr-data.net',\n  errorBeacon: 'bam.nr-data.net',\n  agent: 'js-agent.newrelic.com/nr.min.js'\n}\n\nvar xhrWrappable = XHR &&\n  XHR_PROTO &&\n  XHR_PROTO[ADD_EVENT_LISTENER] &&\n  !/CriOS/.test(navigator.userAgent)\n\nvar exp = module.exports = {\n  offset: now.getLastTimestamp(),\n  now: now,\n  origin: origin,\n  features: {},\n  xhrWrappable: xhrWrappable,\n  userAgent: userAgent,\n  disabled: disabled\n}\n\nif (!protocolAllowed(win.location)) return\n\n// api loads registers several event listeners, but does not have any exports\nrequire(1)\n\n// paint timings\nrequire(5)\n\nif (doc[ADD_EVENT_LISTENER]) {\n  doc[ADD_EVENT_LISTENER]('DOMContentLoaded', loaded, false)\n  win[ADD_EVENT_LISTENER]('load', windowLoaded, false)\n} else {\n  doc[ATTACH_EVENT]('onreadystatechange', stateChange)\n  win[ATTACH_EVENT]('onload', windowLoaded)\n}\n\nhandle('mark', ['firstbyte', now.getLastTimestamp()], null, 'api')\n\nvar loadFired = 0\nfunction windowLoaded () {\n  if (loadFired++) return\n  var info = exp.info = NREUM.info\n\n  var firstScript = doc.getElementsByTagName('script')[0]\n  setTimeout(ee.abort, 30000)\n\n  if (!(info && info.licenseKey && info.applicationID && firstScript)) {\n    return ee.abort()\n  }\n\n  mapOwn(defInfo, function (key, val) {\n    // this will overwrite any falsy value in config\n    // This is intentional because agents may write an empty string to\n    // the agent key in the config, in which case we want to use the default\n    if (!info[key]) info[key] = val\n  })\n\n  var ts = now()\n  handle('mark', ['onload', ts + exp.offset], null, 'api')\n  handle('timing', ['load', ts])\n\n  var agent = doc.createElement('script')\n  agent.src = scheme + '://' + info.agent\n  firstScript.parentNode.insertBefore(agent, firstScript)\n}\n\nfunction stateChange () {\n  if (doc.readyState === 'complete') loaded()\n}\n\nfunction loaded () {\n  handle('mark', ['domContent', now() + exp.offset], null, 'api')\n}\n\n},{}],\"wrap-function\":[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar slice = require(9)\nvar flag = 'nr@original'\nvar has = Object.prototype.hasOwnProperty\nvar inWrapper = false\n\nmodule.exports = createWrapperWithEmitter\nmodule.exports.wrapFunction = wrapFunction\nmodule.exports.wrapInPlace = wrapInPlace\nmodule.exports.argsToArray = argsToArray\n\nfunction createWrapperWithEmitter(emitter, always) {\n  emitter || (emitter = ee)\n\n  wrapFn.inPlace = inPlace\n  wrapFn.flag = flag\n\n  return wrapFn\n\n  function wrapFn (fn, prefix, getContext, methodName, bubble) {\n    // Unless fn is both wrappable and unwrapped, return it unchanged.\n    if (notWrappable(fn)) return fn\n\n    if (!prefix) prefix = ''\n\n    nrWrapper[flag] = fn\n    copy(fn, nrWrapper, emitter)\n    return nrWrapper\n\n    function nrWrapper () {\n      var args\n      var originalThis\n      var ctx\n      var result\n\n      try {\n        originalThis = this\n        args = slice(arguments)\n\n        if (typeof getContext === 'function') {\n          ctx = getContext(args, originalThis)\n        } else {\n          ctx = getContext || {}\n        }\n      } catch (e) {\n        report([e, '', [args, originalThis, methodName], ctx], emitter)\n      }\n\n      // Warning: start events may mutate args!\n      safeEmit(prefix + 'start', [args, originalThis, methodName], ctx, bubble)\n\n      try {\n        result = fn.apply(originalThis, args)\n        return result\n      } catch (err) {\n        safeEmit(prefix + 'err', [args, originalThis, err], ctx, bubble)\n\n        // rethrow error so we don't effect execution by observing.\n        throw err\n      } finally {\n        // happens no matter what.\n        safeEmit(prefix + 'end', [args, originalThis, result], ctx, bubble)\n      }\n    }\n  }\n\n  function inPlace (obj, methods, prefix, getContext, bubble) {\n    if (!prefix) prefix = ''\n    // If prefix starts with '-' set this boolean to add the method name to\n    // the prefix before passing each one to wrap.\n    var prependMethodPrefix = (prefix.charAt(0) === '-')\n    var fn\n    var method\n    var i\n\n    for (i = 0; i < methods.length; i++) {\n      method = methods[i]\n      fn = obj[method]\n\n      // Unless fn is both wrappable and unwrapped bail,\n      // so we don't add extra properties with undefined values.\n      if (notWrappable(fn)) continue\n\n      obj[method] = wrapFn(fn, (prependMethodPrefix ? method + prefix : prefix), getContext, method, bubble)\n    }\n  }\n\n  function safeEmit (evt, arr, store, bubble) {\n    if (inWrapper && !always) return\n    var prev = inWrapper\n    inWrapper = true\n    try {\n      emitter.emit(evt, arr, store, always, bubble)\n    } catch (e) {\n      report([e, evt, arr, store], emitter)\n    }\n    inWrapper = prev\n  }\n}\n\nfunction report (args, emitter) {\n  emitter || (emitter = ee)\n  try {\n    emitter.emit('internal-error', args)\n  } catch (err) {}\n}\n\nfunction copy (from, to, emitter) {\n  if (Object.defineProperty && Object.keys) {\n    // Create accessors that proxy to actual function\n    try {\n      var keys = Object.keys(from)\n      keys.forEach(function (key) {\n        Object.defineProperty(to, key, {\n          get: function () { return from[key] },\n          set: function (val) { from[key] = val; return val }\n        })\n      })\n      return to\n    } catch (e) {\n      report([e], emitter)\n    }\n  }\n  // fall back to copying properties\n  for (var i in from) {\n    if (has.call(from, i)) {\n      to[i] = from[i]\n    }\n  }\n  return to\n}\n\nfunction notWrappable (fn) {\n  return !(fn && fn instanceof Function && fn.apply && !fn[flag])\n}\n\nfunction wrapFunction(fn, wrapper) {\n  var wrapped = wrapper(fn)\n  wrapped[flag] = fn\n  copy(fn, wrapped, ee)\n  return wrapped\n}\n\nfunction wrapInPlace(obj, fnName, wrapper) {\n  var fn = obj[fnName]\n  obj[fnName] = wrapFunction(fn, wrapper)\n}\n\nfunction argsToArray() {\n  var len = arguments.length\n  var arr = new Array(len)\n  for (var i = 0; i < len; ++i) {\n    arr[i] = arguments[i]\n  }\n  return arr\n}\n\n},{}]},{},[\"loader\"])\n\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getConfiguration: getConfiguration\n}\n\nfunction getConfiguration(path) {\n  if (!NREUM.init) return\n  var val = NREUM.init\n  var parts = path.split('.')\n  for (var i = 0; i < parts.length - 1; i++) {\n    val = val[parts[i]]\n    if (typeof val !== 'object') return\n  }\n  val = val[parts[parts.length - 1]]\n  return val\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar lastTimestamp = new Date().getTime()\nvar offset = lastTimestamp\n\nvar performanceCheck = require(10)\n\nmodule.exports = now\nmodule.exports.offset = offset\nmodule.exports.getLastTimestamp = getLastTimestamp\n\nfunction now () {\n  if (performanceCheck.exists && performance.now) {\n    return Math.round(performance.now())\n  }\n  // ensure a new timestamp is never smaller than a previous timestamp\n  return (lastTimestamp = Math.max(new Date().getTime(), lastTimestamp)) - offset\n}\n\nfunction getLastTimestamp() {\n  return lastTimestamp\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = protocolAllowed\n\nfunction protocolAllowed (location) {\n  return !!(location && location.protocol && location.protocol !== 'file:')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// collect page view timings unless the feature is explicitly disabled\nif ('init' in NREUM && 'page_view_timing' in NREUM.init &&\n  'enabled' in NREUM.init.page_view_timing &&\n  NREUM.init.page_view_timing.enabled === false) {\n  return\n}\n\nvar handle = require(\"handle\")\nvar loader = require(\"loader\")\nvar subscribeToVisibilityChange = require(7)\n\nvar origEvent = NREUM.o.EV\n\n// paint metrics\nfunction perfObserver(list, observer) {\n  var entries = list.getEntries()\n  entries.forEach(function (entry) {\n    if (entry.name === 'first-paint') {\n      handle('timing', ['fp', Math.floor(entry.startTime)])\n    } else if (entry.name === 'first-contentful-paint') {\n      handle('timing', ['fcp', Math.floor(entry.startTime)])\n    }\n  })\n}\n\n// largest contentful paint\nfunction lcpObserver(list, observer) {\n  var entries = list.getEntries()\n  if (entries.length > 0) {\n    handle('lcp', [entries[entries.length - 1]])\n  }\n}\n\nfunction clsObserver(list) {\n  list.getEntries().forEach(function(entry) {\n    if (!entry.hadRecentInput) {\n      handle('cls', [entry])\n    }\n  })\n}\n\nvar performanceObserver\nvar lcpPerformanceObserver\nvar clsPerformanceObserver\nif ('PerformanceObserver' in window && typeof window.PerformanceObserver === 'function') {\n  // passing in an unknown entry type to observer could throw an exception\n  performanceObserver = new PerformanceObserver(perfObserver) // eslint-disable-line no-undef\n  try {\n    performanceObserver.observe({entryTypes: ['paint']})\n  } catch (e) {}\n\n  lcpPerformanceObserver = new PerformanceObserver(lcpObserver) // eslint-disable-line no-undef\n  try {\n    lcpPerformanceObserver.observe({entryTypes: ['largest-contentful-paint']})\n  } catch (e) {}\n\n  clsPerformanceObserver = new PerformanceObserver(clsObserver) // eslint-disable-line no-undef\n  try {\n    clsPerformanceObserver.observe({type: 'layout-shift', buffered: true})\n  } catch (e) {}\n}\n\n// first interaction and first input delay\nif ('addEventListener' in document) {\n  var fiRecorded = false\n  var allowedEventTypes = ['click', 'keydown', 'mousedown', 'pointerdown', 'touchstart']\n  allowedEventTypes.forEach(function (e) {\n    document.addEventListener(e, captureInteraction, false)\n  })\n}\n\nfunction captureInteraction(evt) {\n  if (evt instanceof origEvent && !fiRecorded) {\n    var fi = Math.round(evt.timeStamp)\n    var attributes = {\n      type: evt.type\n    }\n\n    // The value of Event.timeStamp is epoch time in some old browser, and relative\n    // timestamp in newer browsers. We assume that large numbers represent epoch time.\n    if (fi <= loader.now()) {\n      attributes['fid'] = loader.now() - fi\n    } else if (fi > loader.offset && fi <= Date.now()) {\n      fi = fi - loader.offset\n      attributes['fid'] = loader.now() - fi\n    } else {\n      fi = loader.now()\n    }\n\n    fiRecorded = true\n    handle('timing', ['fi', fi, attributes])\n  }\n}\n\n// page visibility events\nsubscribeToVisibilityChange(captureVisibilityChange)\n\nfunction captureVisibilityChange(state) {\n  handle('pageHide', [loader.now(), state])\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Feature-detection is much preferred over using User Agent to detect browser.\n// However, there are cases where feature detection is not possible, for example\n// when a specific version of a browser has a bug that requires a workaround in just\n// that version.\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Browser_Name\nvar agentName = null\nvar agentVersion = null\nvar safari = /Version\\/(\\S+)\\s+Safari/\n\nif (navigator.userAgent) {\n  var userAgent = navigator.userAgent\n  var parts = userAgent.match(safari)\n\n  if (parts && userAgent.indexOf('Chrome') === -1 &&\n      userAgent.indexOf('Chromium') === -1) {\n    agentName = 'Safari'\n    agentVersion = parts[1]\n  }\n}\n\nmodule.exports = {\n  agent: agentName,\n  version: agentVersion,\n  match: match\n}\n\nfunction match (name, version) {\n  if (!agentName) {\n    return false\n  }\n\n  if (name !== agentName) {\n    return false\n  }\n\n  // version not provided, only match by name\n  if (!version) {\n    return true\n  }\n\n  // version provided, but not detected - not reliable match\n  if (!agentVersion) {\n    return false\n  }\n\n  var detectedParts = agentVersion.split('.')\n  var requestedParts = version.split('.')\n  for (var i = 0; i < requestedParts.length; i++) {\n    if (requestedParts[i] !== detectedParts[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = subscribeToVisibilityChange\n\nvar hidden, eventName, state\n\nif (typeof document.hidden !== 'undefined') {\n  hidden = 'hidden'\n  eventName = 'visibilitychange'\n  state = 'visibilityState'\n} else if (typeof document.msHidden !== 'undefined') {\n  hidden = 'msHidden'\n  eventName = 'msvisibilitychange'\n} else if (typeof document.webkitHidden !== 'undefined') {\n  hidden = 'webkitHidden'\n  eventName = 'webkitvisibilitychange'\n  state = 'webkitVisibilityState'\n}\n\nfunction subscribeToVisibilityChange(cb) {\n  if ('addEventListener' in document && eventName) {\n    document.addEventListener(eventName, handleVisibilityChange, false)\n  }\n\n  function handleVisibilityChange() {\n    if (state && document[state]) {\n      cb(document[state])\n    } else if (document[hidden]) {\n      cb('hidden')\n    } else {\n      cb('visible')\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = mapOwn\n\nfunction mapOwn (obj, fn) {\n  var results = []\n  var key = ''\n  var i = 0\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      results[i] = fn(key, obj[key])\n      i += 1\n    }\n  }\n\n  return results\n}\n","/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  exists: typeof (window.performance) !== 'undefined' && window.performance.timing && typeof (window.performance.timing.navigationStart) !== 'undefined'\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ctxId = 'nr@context'\nvar getOrSet = require(\"gos\")\nvar mapOwn = require(8)\n\nvar eventBuffer = {}\nvar emitters = {}\n\nvar baseEE = module.exports = ee()\nmodule.exports.getOrSetContext = getOrSetContext\n\nbaseEE.backlog = eventBuffer\n\nfunction EventContext () {}\n\nfunction ee (old) {\n  var handlers = {}\n  var bufferGroupMap = {}\n\n  var emitter = {\n    on: addEventListener,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    emit: emit,\n    get: getOrCreate,\n    listeners: listeners,\n    context: context,\n    buffer: bufferEventsByGroup,\n    abort: abortIfNotLoaded,\n    aborted: false\n  }\n\n  return emitter\n\n  function context (contextOrStore) {\n    if (contextOrStore && contextOrStore instanceof EventContext) {\n      return contextOrStore\n    } else if (contextOrStore) {\n      return getOrSet(contextOrStore, ctxId, getNewContext)\n    } else {\n      return getNewContext()\n    }\n  }\n\n  function emit (type, args, contextOrStore, force, bubble) {\n    if (bubble !== false) bubble = true\n    if (baseEE.aborted && !force) { return }\n    if (old && bubble) old(type, args, contextOrStore)\n\n    var ctx = context(contextOrStore)\n    var handlersArray = listeners(type)\n    var len = handlersArray.length\n\n    // Extremely verbose debug logging\n    // if ([/^xhr/].map(function (match) {return type.match(match)}).filter(Boolean).length) {\n    //  console.log(type + ' args:')\n    //  console.log(args)\n    //  console.log(type + ' handlers array:')\n    //  console.log(handlersArray)\n    //  console.log(type + ' context:')\n    //  console.log(ctx)\n    //  console.log(type + ' ctxStore:')\n    //  console.log(ctxStore)\n    // }\n\n    // Apply each handler function in the order they were added\n    // to the context with the arguments\n\n    for (var i = 0; i < len; i++) handlersArray[i].apply(ctx, args)\n\n    // Buffer after emitting for consistent ordering\n    var bufferGroup = eventBuffer[bufferGroupMap[type]]\n    if (bufferGroup) {\n      bufferGroup.push([emitter, type, args, ctx])\n    }\n\n    // Return the context so that the module that emitted can see what was done.\n    return ctx\n  }\n\n  function addEventListener (type, fn) {\n    // Retrieve type from handlers, if it doesn't exist assign the default and retrieve it.\n    handlers[type] = listeners(type).concat(fn)\n  }\n\n  function removeEventListener (type, fn) {\n    var listeners = handlers[type]\n    if (!listeners) return\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1)\n      }\n    }\n  }\n\n  function listeners (type) {\n    return handlers[type] || []\n  }\n\n  function getOrCreate (name) {\n    return (emitters[name] = emitters[name] || ee(emit))\n  }\n\n  function bufferEventsByGroup (types, group) {\n    mapOwn(types, function (i, type) {\n      group = group || 'feature'\n      bufferGroupMap[type] = group\n      if (!(group in eventBuffer)) {\n        eventBuffer[group] = []\n      }\n    })\n  }\n}\n\n// get context object from store object, or create if does not exist\nfunction getOrSetContext(obj) {\n  return getOrSet(obj, ctxId, getNewContext)\n}\n\nfunction getNewContext () {\n  return new EventContext()\n}\n\n// abort should be called 30 seconds after the page has started running\n// We should drop our data and stop collecting if we still have a backlog, which\n// signifies the rest of the agent wasn't loaded\nfunction abortIfNotLoaded () {\n  if (eventBuffer.api || eventBuffer.feature) {\n    baseEE.aborted = true\n    eventBuffer = baseEE.backlog = {}\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = getOrSet\n\n// Always returns the current value of obj[prop], even if it has to set it first\nfunction getOrSet (obj, prop, getVal) {\n  // If the value exists return it.\n  if (has.call(obj, prop)) return obj[prop]\n\n  var val = getVal()\n\n  // Attempt to set the property so it's not enumerable\n  if (Object.defineProperty && Object.keys) {\n    try {\n      Object.defineProperty(obj, prop, {\n        value: val, // old IE inherits non-write-ability\n        writable: true,\n        enumerable: false\n      })\n\n      return val\n    } catch (e) {\n      // Can't report internal errors,\n      // because GOS is a dependency of the reporting mechanisms\n    }\n  }\n\n  // fall back to setting normally\n  obj[prop] = val\n  return val\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\").get('handle')\n\n// Exported for register-handler to attach to.\nmodule.exports = handle\nhandle.ee = ee\n\nfunction handle (type, args, ctx, group) {\n  ee.buffer([type], group)\n  ee.emit(type, args, ctx)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Start assigning ids at 1 so 0 can always be used for window, without\n// actually setting it (which would create a global variable).\nvar index = 1\nvar prop = 'nr@id'\nvar getOrSet = require(\"gos\")\n\nmodule.exports = id\n\n// Always returns id of obj, may tag obj with an id in the process.\nfunction id (obj) {\n  var type = typeof obj\n  // We can only tag objects, functions, and arrays with ids.\n  // For all primitive values we instead return -1.\n  if (!obj || !(type === 'object' || type === 'function')) return -1\n  if (obj === window) return 0\n\n  return getOrSet(obj, prop, function () { return index++ })\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar now = require(3)\nvar handle = require(\"handle\")\nvar mapOwn = require(8)\nvar ee = require(\"ee\")\nvar userAgent = require(6)\nvar protocolAllowed = require(4)\nvar config = require(2)\n\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\nvar win = window\nvar doc = win.document\n\nvar ADD_EVENT_LISTENER = 'addEventListener'\nvar ATTACH_EVENT = 'attachEvent'\nvar XHR = win.XMLHttpRequest\nvar XHR_PROTO = XHR && XHR.prototype\n\nvar disabled = !protocolAllowed(win.location)\n\nNREUM.o = {\n  ST: setTimeout,\n  SI: win.setImmediate,\n  CT: clearTimeout,\n  XHR: XHR,\n  REQ: win.Request,\n  EV: win.Event,\n  PR: win.Promise,\n  MO: win.MutationObserver\n}\n\nvar origin = '' + location\nvar defInfo = {\n  beacon: 'bam.nr-data.net',\n  errorBeacon: 'bam.nr-data.net',\n  agent: 'js-agent.newrelic.com/nr.min.js'\n}\n\nvar xhrWrappable = XHR &&\n  XHR_PROTO &&\n  XHR_PROTO[ADD_EVENT_LISTENER] &&\n  !/CriOS/.test(navigator.userAgent)\n\nvar exp = module.exports = {\n  offset: now.getLastTimestamp(),\n  now: now,\n  origin: origin,\n  features: {},\n  xhrWrappable: xhrWrappable,\n  userAgent: userAgent,\n  disabled: disabled\n}\n\nif (!protocolAllowed(win.location)) return\n\n// api loads registers several event listeners, but does not have any exports\nrequire(1)\n\n// paint timings\nrequire(5)\n\nif (doc[ADD_EVENT_LISTENER]) {\n  doc[ADD_EVENT_LISTENER]('DOMContentLoaded', loaded, false)\n  win[ADD_EVENT_LISTENER]('load', windowLoaded, false)\n} else {\n  doc[ATTACH_EVENT]('onreadystatechange', stateChange)\n  win[ATTACH_EVENT]('onload', windowLoaded)\n}\n\nhandle('mark', ['firstbyte', now.getLastTimestamp()], null, 'api')\n\nvar loadFired = 0\nfunction windowLoaded () {\n  if (loadFired++) return\n  var info = exp.info = NREUM.info\n\n  var firstScript = doc.getElementsByTagName('script')[0]\n  setTimeout(ee.abort, 30000)\n\n  if (!(info && info.licenseKey && info.applicationID && firstScript)) {\n    return ee.abort()\n  }\n\n  mapOwn(defInfo, function (key, val) {\n    // this will overwrite any falsy value in config\n    // This is intentional because agents may write an empty string to\n    // the agent key in the config, in which case we want to use the default\n    if (!info[key]) info[key] = val\n  })\n\n  var ts = now()\n  handle('mark', ['onload', ts + exp.offset], null, 'api')\n  handle('timing', ['load', ts])\n\n  var agent = doc.createElement('script')\n  agent.src = scheme + '://' + info.agent\n  firstScript.parentNode.insertBefore(agent, firstScript)\n}\n\nfunction stateChange () {\n  if (doc.readyState === 'complete') loaded()\n}\n\nfunction loaded () {\n  handle('mark', ['domContent', now() + exp.offset], null, 'api')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar slice = require(9)\nvar flag = 'nr@original'\nvar has = Object.prototype.hasOwnProperty\nvar inWrapper = false\n\nmodule.exports = createWrapperWithEmitter\nmodule.exports.wrapFunction = wrapFunction\nmodule.exports.wrapInPlace = wrapInPlace\nmodule.exports.argsToArray = argsToArray\n\nfunction createWrapperWithEmitter(emitter, always) {\n  emitter || (emitter = ee)\n\n  wrapFn.inPlace = inPlace\n  wrapFn.flag = flag\n\n  return wrapFn\n\n  function wrapFn (fn, prefix, getContext, methodName, bubble) {\n    // Unless fn is both wrappable and unwrapped, return it unchanged.\n    if (notWrappable(fn)) return fn\n\n    if (!prefix) prefix = ''\n\n    nrWrapper[flag] = fn\n    copy(fn, nrWrapper, emitter)\n    return nrWrapper\n\n    function nrWrapper () {\n      var args\n      var originalThis\n      var ctx\n      var result\n\n      try {\n        originalThis = this\n        args = slice(arguments)\n\n        if (typeof getContext === 'function') {\n          ctx = getContext(args, originalThis)\n        } else {\n          ctx = getContext || {}\n        }\n      } catch (e) {\n        report([e, '', [args, originalThis, methodName], ctx], emitter)\n      }\n\n      // Warning: start events may mutate args!\n      safeEmit(prefix + 'start', [args, originalThis, methodName], ctx, bubble)\n\n      try {\n        result = fn.apply(originalThis, args)\n        return result\n      } catch (err) {\n        safeEmit(prefix + 'err', [args, originalThis, err], ctx, bubble)\n\n        // rethrow error so we don't effect execution by observing.\n        throw err\n      } finally {\n        // happens no matter what.\n        safeEmit(prefix + 'end', [args, originalThis, result], ctx, bubble)\n      }\n    }\n  }\n\n  function inPlace (obj, methods, prefix, getContext, bubble) {\n    if (!prefix) prefix = ''\n    // If prefix starts with '-' set this boolean to add the method name to\n    // the prefix before passing each one to wrap.\n    var prependMethodPrefix = (prefix.charAt(0) === '-')\n    var fn\n    var method\n    var i\n\n    for (i = 0; i < methods.length; i++) {\n      method = methods[i]\n      fn = obj[method]\n\n      // Unless fn is both wrappable and unwrapped bail,\n      // so we don't add extra properties with undefined values.\n      if (notWrappable(fn)) continue\n\n      obj[method] = wrapFn(fn, (prependMethodPrefix ? method + prefix : prefix), getContext, method, bubble)\n    }\n  }\n\n  function safeEmit (evt, arr, store, bubble) {\n    if (inWrapper && !always) return\n    var prev = inWrapper\n    inWrapper = true\n    try {\n      emitter.emit(evt, arr, store, always, bubble)\n    } catch (e) {\n      report([e, evt, arr, store], emitter)\n    }\n    inWrapper = prev\n  }\n}\n\nfunction report (args, emitter) {\n  emitter || (emitter = ee)\n  try {\n    emitter.emit('internal-error', args)\n  } catch (err) {}\n}\n\nfunction copy (from, to, emitter) {\n  if (Object.defineProperty && Object.keys) {\n    // Create accessors that proxy to actual function\n    try {\n      var keys = Object.keys(from)\n      keys.forEach(function (key) {\n        Object.defineProperty(to, key, {\n          get: function () { return from[key] },\n          set: function (val) { from[key] = val; return val }\n        })\n      })\n      return to\n    } catch (e) {\n      report([e], emitter)\n    }\n  }\n  // fall back to copying properties\n  for (var i in from) {\n    if (has.call(from, i)) {\n      to[i] = from[i]\n    }\n  }\n  return to\n}\n\nfunction notWrappable (fn) {\n  return !(fn && fn instanceof Function && fn.apply && !fn[flag])\n}\n\nfunction wrapFunction(fn, wrapper) {\n  var wrapped = wrapper(fn)\n  wrapped[flag] = fn\n  copy(fn, wrapped, ee)\n  return wrapped\n}\n\nfunction wrapInPlace(obj, fnName, wrapper) {\n  var fn = obj[fnName]\n  obj[fnName] = wrapFunction(fn, wrapper)\n}\n\nfunction argsToArray() {\n  var len = arguments.length\n  var arr = new Array(len)\n  for (var i = 0; i < len; ++i) {\n    arr[i] = arguments[i]\n  }\n  return arr\n}\n"],"sourceRoot":"/source/"}