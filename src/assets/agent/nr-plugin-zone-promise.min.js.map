{"version":3,"sources":["node_modules/browser-pack/_prelude.js","plugins/zone-promise.js","nr-plugin-zone-promise.min.js"],"names":["modules","cache","entry","newRequire","name","jumped","currentRequire","__nr_require","previousRequire","Error","m","exports","call","x","id","i","length","1","require","module","init","pluginApi","api","instrument","instrumented","wrapZonePromise","window","Promise","toString","indexOf","promiseWrapper","inPlace","prototype","getPromise","args","originalThis","handle","frameworksEE","get","addEventListener","on","currentNode","getCurrentNode","this","promise","spaNode","prevNode","setCurrentNode"],"mappings":"CAUA,SAAAA,EAAAC,EAAAC,GAIA,QAAAC,GAAAC,EAAAC,GACA,IAAAJ,EAAAG,GAAA,CACA,IAAAJ,EAAAI,GAAA,CAIA,GAAAE,GAAA,kBAAAC,eAAAA,YACA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAMA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EACA,MAAA,IAAAK,OAAA,uBAAAL,EAAA,KAEA,GAAAM,GAAAT,EAAAG,IAAAO,WACAX,GAAAI,GAAA,GAAAQ,KAAAF,EAAAC,QAAA,SAAAE,GACA,GAAAC,GAAAd,EAAAI,GAAA,GAAAS,EACA,OAAAV,GAAAW,GAAAD,IACAH,EAAAA,EAAAC,SAEA,MAAAV,GAAAG,GAAAO,QAEA,IAAA,GA1BAH,GAAA,kBAAAD,eAAAA,aA0BAQ,EAAA,EAAAA,EAAAb,EAAAc,OAAAD,IAAAZ,EAAAD,EAAAa,GAGA,OAAAZ,KAEAc,GAAA,SAAAC,EAAAC,EAAAR,GC5BA,QAAAS,GAAAC,GACAA,IACAC,EAAAD,EACAE,KAOA,QAAAA,KACAC,GACAC,IAGA,QAAAA,KAEAC,OAAAC,QAAAC,WAAAC,QAAA,yBACAC,EAAAC,QAAAL,OAAAC,QAAAK,WAAA,QAAA,oBAAAC,GACAT,GAAA,GAIA,QAAAS,GAAAC,EAAAC,GACA,MAAAA,GAlCA,GAAAC,GAAAlB,EAAA,UACAmB,EAAAnB,EAAA,MAAAoB,IAAA,cACAR,EAAAZ,EAAA,iBAAAmB,GAEAf,EAAA,KACAE,GAAA,CAGAY,GAAA,gBAAAhB,IAQAM,OAAAa,iBAAA,mBAAA,WACAhB,MAqBAc,EAAAG,GAAA,yBAAA,SAAAN,EAAAC,GACA,GAAAb,EAAA,CACA,GAAAmB,GAAAnB,EAAAoB,gBACAD,KACAE,KAAAC,QAAAT,EACAQ,KAAAE,QAAAJ,EAEA,kBAAAP,GAAA,KACAA,EAAA,GAAAJ,EAAAI,EAAA,GAAA,kBAAAS,OAEA,kBAAAT,GAAA,KACAA,EAAA,GAAAJ,EAAAI,EAAA,GAAA,kBAAAS,WAKAN,EAAAG,GAAA,uBAAA,SAAAN,GACAZ,GACAqB,KAAAE,UACAF,KAAAG,SAAAxB,EAAAoB,iBACApB,EAAAyB,eAAAJ,KAAAE,YAIAR,EAAAG,GAAA,qBAAA,SAAAN,GACAZ,GACAqB,KAAAE,SACAvB,EAAAyB,eAAAJ,KAAAG,sBCgDW","file":"nr-plugin-zone-promise.min.js","sourcesContent":["// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requireuires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  // Save the require from previous bundle to this closure if any\n  var previousRequire = typeof __nr_require === 'function' && __nr_require\n\n  function newRequire (name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire = typeof __nr_require === 'function' && __nr_require\n        if (!jumped && currentRequire) return currentRequire(name, true)\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) return previousRequire(name, true)\n        throw new Error(\"Cannot find module '\" + name + \"'\")\n      }\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  // Override the current require with this new one\n  return newRequire\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handle = require(\"handle\")\nvar frameworksEE = require(\"ee\").get('frameworks')\nvar promiseWrapper = require(\"wrap-function\")(frameworksEE)\n\nvar api = null\nvar instrumented = false\n\n// register itself with the SPA feature\nhandle('spa-register', [init])\n\nfunction init(pluginApi) {\n  if (!pluginApi) return\n  api = pluginApi\n  instrument()\n}\n\nwindow.addEventListener('DOMContentLoaded', function () {\n  instrument()\n})\n\nfunction instrument() {\n  if (instrumented) return\n  wrapZonePromise()\n}\n\nfunction wrapZonePromise() {\n  // instrument Zone.js promise\n  if (window.Promise.toString().indexOf('ZoneAwarePromise') > -1) {\n    promiseWrapper.inPlace(window.Promise.prototype, ['then'], 'zonepromise-then-', getPromise)\n    instrumented = true\n  }\n}\n\nfunction getPromise (args, originalThis) {\n  return originalThis\n}\n\n// handle wrapped function events\nframeworksEE.on('zonepromise-then-start', function (args, originalThis) {\n  if (!api) return\n  var currentNode = api.getCurrentNode()\n  if (currentNode) {\n    this.promise = originalThis\n    this.spaNode = currentNode\n\n    if (typeof args[0] === 'function') {\n      args[0] = promiseWrapper(args[0], 'zonepromise-cb-', this)\n    }\n    if (typeof args[1] === 'function') {\n      args[1] = promiseWrapper(args[1], 'zonepromise-cb-', this)\n    }\n  }\n})\n\nframeworksEE.on('zonepromise-cb-start', function(args) {\n  if (!api) return\n  if (this.spaNode) {\n    this.prevNode = api.getCurrentNode()\n    api.setCurrentNode(this.spaNode)\n  }\n})\n\nframeworksEE.on('zonepromise-cb-end', function(args) {\n  if (!api) return\n  if (this.spaNode) {\n    api.setCurrentNode(this.prevNode)\n  }\n})\n","// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requireuires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  // Save the require from previous bundle to this closure if any\n  var previousRequire = typeof __nr_require === 'function' && __nr_require\n\n  function newRequire (name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire = typeof __nr_require === 'function' && __nr_require\n        if (!jumped && currentRequire) return currentRequire(name, true)\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) return previousRequire(name, true)\n        throw new Error(\"Cannot find module '\" + name + \"'\")\n      }\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  // Override the current require with this new one\n  return newRequire\n})\n({1:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handle = require(\"handle\")\nvar frameworksEE = require(\"ee\").get('frameworks')\nvar promiseWrapper = require(\"wrap-function\")(frameworksEE)\n\nvar api = null\nvar instrumented = false\n\n// register itself with the SPA feature\nhandle('spa-register', [init])\n\nfunction init(pluginApi) {\n  if (!pluginApi) return\n  api = pluginApi\n  instrument()\n}\n\nwindow.addEventListener('DOMContentLoaded', function () {\n  instrument()\n})\n\nfunction instrument() {\n  if (instrumented) return\n  wrapZonePromise()\n}\n\nfunction wrapZonePromise() {\n  // instrument Zone.js promise\n  if (window.Promise.toString().indexOf('ZoneAwarePromise') > -1) {\n    promiseWrapper.inPlace(window.Promise.prototype, ['then'], 'zonepromise-then-', getPromise)\n    instrumented = true\n  }\n}\n\nfunction getPromise (args, originalThis) {\n  return originalThis\n}\n\n// handle wrapped function events\nframeworksEE.on('zonepromise-then-start', function (args, originalThis) {\n  if (!api) return\n  var currentNode = api.getCurrentNode()\n  if (currentNode) {\n    this.promise = originalThis\n    this.spaNode = currentNode\n\n    if (typeof args[0] === 'function') {\n      args[0] = promiseWrapper(args[0], 'zonepromise-cb-', this)\n    }\n    if (typeof args[1] === 'function') {\n      args[1] = promiseWrapper(args[1], 'zonepromise-cb-', this)\n    }\n  }\n})\n\nframeworksEE.on('zonepromise-cb-start', function(args) {\n  if (!api) return\n  if (this.spaNode) {\n    this.prevNode = api.getCurrentNode()\n    api.setCurrentNode(this.spaNode)\n  }\n})\n\nframeworksEE.on('zonepromise-cb-end', function(args) {\n  if (!api) return\n  if (this.spaNode) {\n    api.setCurrentNode(this.prevNode)\n  }\n})\n\n},{}]},{},[1])\n\n"],"sourceRoot":"/source/"}