{"version":3,"sources":["node_modules/browser-pack/_prelude.js","agent/add-e.js","nr-dev.min.js","agent/aggregator.js","agent/api.js","agent/bel-serializer.js","agent/clean-url.js","agent/drain.js","agent/encode.js","agent/feature-flags.js","agent/harvest-scheduler.js","agent/harvest.js","agent/ie-version.js","agent/index.js","agent/location.js","agent/nav-cookie.js","agent/nav-timing.js","agent/paint-metrics.js","agent/register-handler.js","agent/s-hash.js","agent/single.js","agent/start-time.js","agent/stopwatch.js","agent/stringify.js","agent/submit-data.js","agent/timings.js","agent/unload.js","feature/err/aggregate/canonical-function-name.js","feature/err/aggregate/compute-stack-trace.js","feature/err/aggregate/format-stack-trace.js","feature/err/aggregate/index.js","feature/err/aggregate/string-hash-code.js","feature/ins/aggregate/index.js","feature/spa/aggregate/Interaction.js","feature/spa/aggregate/InteractionNode.js","feature/spa/aggregate/index.js","feature/spa/aggregate/serializer.js","feature/stn/aggregate/index.js","feature/xhr/aggregate/index.js","feature/xhr/instrument/parse-url.js","loader/config.js","loader/data-size.js","loader/firefox-version.js","loader/now.js","loader/unique-id.js","map-own/index.js","node_modules/lodash._slice/index.js","performance-check/index.js","reduce/index.js"],"names":["modules","cache","entry","newRequire","name","jumped","currentRequire","__nr_require","previousRequire","Error","m","exports","call","x","id","i","length","1","require","module","sType","callback","window","addEventListener","attachEvent","2","store","type","params","newMetrics","customParams","bucket","getBucket","metrics","aggregateMetrics","oldMetrics","count","mapOwn","key","value","updateMetric","metric","c","createMetricObject","t","sos","max","min","mergeMetrics","oldMetric","newMetric","mergeMetric","Math","aggregatedData","custom","get","take","types","results","hasData","toArray","obj","getValue","merge","3","setPageViewName","host","charAt","loader","customTransaction","finished","providedTime","time","offset","agg","addToTrace","start","origin","handle","evt","report","n","s","e","end","o","inlineHit","request_name","queue_time","app_time","total_be_time","dom_time","fe_time","encodeURIComponent","cycle","info","beacon","url","scheme","licenseKey","applicationID","submitData","img","setErrorHandler","handler","onerror","addRelease","releaseCount","releaseIds","slice","register","harvest","single","config","getConfiguration","on","qs","api","fnName","fn","4","nullable","val","comma","numeric","noDefault","floor","toString","undefined","getAddStringContext","addString","str","String","hasOwnProp","stringTable","stringTableIdx","quoteString","Object","hasOwnProperty","create","addCustomAttributes","attrs","attrParts","MAX_ATTRIBUTES","serializedValue","stringify","push","replace","escapable","prototype","5","withHash","withoutHash","keepHash","6","emitEvent","groupHandlers","registration","sourceEE","ee","ctx","args","apply","baseEE","handlers","group","bufferedEventsInGroup","backlog","eventType","handlerRegistrationList","7","real","charMap","safeEncoded","fromArray","maxBytes","bytes","join","payload","total","result","feature","dataArray","next","intermediate","param","%2C","%3A","%2F","%40","%24","%3B","charList","k","RegExp","8","drain","flags","flag","activatedFeatures","emit","active","9","HarvestScheduler","endpoint","opts","this","started","timeoutHandle","startTimer","interval","initialDelay","scheduleHarvest","stopTimer","clearTimeout","delay","timer","setTimeout","runHarvest","onHarvestFinished","scheduler","getPayload","submitMethod","getSubmitMethod","retry","method","xhr","send","sendX","onFinished","sent","retryDelay","10","sendRUM","nr","queueTime","aggregator","applicationTime","stopwatch","measure","measuresMetrics","measuresQueryString","metricName","protocol","chunksForQueryString","baseQueryString","encode","ttGuid","user","account","product","features","performance","navTimingApiData","timing","addPT","navigation","addPN","getEntriesByType","entries","forEach","startTime","addPaintMetric","extra","userAttributes","atts","customJsAttributes","jsAttributes","queryString","jsonp","sendAllFromUnload","sents","_events","unload","reduce","or","a","b","createPayload","options","makeBody","createAccumulator","makeQueryString","listeners","singlePayload","body","cbFinished","_send","errorBeacon","cm","useBody","fullUrl","status","tooManyRequestsDelay","needResponse","responseText","xhrUsable","haveSendBeacon","pingErrors","ieVersion","transactionNameParam","transactionName","tNamePlain","listener","resetListeners","areCookiesEnabled","NREUM","init","privacy","cookies_enabled","sa","version","now","cleanURL","locationUtil","getLocation","accumulator","navigator","sendBeacon","addMetric","sendFinal","11","div","document","createElement","innerHTML","len","getElementsByTagName","12","finalHarvest","navCookie","conditionallySet","subscribeToUnload","registerHandler","activateFeatures","autorun","setToken","mark","13","location","14","exp","setCookie","cookie","Number","Date","sHash","href","referrer","15","pt","v","START","of","addRel","UNLOAD_EVENT","REDIRECT","END","DOMAIN_LOOKUP","ONNECT","REQUEST","RESPONSE","domLoading","domInteractive","DOM_CONTENT_LOAD_EVENT","domComplete","LOAD_EVENT","pn","redirectCount","prop","relativeValue","round","navTimingValues","nt","16","paintMetrics","17","defaultRegister","registerWithSpecificEmitter","handleEE","list","18","h","charCodeAt","abs","19","res","called","arguments","20","findStartTime","starttime","findStartWebTiming","findStartCookie","ffVersion","performanceCheck","exists","navigationStart","aCookies","split","indexOf","startPage","referrerPage","bReferrerMatch","aSubCookies","substring","j","substr","docReferrer","getTime","21","markName","markTime","marks","startMark","endMark","22","","err","quote","string","lastIndex","test","meta","holder","isFinite","partial","Array","\b","\t","\n","\f","\r","\"","\\","23","element","src","firstScript","parentNode","insertBefore","sync","request","XMLHttpRequest","open","withCredentials","setRequestHeader","xhrSync","Image","24","isEnabled","maxLCPTimeSeconds","initialHarvestSeconds","harvestTimeSeconds","prepareHarvest","processTiming","updateLatestLcp","updateClsScore","updatePageHide","recordLcp","lcpRecorded","lcp","lcpEntry","cls","size","eid","addTiming","previous","clsEntry","timestamp","state","pageHideRecorded","recordUnload","addCls","timings","timingsSent","appendGlobalCustomAttributes","timingAttributes","customAttributes","data","enabled","25","cb","oneCall","addE","26","canonicalFunctionName","orig","match","canonicalFunctionNameRe","27","computeStackTrace","ex","stack","computeStackTraceFromStacktraceProp","debug","computeStackTraceFromStackProp","computeStackTraceFromOperaMultiLineMessage","computeStackTraceBySourceAndLine","computeStackTraceWithMessageOnly","mode","stackString","frames","errorInfo","parseStackProp","stackLines","wrapperSeen","getClassName","message","formatStackTrace","line","getElement","isWrapper","func","parts","gecko","chrome","column","chrome_eval","ie_eval","className","sourceURL","classNameRegex","exec","constructor","functionName","stacktrace","testRE","lines","lineRE1","lineRE2","lineRE3","scripts","inlineScriptBlocks","has","item","28","truncateStackLines","truncatedLines","truncateSize","MAX_STACK_TRACE_LENGTH","stripNewlinesRegex","29","onHarvestStarted","currentBody","ri","errorOnPage","pve","getBucketName","nameHash","stringHashCode","exceptionClass","stackHash","canonicalizeURL","cleanedOrigin","cleanedURL","buildCanonicalStackString","stackInfo","canonicalStack","frame","canonicalizeStackURLs","originalURL","storeError","internal","setCustom","request_uri","pathname","stackReported","browser_stack_hash","stack_trace","hash","pageviewReported","pageview","_interactionId","errorCache","att","jsAttributesHash","aggregateHash","interaction","globalCustomParams","localCustomParams","root","browserInteractionId","_interactionNodeId","parentNodeId","30","charVal","31","ua","at","ins","events","currentEvents","concat","addPageAction","attributes","set","eventAttributes","eventsPerHarvest","width","height","documentElement","clientWidth","clientHeight","defaults","timeSinceLoad","browserWidth","browserHeight","referrerUrl","currentUrl","pageUrl","actionName","setCustomAttribute","eventsPerMinute","32","Interaction","eventName","routeName","lastId","nodes","REMAINING","finishTimer","checkingFinish","lastCb","lastFinish","InteractionNode","trigger","initialPageURL","oldRoute","newURL","oldURL","originals","originalSetTimeout","ST","originalClearTimeout","CT","InteractionPrototype","checkFinish","_resetFinishCheck","newRoute","finish","onNodeAdded","endTimestamp","customAttrs","attr","33","parent","INTERACTION","children","jsEnd","jsTime","MAX_NODES","InteractionNodePrototype","child","dontWait","node","exclusiveTime","cancelled","34","saveNode","overwrite","SPA_NODE","currentNode","resolvePromise","resolved","getCurrentNode","setCurrentNode","newNode","pageLoaded","initialPageLoad","lastSeenUrl","lastSeenRouteName","prevNode","onInteractionFinished","interactionsToHarvest","serializer","serializeMultiple","navTiming","interactionsSent","getActionText","nodeType","tagName","toLowerCase","goodNodeTypes","isGoodNode","title","innerText","saveInteraction","ignored","save","routeChange","uniqueId","generateUuid","firstPaint","firstContentfulPaint","configuration","parseUrl","mutationEE","promiseEE","historyEE","eventsEE","timerEE","fetchEE","jsonpEE","xhrEE","tracerEE","dataSize","INTERACTION_EVENTS","MAX_TIMER_BUDGET","FN_START","FN_END","CB_START","INTERACTION_API","JSONP_NODE","FETCH_START","FETCH_DONE","FETCH_BODY","JSONP_END","origRequest","REQ","timerMap","timerBudget","nodeOnLastHashUpdate","childTime","depth","callbackStart","ct","callbackEnd","totalTime","isTraced","tracedTime","tracerDone","interactionContext","hasCb","inc","activeNodeFor","pluginApi","eventSource","ev","evName","eventNode","__nrNode","context","spaNode","ixn","target","timerId","timerDuration","dt","parsed","hostname","port","txSize","rxSize","isJSONP","fetchArguments","dtPayload","bodyPromise","URL","toUpperCase","isFetch","hashChangedDuringCb","onload","el","isScript","nodeName","getCtx","actionText","customName","currentRouteName","35","interactions","serialized","serializeInteraction","serializeSingle","isRouteChange","addNode","nodeList","firstTimestamp","typeName","typeId","typeIdsByName","startTimestamp","childCount","attrCount","apmAttributes","hasNavTiming","isInitialPage","appTime","fields","includeHashFragment","spanId","traceId","unshift","seperator","navTimingNode","prev","ajax","customTracer","36","storeTiming","_t","timeOffset","storeSTN","storeTimer","category","storeEvent","currentEvent","ignoredEvents","evtName","evtOrigin","rename","classList","FileReader","storeHist","path","old","storeResources","resources","currentResource","initiatorType","fetchStart","responseEnd","entryType","laststart","storeErrorAgg","storeXhrAgg","duration","stn","nodeCount","maxNodesPerHarvest","traceArr","trace","mergeSTNs","takeSTNs","stns","toAggregate","sort","byStart","smearEvtsByOrigin","flatten","sentTrace","stnInfo","st","ptid","ja","maxGap","maxLen","lastO","byOrigin","lastArr","last","trivial","limit","xhrWrappable","mouseup","mousedown","typing","scrolling","mousing","touching","keydown","keyup","keypress","mousemove","mouseenter","mouseleave","mouseover","mouseout","scroll","touchstart","touchmove","touchend","touchcancel","touchenter","touchleave","_takeSTNs","37","storeXhr","cat","38","stringsToParsedUrls","urlEl","ret","firstSplit","pop","sameProtocol","sameDomain","domain","sameOrigin","39","40","ArrayBuffer","byteLength","Blob","FormData","JSON","41","userAgent","42","lastTimestamp","getLastTimestamp","43","getRandomValue","randomVals","rvIndex","random","crypto","msCrypto","getRandomValues","Uint8Array","template","generateSpanId","generateRandomHexString","generateTraceId","chars","44","45","array","index","46","47","arr"],"mappings":"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","file":"nr-dev.min.js","sourcesContent":["// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requireuires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  // Save the require from previous bundle to this closure if any\n  var previousRequire = typeof __nr_require === 'function' && __nr_require\n\n  function newRequire (name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire = typeof __nr_require === 'function' && __nr_require\n        if (!jumped && currentRequire) return currentRequire(name, true)\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) return previousRequire(name, true)\n        throw new Error(\"Cannot find module '\" + name + \"'\")\n      }\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  // Override the current require with this new one\n  return newRequire\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Safely add an event listener to window in any browser\nmodule.exports = function (sType, callback) {\n  if ('addEventListener' in window) {\n    return window.addEventListener(sType, callback, false)\n  } else if ('attachEvent' in window) {\n    return window.attachEvent('on' + sType, callback)\n  }\n}\n","// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requireuires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  // Save the require from previous bundle to this closure if any\n  var previousRequire = typeof __nr_require === 'function' && __nr_require\n\n  function newRequire (name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire = typeof __nr_require === 'function' && __nr_require\n        if (!jumped && currentRequire) return currentRequire(name, true)\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) return previousRequire(name, true)\n        throw new Error(\"Cannot find module '\" + name + \"'\")\n      }\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  // Override the current require with this new one\n  return newRequire\n})\n({1:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Safely add an event listener to window in any browser\nmodule.exports = function (sType, callback) {\n  if ('addEventListener' in window) {\n    return window.addEventListener(sType, callback, false)\n  } else if ('attachEvent' in window) {\n    return window.attachEvent('on' + sType, callback)\n  }\n}\n\n},{}],2:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\n\nvar aggregatedData = {}\n\nmodule.exports = {\n  store: store,\n  take: take,\n  get: get,\n  merge: mergeMetrics\n}\n\n// Items with the same type and name get aggregated together\n// params are example data from the aggregated items\n// metrics are the numeric values to be aggregated\nfunction store (type, name, params, newMetrics, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  bucket.metrics = aggregateMetrics(newMetrics, bucket.metrics)\n  return bucket\n}\n\nfunction aggregateMetrics (newMetrics, oldMetrics) {\n  if (!oldMetrics) oldMetrics = {count: 0}\n  oldMetrics.count += 1\n  mapOwn(newMetrics, function (key, value) {\n    oldMetrics[key] = updateMetric(value, oldMetrics[key])\n  })\n  return oldMetrics\n}\n\nfunction updateMetric (value, metric) {\n  // When there is only one data point, the c (count), min, max, and sos (sum of squares) params are superfluous.\n  if (!metric) return {t: value}\n\n  // but on the second data point, we need to calculate the other values before aggregating in new values\n  if (!metric.c) {\n    metric = createMetricObject(metric.t)\n  }\n\n  // at this point, metric is always uncondensed\n  metric.c += 1\n  metric.t += value\n  metric.sos += value * value\n  if (value > metric.max) metric.max = value\n  if (value < metric.min) metric.min = value\n\n  return metric\n}\n\n/**\n * Merge metrics object into existing metrics.\n *\n * @param {string} type\n * @param {string} name\n * @param {object} metrics - Metrics to merge.\n */\nfunction mergeMetrics (type, name, metrics, params, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  if (!bucket.metrics) {\n    bucket.metrics = metrics\n    return\n  }\n\n  var oldMetrics = bucket.metrics\n  oldMetrics.count += metrics.count\n\n  // iterate through each new metric and merge\n  mapOwn(metrics, function (key, value) {\n    // count is a special case handled above\n    if (key === 'count') return\n\n    var oldMetric = oldMetrics[key]\n    var newMetric = metrics[key]\n\n    // handling the case where newMetric is a single-value first\n    if (newMetric && !newMetric.c) {\n      oldMetrics[key] = updateMetric(newMetric.t, oldMetric)\n    } else { // newMetric is a metric object\n      oldMetrics[key] = mergeMetric(newMetric, oldMetrics[key])\n    }\n  })\n}\n\nfunction mergeMetric(newMetric, oldMetric) {\n  if (!oldMetric) return newMetric\n\n  if (!oldMetric.c) {\n    // oldMetric is a single-value\n    oldMetric = createMetricObject(oldMetric.t)\n  }\n\n  oldMetric.min = Math.min(newMetric.min, oldMetric.min)\n  oldMetric.max = Math.max(newMetric.max, oldMetric.max)\n  oldMetric.t += newMetric.t\n  oldMetric.sos += newMetric.sos\n  oldMetric.c += newMetric.c\n\n  return oldMetric\n}\n\n// take a value and create a metric object\nfunction createMetricObject (value) {\n  return {\n    t: value,\n    min: value,\n    max: value,\n    sos: value * value,\n    c: 1\n  }\n}\n\nfunction getBucket (type, name, params, customParams) {\n  if (!aggregatedData[type]) aggregatedData[type] = {}\n  var bucket = aggregatedData[type][name]\n  if (!bucket) {\n    bucket = aggregatedData[type][name] = { params: params || {} }\n    if (customParams) {\n      bucket.custom = customParams\n    }\n  }\n  return bucket\n}\n\nfunction get (type, name) {\n  // if name is passed, get a single bucket\n  if (name) return aggregatedData[type] && aggregatedData[type][name]\n  // else, get all buckets of that type\n  return aggregatedData[type]\n}\n\n// Like get, but for many types and it deletes the retrieved content from the aggregatedData\nfunction take (types) {\n  var results = {}\n  var type = ''\n  var hasData = false\n  for (var i = 0; i < types.length; i++) {\n    type = types[i]\n    results[type] = toArray(aggregatedData[type])\n    if (results[type].length) hasData = true\n    delete aggregatedData[type]\n  }\n  return hasData ? results : null\n}\n\nfunction toArray (obj) {\n  if (typeof obj !== 'object') return []\n\n  return mapOwn(obj, getValue)\n}\n\nfunction getValue (key, value) {\n  return value\n}\n\n},{}],3:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar register = require(17)\nvar harvest = require(10)\nvar agg = require(2)\nvar single = require(19)\nvar submitData = require(23)\nvar mapOwn = require(44)\nvar loader = require(\"loader\")\nvar handle = require(\"handle\")\nvar config = require(39)\nvar cycle = 0\n\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\nharvest.on('jserrors', function () {\n  return { qs: agg.take([ 'cm' ]) }\n})\n\nvar api = {\n  finished: single(finished),\n  setPageViewName: setPageViewName,\n  setErrorHandler: setErrorHandler,\n  addToTrace: addToTrace,\n  inlineHit: inlineHit,\n  addRelease: addRelease\n}\n\n// Hook all of the api functions up to the queues/stubs created in loader/api.js\nmapOwn(api, function (fnName, fn) {\n  register('api-' + fnName, fn, 'api')\n})\n\n// All API functions get passed the time they were called as their\n// first parameter. These functions can be called asynchronously.\n\nfunction setPageViewName (t, name, host) {\n  if (typeof name !== 'string') return\n  if (name.charAt(0) !== '/') name = '/' + name\n  loader.customTransaction = (host || 'http://custom.transaction') + name\n}\n\nfunction finished (t, providedTime) {\n  var time = providedTime ? providedTime - loader.offset : t\n  agg.store('cm', 'finished', { name: 'finished' }, { time: time })\n  addToTrace(t, { name: 'finished', start: time + loader.offset, origin: 'nr' })\n  handle('api-addPageAction', [ time, 'finished' ])\n}\n\nfunction addToTrace (t, evt) {\n  if (!(evt && typeof evt === 'object' && evt.name && evt.start)) return\n\n  var report = {\n    n: evt.name,\n    s: evt.start - loader.offset,\n    e: (evt.end || evt.start) - loader.offset,\n    o: evt.origin || '',\n    t: 'api'\n  }\n\n  handle('bstApi', [report])\n}\n\n// NREUM.inlineHit(request_name, queue_time, app_time, total_be_time, dom_time, fe_time)\n//\n// request_name - the 'web page' name or service name\n// queue_time - the amount of time spent in the app tier queue\n// app_time - the amount of time spent in the application code\n// total_be_time - the total roundtrip time of the remote service call\n// dom_time - the time spent processing the result of the service call (or user defined)\n// fe_time - the time spent rendering the result of the service call (or user defined)\nfunction inlineHit (t, request_name, queue_time, app_time, total_be_time, dom_time, fe_time) {\n  request_name = window.encodeURIComponent(request_name)\n  cycle += 1\n\n  if (!loader.info.beacon) return\n\n  var url = scheme + '://' + loader.info.beacon + '/1/' + loader.info.licenseKey\n\n  url += '?a=' + loader.info.applicationID + '&'\n  url += 't=' + request_name + '&'\n  url += 'qt=' + ~~queue_time + '&'\n  url += 'ap=' + ~~app_time + '&'\n  url += 'be=' + ~~total_be_time + '&'\n  url += 'dc=' + ~~dom_time + '&'\n  url += 'fe=' + ~~fe_time + '&'\n  url += 'c=' + cycle\n\n  submitData.img(url)\n}\n\nfunction setErrorHandler (t, handler) {\n  loader.onerror = handler\n}\n\nvar releaseCount = 0\nfunction addRelease (t, name, id) {\n  if (++releaseCount > 10) return\n  loader.releaseIds[name.slice(-200)] = ('' + id).slice(-200)\n}\n\n},{}],4:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar stringify = require(22)\n\nvar hasOwnProp = Object.prototype.hasOwnProperty\nvar MAX_ATTRIBUTES = 64\n\nmodule.exports = {\n  nullable: nullable,\n  numeric: numeric,\n  getAddStringContext: getAddStringContext,\n  addCustomAttributes: addCustomAttributes\n}\n\nfunction nullable (val, fn, comma) {\n  return val || val === 0 || val === ''\n    ? fn(val) + (comma ? ',' : '')\n    : '!'\n}\n\nfunction numeric (n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36)\n  }\n  return (n === undefined || n === 0) ? '' : Math.floor(n).toString(36)\n}\n\nfunction getAddStringContext () {\n  var stringTable = Object.hasOwnProperty('create') ? Object.create(null) : {}\n  var stringTableIdx = 0\n\n  return addString\n\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return ''\n    str = String(str)\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true)\n    } else {\n      stringTable[str] = stringTableIdx++\n      return quoteString(str)\n    }\n  }\n}\n\nfunction addCustomAttributes (attrs, addString) {\n  var attrParts = []\n\n  mapOwn(attrs, function (key, val) {\n    if (attrParts.length >= MAX_ATTRIBUTES) return\n    var type = 5\n    var serializedValue\n    // add key to string table first\n    key = addString(key)\n\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val))\n        } else {\n          // null attribute type\n          type = 9\n        }\n        break\n      case 'number':\n        type = 6\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.'\n        break\n      case 'boolean':\n        type = val ? 7 : 8\n        break\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9\n        break\n      default:\n        serializedValue = addString(val)\n    }\n\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')])\n  })\n\n  return attrParts\n}\n\nvar escapable = /([,\\\\;])/g\n\nfunction quoteString (str) {\n  return \"'\" + str.replace(escapable, '\\\\$1')\n}\n\n},{}],5:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar withHash = /([^?#]*)[^#]*(#[^?]*|$).*/\nvar withoutHash = /([^?#]*)().*/\nmodule.exports = function cleanURL (url, keepHash) {\n  return url.replace(keepHash ? withHash : withoutHash, '$1$2')\n}\n\n},{}],6:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar baseEE = require(\"ee\")\nvar mapOwn = require(44)\nvar handlers = require(17).handlers\n\nmodule.exports = function drain (group) {\n  var bufferedEventsInGroup = baseEE.backlog[group]\n  var groupHandlers = handlers[group]\n  if (groupHandlers) {\n    // don't cache length, buffer can grow while processing\n    for (var i = 0; bufferedEventsInGroup && i < bufferedEventsInGroup.length; ++i) { // eslint-disable-line no-unmodified-loop-condition\n      emitEvent(bufferedEventsInGroup[i], groupHandlers)\n    }\n\n    mapOwn(groupHandlers, function (eventType, handlerRegistrationList) {\n      mapOwn(handlerRegistrationList, function (i, registration) {\n        // registration is an array of: [targetEE, eventHandler]\n        registration[0].on(eventType, registration[1])\n      })\n    })\n  }\n\n  delete handlers[group]\n  // Keep the group as a property so we know it was created and drained\n  baseEE.backlog[group] = null\n}\n\nfunction emitEvent (evt, groupHandlers) {\n  var type = evt[1]\n  mapOwn(groupHandlers[type], function (i, registration) {\n    var sourceEE = evt[0]\n    var ee = registration[0]\n    if (ee === sourceEE) {\n      var handler = registration[1]\n      var ctx = evt[3]\n      var args = evt[2]\n      handler.apply(ctx, args)\n    }\n  })\n}\n\n},{}],7:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar stringify = require(22)\n\n  // Characters that are safe in a qs, but get encoded.\nvar charMap = {\n  '%2C': ',',\n  '%3A': ':',\n  '%2F': '/',\n  '%40': '@',\n  '%24': '$',\n  '%3B': ';'\n}\n\nvar charList = mapOwn(charMap, function (k) { return k })\nvar safeEncoded = new RegExp(charList.join('|'), 'g')\n\nfunction real (c) {\n  return charMap[c]\n}\n\n// Encode as URI Component, then unescape anything that is ok in the\n// query string position.\nfunction qs (value) {\n  if (value === null || value === undefined) return 'null'\n  return encodeURIComponent(value).replace(safeEncoded, real)\n}\n\nmodule.exports = {obj: obj, fromArray: fromArray, qs: qs, param: param}\n\nfunction fromArray (qs, maxBytes) {\n  var bytes = 0\n  for (var i = 0; i < qs.length; i++) {\n    bytes += qs[i].length\n    if (bytes > maxBytes) return qs.slice(0, i).join('')\n  }\n  return qs.join('')\n}\n\nfunction obj (payload, maxBytes) {\n  var total = 0\n  var result = ''\n\n  mapOwn(payload, function (feature, dataArray) {\n    var intermediate = []\n    var next\n    var i\n\n    if (typeof dataArray === 'string') {\n      next = '&' + feature + '=' + qs(dataArray)\n      total += next.length\n      result += next\n    } else if (dataArray.length) {\n      total += 9\n      for (i = 0; i < dataArray.length; i++) {\n        next = qs(stringify(dataArray[i]))\n        total += next.length\n        if (typeof maxBytes !== 'undefined' && total >= maxBytes) break\n        intermediate.push(next)\n      }\n      result += '&' + feature + '=%5B' + intermediate.join(',') + '%5D'\n    }\n  })\n  return result\n}\n\n// Constructs an HTTP parameter to add to the BAM router URL\nfunction param (name, value) {\n  if (value && typeof (value) === 'string') {\n    return '&' + name + '=' + qs(value)\n  }\n  return ''\n}\n\n},{}],8:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar ee = require(\"ee\")\nvar drain = require(6)\n\nmodule.exports = function activateFeatures (flags) {\n  if (!(flags && typeof flags === 'object')) return\n  mapOwn(flags, function (flag, val) {\n    if (!val || activatedFeatures[flag]) return\n    ee.emit('feat-' + flag, [])\n    activatedFeatures[flag] = true\n  })\n\n  drain('feature')\n}\n\nvar activatedFeatures = module.exports.active = {}\n\n},{}],9:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar harvest = require(10)\nvar submitData = require(23)\n\nmodule.exports = HarvestScheduler\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nfunction HarvestScheduler(loader, endpoint, opts) {\n  this.loader = loader\n  this.endpoint = endpoint\n  this.opts = opts || {}\n  this.started = false\n  this.timeoutHandle = null\n}\n\nHarvestScheduler.prototype.startTimer = function startTimer(interval, initialDelay) {\n  this.interval = interval\n  this.started = true\n  this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval)\n}\n\nHarvestScheduler.prototype.stopTimer = function stopTimer() {\n  this.started = false\n  if (this.timeoutHandle) {\n    clearTimeout(this.timeoutHandle)\n  }\n}\n\nHarvestScheduler.prototype.scheduleHarvest = function scheduleHarvest(delay, opts) {\n  if (this.timeoutHandle) return\n  var timer = this\n\n  if (delay == null) {\n    delay = this.interval\n  }\n  this.timeoutHandle = setTimeout(function() {\n    timer.timeoutHandle = null\n    timer.runHarvest(opts)\n  }, delay * 1000)\n}\n\nHarvestScheduler.prototype.runHarvest = function runHarvest(opts) {\n  var scheduler = this\n\n  if (this.opts.getPayload) {\n    var submitMethod = harvest.getSubmitMethod(this.endpoint)\n    if (!submitMethod) return false\n\n    var retry = submitMethod.method === submitData.xhr\n    var payload = this.opts.getPayload({ retry: retry })\n    if (payload) {\n      harvest.send(this.endpoint, this.loader, payload, opts, submitMethod, onHarvestFinished)\n    }\n  } else {\n    harvest.sendX(this.endpoint, this.loader, opts, onHarvestFinished)\n  }\n\n  if (this.started) {\n    this.scheduleHarvest()\n  }\n\n  function onHarvestFinished(result) {\n    scheduler.onHarvestFinished(opts, result)\n  }\n}\n\nHarvestScheduler.prototype.onHarvestFinished = function onHarvestFinished(opts, result) {\n  if (this.opts.onFinished) {\n    this.opts.onFinished(result)\n  }\n\n  if (result.sent && result.retry) {\n    var delay = result.delay || this.opts.retryDelay\n    // reschedule next harvest if should be delayed longer\n    if (this.started && delay) {\n      clearTimeout(this.timeoutHandle)\n      this.timeoutHandle = null\n      this.scheduleHarvest(delay, opts)\n    } else if (!this.started && delay) {\n      // if not running on a timer, schedule a single retry\n      this.scheduleHarvest(delay, opts)\n    }\n  }\n}\n\n},{}],10:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar single = require(19)\nvar mapOwn = require(44)\nvar timing = require(15)\nvar encode = require(7)\nvar stringify = require(22)\nvar submitData = require(23)\nvar reduce = require(47)\nvar aggregator = require(2)\nvar stopwatch = require(21)\nvar locationUtil = require(13)\nvar config = require(39)\n\nvar cleanURL = require(5)\n\nvar version = 'DEVELOPMENT'\nvar jsonp = 'NREUM.setToken'\nvar _events = {}\nvar haveSendBeacon = !!navigator.sendBeacon\nvar tooManyRequestsDelay = config.getConfiguration('harvest.tooManyRequestsDelay') || 60\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\n// requiring ie version updates the IE version on the loader object\nvar ieVersion = require(11)\nvar xhrUsable = ieVersion > 9 || ieVersion === 0\n\nvar addPaintMetric = require(16).addMetric\n\nmodule.exports = {\n  sendRUM: single(sendRUM), // wrapping this in single makes it so that it can only be called once from outside\n  sendFinal: sendAllFromUnload,\n  pingErrors: pingErrors,\n  sendX: sendX,\n  send: send,\n  on: on,\n  xhrUsable: xhrUsable,\n  resetListeners: resetListeners,\n  getSubmitMethod: getSubmitMethod\n}\n\n// nr is injected into all send methods. This allows for easier testing\n// we could require('loader') instead\nfunction sendRUM (nr) {\n  if (!nr.info.beacon) return\n  if (nr.info.queueTime) aggregator.store('measures', 'qt', { value: nr.info.queueTime })\n  if (nr.info.applicationTime) aggregator.store('measures', 'ap', { value: nr.info.applicationTime })\n\n  // some time in the past some code will have called stopwatch.mark('starttime', Date.now())\n  // calling measure like this will create a metric that measures the time differential between\n  // the two marks.\n  stopwatch.measure('be', 'starttime', 'firstbyte')\n  stopwatch.measure('fe', 'firstbyte', 'onload')\n  stopwatch.measure('dc', 'firstbyte', 'domContent')\n\n  var measuresMetrics = aggregator.get('measures')\n\n  var measuresQueryString = mapOwn(measuresMetrics, function (metricName, measure) {\n    return '&' + metricName + '=' + measure.params.value\n  }).join('')\n\n  if (measuresQueryString) {\n    // currently we only have one version of our protocol\n    // in the future we may add more\n    var protocol = '1'\n\n    var chunksForQueryString = [baseQueryString(nr)]\n\n    chunksForQueryString.push(measuresQueryString)\n\n    chunksForQueryString.push(encode.param('tt', nr.info.ttGuid))\n    chunksForQueryString.push(encode.param('us', nr.info.user))\n    chunksForQueryString.push(encode.param('ac', nr.info.account))\n    chunksForQueryString.push(encode.param('pr', nr.info.product))\n    chunksForQueryString.push(encode.param('af', mapOwn(nr.features, function (k) { return k }).join(',')))\n\n    if (window.performance && typeof (window.performance.timing) !== 'undefined') {\n      var navTimingApiData = ({\n        timing: timing.addPT(window.performance.timing, {}),\n        navigation: timing.addPN(window.performance.navigation, {})\n      })\n      chunksForQueryString.push(encode.param('perf', stringify(navTimingApiData)))\n    }\n\n    if (window.performance && window.performance.getEntriesByType) {\n      var entries = window.performance.getEntriesByType('paint')\n      if (entries && entries.length > 0) {\n        entries.forEach(function(entry) {\n          if (!entry.startTime || entry.startTime <= 0) return\n\n          if (entry.name === 'first-paint') {\n            chunksForQueryString.push(encode.param('fp',\n              String(Math.floor(entry.startTime))))\n          } else if (entry.name === 'first-contentful-paint') {\n            chunksForQueryString.push(encode.param('fcp',\n              String(Math.floor(entry.startTime))))\n          }\n          addPaintMetric(entry.name, Math.floor(entry.startTime))\n        })\n      }\n    }\n\n    chunksForQueryString.push(encode.param('xx', nr.info.extra))\n    chunksForQueryString.push(encode.param('ua', nr.info.userAttributes))\n    chunksForQueryString.push(encode.param('at', nr.info.atts))\n\n    var customJsAttributes = stringify(nr.info.jsAttributes)\n    chunksForQueryString.push(encode.param('ja', customJsAttributes === '{}' ? null : customJsAttributes))\n\n    var queryString = encode.fromArray(chunksForQueryString, nr.maxBytes)\n\n    submitData.jsonp(\n      scheme + '://' + nr.info.beacon + '/' + protocol + '/' + nr.info.licenseKey + queryString,\n      jsonp\n    )\n  }\n}\n\nfunction sendAllFromUnload (nr) {\n  var sents = mapOwn(_events, function (endpoint) {\n    return sendX(endpoint, nr, { unload: true })\n  })\n  return reduce(sents, or)\n}\n\nfunction or (a, b) { return a || b }\n\nfunction createPayload (type, options) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  var listeners = (_events[type] && _events[type] || [])\n\n  for (var i = 0; i < listeners.length; i++) {\n    var singlePayload = listeners[i](options)\n    if (!singlePayload) continue\n    if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n    if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n  }\n  return { body: makeBody(), qs: makeQueryString() }\n}\n\n/**\n * Initiate a harvest from multiple sources. An event that corresponds to the endpoint\n * name is emitted, which gives any listeners the opportunity to provide payload data.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction sendX (endpoint, nr, opts, cbFinished) {\n  var submitMethod = getSubmitMethod(endpoint, opts)\n  if (!submitMethod) return false\n  var options = {\n    retry: submitMethod.method === submitData.xhr\n  }\n  return _send(endpoint, nr, createPayload(endpoint, options), opts, submitMethod, cbFinished)\n}\n\n/**\n * Initiate a harvest call.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} singlePayload - Object representing payload.\n * @param {object} singlePayload.qs - Map of values that should be sent as part of the request query string.\n * @param {string} singlePayload.body - String that should be sent as the body of the request.\n * @param {string} singlePayload.body.e - Special case of body used for browser interactions.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction send (endpoint, nr, singlePayload, opts, submitMethod, cbFinished) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n  if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n\n  var payload = { body: makeBody(), qs: makeQueryString() }\n  return _send(endpoint, nr, payload, opts, submitMethod, cbFinished)\n}\n\nfunction _send (endpoint, nr, payload, opts, submitMethod, cbFinished) {\n  if (!nr.info.errorBeacon) return false\n\n  // custom metrics data (cm) is sent as a query parameter to /jserrors\n  if (!payload.body && !(endpoint === 'jserrors' && payload.qs && payload.qs.cm)) {\n    if (cbFinished) {\n      cbFinished({ sent: false })\n    }\n    return false\n  }\n\n  if (!opts) opts = {}\n\n  var url = scheme + '://' + nr.info.errorBeacon + '/' + endpoint + '/1/' + nr.info.licenseKey + baseQueryString(nr)\n  if (payload.qs) url += encode.obj(payload.qs, nr.maxBytes)\n\n  if (!submitMethod) {\n    submitMethod = getSubmitMethod(endpoint, opts)\n  }\n  var method = submitMethod.method\n  var useBody = submitMethod.useBody\n\n  var body\n  var fullUrl = url\n  if (useBody && endpoint === 'events') {\n    body = payload.body.e\n  } else if (useBody) {\n    body = stringify(payload.body)\n  } else {\n    fullUrl = url + encode.obj(payload.body, nr.maxBytes)\n  }\n\n  var result = method(fullUrl, body)\n\n  if (cbFinished && method === submitData.xhr) {\n    var xhr = result\n    xhr.addEventListener('load', function () {\n      var result = { sent: true }\n      if (this.status === 429) {\n        result.retry = true\n        result.delay = tooManyRequestsDelay\n      } else if (this.status === 408 || this.status === 500 || this.status === 503) {\n        result.retry = true\n      }\n\n      if (opts.needResponse) {\n        result.responseText = this.responseText\n      }\n      cbFinished(result)\n    }, false)\n  }\n\n  // if beacon request failed, retry with an alternative method\n  if (!result && method === submitData.beacon) {\n    method = submitData.img\n    result = method(url + encode.obj(payload.body, nr.maxBytes))\n  }\n\n  return result\n}\n\nfunction getSubmitMethod(endpoint, opts) {\n  opts = opts || {}\n  var method\n  var useBody\n\n  if (opts.needResponse) {\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else {\n      return false\n    }\n  } else if (opts.unload) {\n    useBody = haveSendBeacon\n    method = haveSendBeacon ? submitData.beacon : submitData.img\n  } else {\n    // `submitData.beacon` was removed, there is an upper limit to the\n    // number of data allowed before it starts failing, so we save it for\n    // unload data\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else if (endpoint === 'events' || endpoint === 'jserrors') {\n      method = submitData.img\n    } else {\n      return false\n    }\n  }\n\n  return {\n    method: method,\n    useBody: useBody\n  }\n}\n\nfunction pingErrors (nr) {\n  if (scheme === 'http' || !(nr && nr.info && nr.info.errorBeacon && nr.ieVersion)) return\n\n  var url = 'https://' + nr.info.errorBeacon + '/jserrors/ping/' + nr.info.licenseKey + baseQueryString(nr)\n\n  submitData.img(url)\n}\n\n// Constructs the transaction name param for the beacon URL.\n// Prefers the obfuscated transaction name over the plain text.\n// Falls back to making up a name.\nfunction transactionNameParam (nr) {\n  if (nr.info.transactionName) return encode.param('to', nr.info.transactionName)\n  return encode.param('t', nr.info.tNamePlain || 'Unnamed Transaction')\n}\n\nfunction on (type, listener) {\n  var listeners = (_events[type] || (_events[type] = []))\n  listeners.push(listener)\n}\n\nfunction resetListeners() {\n  mapOwn(_events, function(key) {\n    _events[key] = []\n  })\n}\n\n// The stuff that gets sent every time.\nfunction baseQueryString (nr) {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  return ([\n    '?a=' + nr.info.applicationID,\n    encode.param('sa', (nr.info.sa ? '' + nr.info.sa : '')),\n    encode.param('v', version),\n    transactionNameParam(nr),\n    encode.param('ct', nr.customTransaction),\n    '&rst=' + nr.now(),\n    '&ck=' + (areCookiesEnabled ? '1' : '0'),\n    encode.param('ref', cleanURL(locationUtil.getLocation()))\n  ].join(''))\n}\n\n// returns a function that can be called to accumulate values to a single object\n// when the function is called without parameters, then the accumulator is returned\nfunction createAccumulator () {\n  var accumulator = {}\n  var hasData = false\n  return function (key, val) {\n    if (val && val.length) {\n      accumulator[key] = val\n      hasData = true\n    }\n    if (hasData) return accumulator\n  }\n}\n\n},{}],11:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar div = document.createElement('div')\n\ndiv.innerHTML = '<!--[if lte IE 6]><div></div><![endif]-->' +\n  '<!--[if lte IE 7]><div></div><![endif]-->' +\n  '<!--[if lte IE 8]><div></div><![endif]-->' +\n  '<!--[if lte IE 9]><div></div><![endif]-->'\n\nvar len = div.getElementsByTagName('div').length\n\nvar ieVersion\nif (len === 4) ieVersion = 6\nelse if (len === 3) ieVersion = 7\nelse if (len === 2) ieVersion = 8\nelse if (len === 1) ieVersion = 9\nelse ieVersion = 0\n\nmodule.exports = ieVersion\n\n},{}],12:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stopwatch = require(21)\nvar subscribeToUnload = require(25)\nvar harvest = require(10)\nvar registerHandler = require(17)\nvar activateFeatures = require(8)\nvar loader = require(\"loader\")\nvar drain = require(6)\nvar navCookie = require(14)\nvar config = require(39)\n\n// api loads registers several event listeners, but does not have any exports\nrequire(3)\n\n// Register event listeners and schedule harvests for performance timings.\nrequire(24).init(loader, config.getConfiguration('page_view_timing'))\n\nvar autorun = typeof (window.NREUM.autorun) !== 'undefined' ? window.NREUM.autorun : true\n\n// Features are activated using the legacy setToken function name via JSONP\nwindow.NREUM.setToken = activateFeatures\n\nif (require(11) === 6) loader.maxBytes = 2000\nelse loader.maxBytes = 30000\n\nloader.releaseIds = {}\n\nsubscribeToUnload(finalHarvest)\n\nregisterHandler('mark', stopwatch.mark, 'api')\n\nstopwatch.mark('done')\n\ndrain('api')\n\nif (autorun) harvest.sendRUM(loader)\n\n// Set a cookie when the page unloads. Consume this cookie on the next page to get a 'start time'.\n// The navigation start time cookie is removed when the browser supports the web timing API.\n// Doesn't work in some browsers (Opera).\nfunction finalHarvest (e) {\n  harvest.sendFinal(loader, false)\n  // write navigation start time cookie if needed\n  navCookie.conditionallySet()\n}\n\n},{}],13:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getLocation: getLocation\n}\n\nfunction getLocation() {\n  return '' + location\n}\n\n},{}],14:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar sHash = require(18)\nvar startTime = require(20)\n\n// functions are on object, so that they can be mocked\nvar exp = {\n  conditionallySet: conditionallySet,\n  setCookie: setCookie\n}\n\nmodule.exports = exp\n\nfunction conditionallySet() {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  if (startTime.navCookie && areCookiesEnabled) {\n    exp.setCookie()\n  }\n}\n\nfunction setCookie() {\n  document.cookie = 'NREUM=s=' + Number(new Date()) + '&r=' + sHash(document.location.href) + '&p=' + sHash(document.referrer) + '; path=/'\n}\n\n},{}],15:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\n\nvar START = 'Start'\nvar END = 'End'\nvar UNLOAD_EVENT = 'unloadEvent'\nvar REDIRECT = 'redirect'\nvar DOMAIN_LOOKUP = 'domainLookup'\nvar ONNECT = 'onnect'\nvar REQUEST = 'request'\nvar RESPONSE = 'response'\nvar LOAD_EVENT = 'loadEvent'\nvar DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent'\n\nvar navTimingValues = []\nmodule.exports = {\n  addPT: addPT,\n  addPN: addPN,\n  nt: navTimingValues\n}\n\nfunction addPT (pt, v) {\n  var offset = pt['navigation' + START]\n  v.of = offset\n  addRel(offset, offset, v, 'n')\n  addRel(pt[UNLOAD_EVENT + START], offset, v, 'u')\n  addRel(pt[REDIRECT + START], offset, v, 'r')\n  addRel(pt[UNLOAD_EVENT + END], offset, v, 'ue')\n  addRel(pt[REDIRECT + END], offset, v, 're')\n  addRel(pt['fetch' + START], offset, v, 'f')\n  addRel(pt[DOMAIN_LOOKUP + START], offset, v, 'dn')\n  addRel(pt[DOMAIN_LOOKUP + END], offset, v, 'dne')\n  addRel(pt['c' + ONNECT + START], offset, v, 'c')\n  addRel(pt['secureC' + ONNECT + 'ion' + START], offset, v, 's')\n  addRel(pt['c' + ONNECT + END], offset, v, 'ce')\n  addRel(pt[REQUEST + START], offset, v, 'rq')\n  addRel(pt[RESPONSE + START], offset, v, 'rp')\n  addRel(pt[RESPONSE + END], offset, v, 'rpe')\n  addRel(pt.domLoading, offset, v, 'dl')\n  addRel(pt.domInteractive, offset, v, 'di')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + START], offset, v, 'ds')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + END], offset, v, 'de')\n  addRel(pt.domComplete, offset, v, 'dc')\n  addRel(pt[LOAD_EVENT + START], offset, v, 'l')\n  addRel(pt[LOAD_EVENT + END], offset, v, 'le')\n  return v\n}\n\n// Add Performance Navigation values to the given object\nfunction addPN (pn, v) {\n  addRel(pn.type, 0, v, 'ty')\n  addRel(pn.redirectCount, 0, v, 'rc')\n  return v\n}\n\nfunction addRel (value, offset, obj, prop) {\n  var relativeValue\n  if (typeof (value) === 'number' && (value > 0)) {\n    relativeValue = Math.round(value - offset)\n    obj[prop] = relativeValue\n  }\n  navTimingValues.push(relativeValue)\n}\n\n},{}],16:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar paintMetrics = {}\n\nmodule.exports = {\n  addMetric: addMetric,\n  metrics: paintMetrics\n}\n\nfunction addMetric (name, value) {\n  paintMetrics[name] = value\n}\n\n},{}],17:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handleEE = require(\"handle\").ee\n\nmodule.exports = defaultRegister\n\ndefaultRegister.on = registerWithSpecificEmitter\n\nvar handlers = defaultRegister.handlers = {}\n\nfunction defaultRegister (type, handler, group, ee) {\n  registerWithSpecificEmitter(ee || handleEE, type, handler, group)\n}\n\nfunction registerWithSpecificEmitter (ee, type, handler, group) {\n  if (!group) group = 'feature'\n  if (!ee) ee = handleEE\n  var groupHandlers = handlers[group] = handlers[group] || {}\n  var list = groupHandlers[type] = groupHandlers[type] || []\n  list.push([ee, handler])\n}\n\n},{}],18:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = sHash\n\nfunction sHash (s) {\n  var i\n  var h = 0\n\n  for (i = 0; i < s.length; i++) {\n    h += ((i + 1) * s.charCodeAt(i))\n  }\n  return Math.abs(h)\n}\n\n},{}],19:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar slice = require(45)\n\nmodule.exports = single\n\nfunction single (fn) {\n  var called = false\n  var res\n\n  return function () {\n    if (called) return res\n    called = true\n    res = fn.apply(this, slice(arguments))\n    return res\n  }\n}\n\n},{}],20:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Use various techniques to determine the time at which this page started and whether to capture navigation timing information\n\nvar sHash = require(18)\nvar stopwatch = require(21)\nvar loader = require(\"loader\")\nvar ffVersion = require(41)\n\nmodule.exports = { navCookie: true }\n\nfindStartTime()\n\nfunction findStartTime () {\n  var starttime = findStartWebTiming() || findStartCookie()\n\n  if (!starttime) return\n\n  stopwatch.mark('starttime', starttime)\n  // Refine loader.offset\n  loader.offset = starttime\n}\n\n// Find the start time from the Web Timing 'performance' object.\n// http://test.w3.org/webperf/specs/NavigationTiming/\n// http://blog.chromium.org/2010/07/do-you-know-how-slow-your-web-page-is.html\nfunction findStartWebTiming () {\n  // FF 7/8 has a bug with the navigation start time, so use cookie instead of native interface\n  if (ffVersion && ffVersion < 9) return\n\n  var performanceCheck = require(46)\n  if (performanceCheck.exists) {\n    // note that we don't need to use a cookie to record navigation start time\n    module.exports.navCookie = false\n    return window.performance.timing.navigationStart\n  }\n}\n\n// Find the start time based on a cookie set by Episodes in the unload handler.\nfunction findStartCookie () {\n  var aCookies = document.cookie.split(' ')\n\n  for (var i = 0; i < aCookies.length; i++) {\n    if (aCookies[i].indexOf('NREUM=') === 0) {\n      var startPage\n      var referrerPage\n      var aSubCookies = aCookies[i].substring('NREUM='.length).split('&')\n      var startTime\n      var bReferrerMatch\n\n      for (var j = 0; j < aSubCookies.length; j++) {\n        if (aSubCookies[j].indexOf('s=') === 0) {\n          startTime = aSubCookies[j].substring(2)\n        } else if (aSubCookies[j].indexOf('p=') === 0) {\n          referrerPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (referrerPage.charAt(referrerPage.length - 1) === ';') {\n            referrerPage = referrerPage.substr(0, referrerPage.length - 1)\n          }\n        } else if (aSubCookies[j].indexOf('r=') === 0) {\n          startPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (startPage.charAt(startPage.length - 1) === ';') {\n            startPage = startPage.substr(0, startPage.length - 1)\n          }\n        }\n      }\n\n      if (startPage) {\n        var docReferrer = sHash(document.referrer)\n        bReferrerMatch = (docReferrer == startPage) // eslint-disable-line\n        if (!bReferrerMatch) {\n          // Navigation did not start at the page that was just exited, check for re-load\n          // (i.e. the page just exited is the current page and the referring pages match)\n          bReferrerMatch = sHash(document.location.href) == startPage && docReferrer == referrerPage // eslint-disable-line\n        }\n      }\n      if (bReferrerMatch && startTime) {\n        var now = new Date().getTime()\n        if ((now - startTime) > 60000) {\n          return\n        }\n        return startTime\n      }\n    }\n  }\n}\n\n},{}],21:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar aggregator = require(2)\nvar now = require(42)\n\nvar marks = {}\n\nmodule.exports = {\n  mark: mark,\n  measure: measure\n}\n\nfunction mark (markName, markTime) {\n  if (typeof markTime === 'undefined') markTime = (now() + now.offset)\n  marks[markName] = markTime\n}\n\nfunction measure (metricName, startMark, endMark) {\n  var start = marks[startMark]\n  var end = marks[endMark]\n\n  if (typeof start === 'undefined' || typeof end === 'undefined') return\n\n  aggregator.store('measures', metricName, { value: end - start })\n}\n\n},{}],22:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar ee = require(\"ee\")\n\nvar escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g // eslint-disable-line\nvar meta = {\n  '\\b': '\\\\b',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\f': '\\\\f',\n  '\\r': '\\\\r',\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\'\n}\n\nmodule.exports = stringify\n\nfunction stringify (val) {\n  try {\n    return str('', {'': val})\n  } catch (e) {\n    try {\n      ee.emit('internal-error', [e])\n    } catch (err) {\n    }\n  }\n}\n\nfunction quote (string) {\n  escapable.lastIndex = 0\n  return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n    var c = meta[a]\n    return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4)\n  }) + '\"' : '\"' + string + '\"'\n}\n\nfunction str (key, holder) {\n  var value = holder[key]\n\n  switch (typeof value) {\n    case 'string':\n      return quote(value)\n    case 'number':\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return String(value)\n    case 'object':\n      if (!value) { return 'null' }\n      var partial = []\n\n      // The value is an array. Stringify every element. Use null as a placeholder\n      // for non-JSON values.\n      if (value instanceof window.Array || Object.prototype.toString.apply(value) === '[object Array]') {\n        var length = value.length\n        for (var i = 0; i < length; i += 1) {\n          partial[i] = str(i, value) || 'null'\n        }\n\n        return partial.length === 0 ? '[]' : '[' + partial.join(',') + ']'\n      }\n\n      mapOwn(value, function (k) {\n        var v = str(k, value)\n        if (v) partial.push(quote(k) + ':' + v)\n      })\n\n      return partial.length === 0 ? '{}' : '{' + partial.join(',') + '}'\n  }\n}\n\n},{}],23:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar submitData = module.exports = {}\n\nsubmitData.jsonp = function jsonp (url, jsonp) {\n  var element = document.createElement('script')\n  element.type = 'text/javascript'\n  element.src = url + '&jsonp=' + jsonp\n  var firstScript = document.getElementsByTagName('script')[0]\n  firstScript.parentNode.insertBefore(element, firstScript)\n  return element\n}\n\nsubmitData.xhr = function xhr (url, body, sync) {\n  var request = new XMLHttpRequest()\n\n  request.open('POST', url, !sync)\n  try {\n    // Set cookie\n    if ('withCredentials' in request) request.withCredentials = true\n  } catch (e) {}\n\n  request.setRequestHeader('content-type', 'text/plain')\n  request.send(body)\n  return request\n}\n\nsubmitData.xhrSync = function xhrSync (url, body) {\n  return submitData.xhr(url, body, true)\n}\n\nsubmitData.img = function img (url) {\n  var element = new Image()\n  element.src = url\n  return element\n}\n\nsubmitData.beacon = function (url, body) {\n  return navigator.sendBeacon(url, body)\n}\n\n},{}],24:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar nullable = require(4).nullable\nvar numeric = require(4).numeric\nvar getAddStringContext = require(4).getAddStringContext\nvar addCustomAttributes = require(4).addCustomAttributes\nvar now = require(42)\nvar mapOwn = require(44)\n\nvar loader = null\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar register = require(17)\nvar subscribeToUnload = require(25)\n\nvar timings = []\nvar timingsSent = []\nvar lcpRecorded = false\nvar lcp = null\nvar cls = null\nvar pageHideRecorded = false\n\nmodule.exports = {\n  getPayload: getPayload,\n  timings: timings,\n  init: init,\n  finalHarvest: finalHarvest\n}\n\nvar harvestTimeSeconds = 30\n\nfunction init(nr, options) {\n  if (!isEnabled(options)) return\n\n  loader = nr\n\n  if (!options) options = {}\n  var maxLCPTimeSeconds = options.maxLCPTimeSeconds || 60\n  var initialHarvestSeconds = options.initialHarvestSeconds || 10\n  harvestTimeSeconds = options.harvestTimeSeconds || 30\n\n  var scheduler = new HarvestScheduler(loader, 'events', { onFinished: onHarvestFinished, getPayload: prepareHarvest })\n\n  register('timing', processTiming)\n  register('lcp', updateLatestLcp)\n  register('cls', updateClsScore)\n  register('pageHide', updatePageHide)\n\n  // final harvest is initiated from the main agent module, but since harvesting\n  // here is not initiated by the harvester, we need to subscribe to the unload event\n  // separately\n  subscribeToUnload(finalHarvest)\n\n  // After 1 minute has passed, record LCP value if no user interaction has occurred first\n  setTimeout(function() {\n    recordLcp()\n    lcpRecorded = true\n  }, maxLCPTimeSeconds * 1000)\n\n  // send initial data sooner, then start regular\n  scheduler.startTimer(harvestTimeSeconds, initialHarvestSeconds)\n}\n\nfunction recordLcp() {\n  if (!lcpRecorded && lcp !== null) {\n    var lcpEntry = lcp[0]\n    var cls = lcp[1]\n\n    var attrs = {\n      'size': lcpEntry.size,\n      'eid': lcpEntry.id\n    }\n\n    if (cls) {\n      attrs['cls'] = cls\n    }\n\n    addTiming('lcp', Math.floor(lcpEntry.startTime), attrs, false)\n    lcpRecorded = true\n  }\n}\n\nfunction updateLatestLcp(lcpEntry) {\n  if (lcp) {\n    var previous = lcp[0]\n    if (previous.size >= lcpEntry.size) {\n      return\n    }\n  }\n  lcp = [lcpEntry, cls]\n}\n\nfunction updateClsScore(clsEntry) {\n  if (cls === null) {\n    cls = 0\n  }\n  cls += clsEntry.value\n}\n\nfunction updatePageHide(timestamp, state) {\n  if (!pageHideRecorded && state === 'hidden') {\n    addTiming('pageHide', timestamp, null, true)\n    pageHideRecorded = true\n  }\n}\n\nfunction recordUnload() {\n  addTiming('unload', now(), null, true)\n}\n\nfunction addTiming(name, value, attrs, addCls) {\n  attrs = attrs || {}\n\n  if (addCls && cls !== null) {\n    attrs['cls'] = cls\n  }\n\n  timings.push({\n    name: name,\n    value: value,\n    attrs: attrs\n  })\n}\n\nfunction processTiming(name, value, attrs) {\n  // Upon user interaction, the Browser stops executing LCP logic, so we can send here\n  // We're using setTimeout to give the Browser time to finish collecting LCP value\n  if (name === 'fi') {\n    setTimeout(recordLcp, 0)\n  }\n\n  addTiming(name, value, attrs, true)\n}\n\nfunction onHarvestFinished(result) {\n  if (result.retry && timingsSent.length > 0) {\n    for (var i = 0; i < timingsSent.length; i++) {\n      timings.push(timingsSent[i])\n    }\n    timingsSent = []\n  }\n}\n\nfunction finalHarvest() {\n  recordLcp()\n  recordUnload()\n  var payload = prepareHarvest({ retry: false })\n  harvest.send('events', loader, payload, { unload: true })\n}\n\nfunction appendGlobalCustomAttributes(timing) {\n  var timingAttributes = timing.attrs || {}\n  var customAttributes = loader.info.jsAttributes || {}\n\n  mapOwn(customAttributes, function (key, val) {\n    if (key !== 'size' && key !== 'eid' && key !== 'cls' && key !== 'type' && key !== 'fid') {\n      timingAttributes[key] = val\n    }\n  })\n}\n\n// serialize and return current timing data, clear and save current data for retry\nfunction prepareHarvest(options) {\n  if (timings.length === 0) return\n\n  var payload = getPayload(timings)\n  if (options.retry) {\n    for (var i = 0; i < timings.length; i++) {\n      timingsSent.push(timings[i])\n    }\n  }\n  timings = []\n  return { body: { e: payload } }\n}\n\n// serialize array of timing data\nfunction getPayload(data) {\n  var addString = getAddStringContext()\n\n  var payload = 'bel.6;'\n\n  for (var i = 0; i < data.length; i++) {\n    var timing = data[i]\n\n    payload += 'e,'\n    payload += addString(timing.name) + ','\n    payload += nullable(timing.value, numeric, false) + ','\n\n    appendGlobalCustomAttributes(timing)\n\n    var attrParts = addCustomAttributes(timing.attrs, addString)\n    if (attrParts && attrParts.length > 0) {\n      payload += numeric(attrParts.length) + ';' + attrParts.join(';')\n    }\n\n    if ((i + 1) < data.length) payload += ';'\n  }\n\n  return payload\n}\n\nfunction isEnabled(config) {\n  // collect page view timings unless the feature is explicitly disabled\n  if (config && config.enabled === false) {\n    return false\n  }\n  return true\n}\n\n},{}],25:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = require(41)\nvar single = require(19)\nvar addE = require(1)\n\nmodule.exports = subscribeToUnload\n\n// Used to subscribe a callback to when a page is being unloaded. This is used,\n// for example, to submit a final harvest.\nfunction subscribeToUnload (cb) {\n  var oneCall = single(cb)\n\n  // Firefox has a bug wherein a slow-loading resource loaded from the 'pagehide'\n  // or 'unload' event will delay the 'load' event firing on the next page load.\n  // In Firefox versions that support sendBeacon, this doesn't matter, because\n  // we'll use it instead of an image load for our final harvest.\n  //\n  // Some Safari versions never fire the 'unload' event for pages that are being\n  // put into the WebKit page cache, so we *need* to use the pagehide event for\n  // the final submission from Safari.\n  //\n  // Generally speaking, we will try to submit our final harvest from either\n  // pagehide or unload, whichever comes first, but in Firefox, we need to avoid\n  // attempting to submit from pagehide to ensure that we don't slow down loading\n  // of the next page.\n  if (!ffVersion || navigator.sendBeacon) {\n    addE('pagehide', oneCall)\n  } else {\n    addE('beforeunload', oneCall)\n  }\n  addE('unload', oneCall)\n}\n\n},{}],26:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar canonicalFunctionNameRe = /([a-z0-9]+)$/i\nfunction canonicalFunctionName (orig) {\n  if (!orig) return\n\n  var match = orig.match(canonicalFunctionNameRe)\n  if (match) return match[1]\n\n  return\n}\n\nmodule.exports = canonicalFunctionName\n\n},{}],27:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// computeStackTrace: cross-browser stack traces in JavaScript\n//\n// Syntax:\n//   s = computeStackTrace(exception) // consider using TraceKit.report instead\n// Returns:\n//   s.name              - exception name\n//   s.message           - exception message\n//   s.stack[i].url      - JavaScript or HTML file URL\n//   s.stack[i].func     - function name, or empty for anonymous functions\n//   s.stack[i].line     - line number, if known\n//   s.stack[i].column   - column number, if known\n//   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n//   s.mode              - 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace\n//\n// Supports:\n//   - Firefox:  full stack trace with line numbers and unreliable column\n//               number on top frame\n//   - Opera 10: full stack trace with line and column numbers\n//   - Opera 9-: full stack trace with line numbers\n//   - Chrome:   full stack trace with line and column numbers\n//   - Safari:   line and column number for the topmost stacktrace element\n//               only\n//   - IE:       no line numbers whatsoever\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n//\n// OPERA:\n// ex.message = ...message... (see the example below)\n// ex.name = ReferenceError\n// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\nvar reduce = require(47)\nvar formatStackTrace = require(28)\n\nvar has = Object.prototype.hasOwnProperty\nvar debug = false\n\nvar classNameRegex = /function (.+?)\\s*\\(/\nvar chrome = /^\\s*at (?:((?:\\[object object\\])?(?:[^(]*\\([^)]*\\))*[^()]*(?: \\[as \\S+\\])?) )?\\(?((?:file|http|https|chrome-extension):.*?)?:(\\d+)(?::(\\d+))?\\)?\\s*$/i\nvar gecko = /^\\s*(?:(\\S*|global code)(?:\\(.*?\\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\\d+)(?::(\\d+))?\\s*$/i\nvar chrome_eval = /^\\s*at .+ \\(eval at \\S+ \\((?:(?:file|http|https):[^)]+)?\\)(?:, [^:]*:\\d+:\\d+)?\\)$/i\nvar ie_eval = /^\\s*at Function code \\(Function code:\\d+:\\d+\\)\\s*/i\n\nmodule.exports = computeStackTrace\n\nfunction computeStackTrace (ex) {\n  var stack = null\n\n  try {\n    // This must be tried first because Opera 10 *destroys*\n    // its stacktrace property if you try to access the stack\n    // property first!!\n    stack = computeStackTraceFromStacktraceProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromStackProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromOperaMultiLineMessage(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceBySourceAndLine(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceWithMessageOnly(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  return {\n    'mode': 'failed',\n    'stackString': '',\n    'frames': []\n  }\n}\n\n/**\n * Computes stack trace information from the stack property.\n * Chrome and Gecko use this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStackProp (ex) {\n  if (!ex.stack) {\n    return null\n  }\n\n  var errorInfo = reduce(\n    ex.stack.split('\\n'),\n    parseStackProp,\n    {frames: [], stackLines: [], wrapperSeen: false}\n  )\n\n  if (!errorInfo.frames.length) return null\n\n  return {\n    'mode': 'stack',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(errorInfo.stackLines),\n    'frames': errorInfo.frames\n  }\n}\n\nfunction parseStackProp (info, line) {\n  var element = getElement(line)\n\n  if (!element) {\n    info.stackLines.push(line)\n    return info\n  }\n\n  if (isWrapper(element.func)) info.wrapperSeen = true\n  else info.stackLines.push(line)\n\n  if (!info.wrapperSeen) info.frames.push(element)\n  return info\n}\n\nfunction getElement (line) {\n  var parts = line.match(gecko)\n  if (!parts) parts = line.match(chrome)\n\n  if (parts) {\n    return ({\n      'url': parts[2],\n      'func': (parts[1] !== 'Anonymous function' && parts[1] !== 'global code' && parts[1]) || null,\n      'line': +parts[3],\n      'column': parts[4] ? +parts[4] : null\n    })\n  }\n\n  if (line.match(chrome_eval) || line.match(ie_eval) || line === 'anonymous') {\n    return { 'func': 'evaluated code' }\n  }\n}\n\nfunction computeStackTraceBySourceAndLine (ex) {\n  if (!('line' in ex)) return null\n\n  var className = ex.name || getClassName(ex)\n\n  // Safari does not provide a URL for errors in eval'd code\n  if (!ex.sourceURL) {\n    return ({\n      'mode': 'sourceline',\n      'name': className,\n      'message': ex.message,\n      'stackString': getClassName(ex) + ': ' + ex.message + '\\n    in evaluated code',\n      'frames': [{\n        'func': 'evaluated code'\n      }]\n    })\n  }\n\n  var stackString = className + ': ' + ex.message + '\\n    at ' + ex.sourceURL\n  if (ex.line) {\n    stackString += ':' + ex.line\n    if (ex.column) {\n      stackString += ':' + ex.column\n    }\n  }\n\n  return ({\n    'mode': 'sourceline',\n    'name': className,\n    'message': ex.message,\n    'stackString': stackString,\n    'frames': [{ 'url': ex.sourceURL,\n      'line': ex.line,\n      'column': ex.column\n    }]\n  })\n}\n\nfunction computeStackTraceWithMessageOnly (ex) {\n  var className = ex.name || getClassName(ex)\n  if (!className) return null\n\n  return ({\n    'mode': 'nameonly',\n    'name': className,\n    'message': ex.message,\n    'stackString': className + ': ' + ex.message,\n    'frames': []\n  })\n}\n\nfunction getClassName (obj) {\n  var results = classNameRegex.exec(String(obj.constructor))\n  return (results && results.length > 1) ? results[1] : 'unknown'\n}\n\nfunction isWrapper (functionName) {\n  return (functionName && functionName.indexOf('nrWrapper') >= 0)\n}\n\n/**\n * Computes stack trace information from the stacktrace property.\n * Opera 10 uses this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStacktraceProp (ex) {\n  if (!ex.stacktrace) {\n    return null\n  }\n\n  // Access and store the stacktrace property before doing anything\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = ex.stacktrace\n\n  var testRE = / line (\\d+), column (\\d+) in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\(.*\\) in (.*):\\s*$/i\n  var lines = stacktrace.split('\\n')\n  var frames = []\n  var stackLines = []\n  var parts\n  var wrapperSeen = false\n\n  for (var i = 0, j = lines.length; i < j; i += 2) {\n    if ((parts = testRE.exec(lines[i]))) {\n      var element = {\n        'line': +parts[1],\n        'column': +parts[2],\n        'func': parts[3] || parts[4],\n        'url': parts[5]\n      }\n\n      if (isWrapper(element.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(element)\n    } else {\n      stackLines.push(lines[i])\n    }\n  }\n\n  if (!frames.length) {\n    return null\n  }\n\n  return {\n    'mode': 'stacktrace',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n/**\n * Computes stack trace information from an error message that includes\n * the stack trace.\n * Opera 9 and earlier use this method if the option to show stack\n * traces is turned on in opera:config.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack information.\n */\nfunction computeStackTraceFromOperaMultiLineMessage (ex) {\n  // Opera includes a stack trace into the exception message. An example is:\n  //\n  // Statement on line 3: Undefined variable: undefinedFunc\n  // Backtrace:\n  //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz\n  //         undefinedFunc(a)\n  //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy\n  //           zzz(x, y, z)\n  //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx\n  //           yyy(a, a, a)\n  //   Line 1 of function script\n  //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }\n  //   ...\n\n  var lines = ex.message.split('\\n')\n  if (lines.length < 4) {\n    return null\n  }\n\n  var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i\n  var frames = []\n  var stackLines = []\n  var scripts = document.getElementsByTagName('script')\n  var inlineScriptBlocks = []\n  var parts\n  var i\n  var len\n  var wrapperSeen = false\n\n  for (i in scripts) {\n    if (has.call(scripts, i) && !scripts[i].src) {\n      inlineScriptBlocks.push(scripts[i])\n    }\n  }\n\n  for (i = 2, len = lines.length; i < len; i += 2) {\n    var item = null\n    if ((parts = lineRE1.exec(lines[i]))) {\n      item = {\n        'url': parts[2],\n        'func': parts[3],\n        'line': +parts[1]\n      }\n    } else if ((parts = lineRE2.exec(lines[i]))) {\n      item = {\n        'url': parts[3],\n        'func': parts[4]\n      }\n    } else if ((parts = lineRE3.exec(lines[i]))) {\n      var url = window.location.href.replace(/#.*$/, '')\n      var line = parts[1]\n\n      item = {\n        'url': url,\n        'line': line,\n        'func': ''\n      }\n    }\n\n    if (item) {\n      if (isWrapper(item.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(item)\n    }\n  }\n  if (!frames.length) {\n    return null // could not parse multiline exception message as Opera stack trace\n  }\n\n  return {\n    'mode': 'multiline',\n    'name': ex.name || getClassName(ex),\n    'message': lines[0],\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n\n},{}],28:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stripNewlinesRegex = /^\\n+|\\n+$/g\nvar MAX_STACK_TRACE_LENGTH = 65530\n\nmodule.exports = function (stackLines) {\n  return truncateStackLines(stackLines).replace(stripNewlinesRegex, '')\n}\n\nmodule.exports.truncateSize = truncateSize\n\n// takes array of stack lines and returns string with top 50 and buttom 50 lines\nfunction truncateStackLines(stackLines) {\n  var stackString\n  if (stackLines.length > 100) {\n    var truncatedLines = stackLines.length - 100\n    stackString = stackLines.slice(0, 50).join('\\n')\n    stackString += '\\n< ...truncated ' + truncatedLines + ' lines... >\\n'\n    stackString += stackLines.slice(-50).join('\\n')\n  } else {\n    stackString = stackLines.join('\\n')\n  }\n  return stackString\n}\n\n// truncates stack string to limit what is sent to backend\nfunction truncateSize(stackString) {\n  return (stackString.length > MAX_STACK_TRACE_LENGTH) ? stackString.substr(0, MAX_STACK_TRACE_LENGTH) : stackString\n}\n\n},{}],29:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar canonicalFunctionName = require(26)\nvar cleanURL = require(5)\nvar computeStackTrace = require(27)\nvar stringHashCode = require(30)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar stackReported = {}\nvar pageviewReported = {}\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar stringify = require(22)\nvar handle = require(\"handle\")\nvar baseEE = require(\"ee\")\nvar mapOwn = require(44)\nvar config = require(39)\nvar truncateSize = require(28).truncateSize\nvar errorCache = {}\nvar currentBody\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.err) return\nvar errorOnPage = false\n\nvar harvestTimeSeconds = config.getConfiguration('jserrors.harvestTimeSeconds') || 60\n\nee.on('feat-err', function () {\n  register('err', storeError)\n  register('ierr', storeError)\n\n  harvest.on('jserrors', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'jserrors', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds)\n})\n\nfunction onHarvestStarted(options) {\n  var body = agg.take([ 'err', 'ierr' ])\n\n  if (options.retry) {\n    currentBody = body\n  }\n\n  var payload = { body: body, qs: {} }\n  var releaseIds = stringify(loader.releaseIds)\n\n  if (releaseIds !== '{}') {\n    payload.qs.ri = releaseIds\n  }\n\n  if (body && body.err && body.err.length && !errorOnPage) {\n    payload.qs.pve = '1'\n    errorOnPage = true\n  }\n  return payload\n}\n\nfunction onHarvestFinished(result) {\n  if (!result.sent) {\n    // keep connection open\n    harvest.pingErrors(loader)\n  }\n\n  if (result.retry && currentBody) {\n    mapOwn(currentBody, function(key, value) {\n      for (var i = 0; i < value.length; i++) {\n        var bucket = value[i]\n        var name = getBucketName(bucket.params, bucket.custom)\n        agg.merge(key, name, bucket.metrics, bucket.params, bucket.custom)\n      }\n    })\n    currentBody = null\n  }\n}\n\n// open HTTPS connection, which is needed for sending data during page unload on older browsers\nharvest.pingErrors(loader)\n\nfunction nameHash (params) {\n  return stringHashCode(params.exceptionClass) ^ params.stackHash\n}\n\nfunction getBucketName(params, customParams) {\n  return nameHash(params) + ':' + stringHashCode(stringify(customParams))\n}\n\nfunction canonicalizeURL (url, cleanedOrigin) {\n  if (typeof url !== 'string') return ''\n\n  var cleanedURL = cleanURL(url)\n  if (cleanedURL === cleanedOrigin) {\n    return '<inline>'\n  } else {\n    return cleanedURL\n  }\n}\n\nfunction buildCanonicalStackString (stackInfo, cleanedOrigin) {\n  var canonicalStack = ''\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var func = canonicalFunctionName(frame.func)\n\n    if (canonicalStack) canonicalStack += '\\n'\n    if (func) canonicalStack += func + '@'\n    if (typeof frame.url === 'string') canonicalStack += frame.url\n    if (frame.line) canonicalStack += ':' + frame.line\n  }\n\n  return canonicalStack\n}\n\n// Strip query parameters and fragments from the stackString property of the\n// given stackInfo, along with the 'url' properties of each frame in\n// stackInfo.frames.\n//\n// Any URLs that are equivalent to the cleaned version of the origin will also\n// be replaced with the string '<inline>'.\n//\nfunction canonicalizeStackURLs (stackInfo) {\n  // Currently, loader.origin might contain a fragment, but we don't want to use it\n  // for comparing with frame URLs.\n  var cleanedOrigin = cleanURL(loader.origin)\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var originalURL = frame.url\n    var cleanedURL = canonicalizeURL(originalURL, cleanedOrigin)\n    if (cleanedURL && cleanedURL !== frame.url) {\n      frame.url = cleanedURL\n      stackInfo.stackString = stackInfo.stackString.split(originalURL).join(cleanedURL)\n    }\n  }\n\n  return stackInfo\n}\n\nfunction storeError (err, time, internal, customAttributes) {\n  // are we in an interaction\n  time = time || loader.now()\n  if (!internal && loader.onerror && loader.onerror(err)) return\n\n  var stackInfo = canonicalizeStackURLs(computeStackTrace(err))\n  var canonicalStack = buildCanonicalStackString(stackInfo)\n\n  var params = {\n    stackHash: stringHashCode(canonicalStack),\n    exceptionClass: stackInfo.name,\n    request_uri: window.location.pathname\n  }\n  if (stackInfo.message) {\n    params.message = '' + stackInfo.message\n  }\n\n  if (!stackReported[params.stackHash]) {\n    stackReported[params.stackHash] = true\n    params.stack_trace = truncateSize(stackInfo.stackString)\n  } else {\n    params.browser_stack_hash = stringHashCode(stackInfo.stackString)\n  }\n  params.releaseIds = stringify(loader.releaseIds)\n\n  // When debugging stack canonicalization/hashing, uncomment these lines for\n  // more output in the test logs\n  // params.origStack = err.stack\n  // params.canonicalStack = canonicalStack\n\n  var hash = nameHash(params)\n\n  if (!pageviewReported[hash]) {\n    params.pageview = 1\n    pageviewReported[hash] = true\n  }\n\n  var type = internal ? 'ierr' : 'err'\n  var newMetrics = { time: time }\n\n  // stn and spa aggregators listen to this event - stn sends the error in its payload,\n  // and spa annotates the error with interaction info\n  handle('errorAgg', [type, hash, params, newMetrics])\n\n  if (params._interactionId != null) {\n    // hold on to the error until the interaction finishes\n    errorCache[params._interactionId] = errorCache[params._interactionId] || []\n    errorCache[params._interactionId].push([type, hash, params, newMetrics, att, customAttributes])\n  } else {\n    // store custom attributes\n    var customParams = {}\n    var att = loader.info.jsAttributes\n    mapOwn(att, setCustom)\n    if (customAttributes) {\n      mapOwn(customAttributes, setCustom)\n    }\n\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n    agg.store(type, aggregateHash, params, newMetrics, customParams)\n  }\n\n  function setCustom (key, val) {\n    customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nbaseEE.on('interactionSaved', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    params.browserInteractionId = interaction.root.attrs.id\n    delete params._interactionId\n\n    if (params._interactionNodeId) {\n      params.parentNodeId = params._interactionNodeId.toString()\n      delete params._interactionNodeId\n    }\n\n    var hash = item[1] + interaction.root.attrs.id\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, params, item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n\nbaseEE.on('interactionDiscarded', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    delete params._interactionId\n    delete params._interactionNodeId\n\n    var hash = item[1]\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, item[2], item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n\n},{}],30:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nfunction stringHashCode (string) {\n  var hash = 0\n  var charVal\n\n  if (!string || !string.length) return hash\n  for (var i = 0; i < string.length; i++) {\n    charVal = string.charCodeAt(i)\n    hash = ((hash << 5) - hash) + charVal\n    hash = hash | 0 // Convert to 32bit integer\n  }\n  return hash\n}\n\nmodule.exports = stringHashCode\n\n},{}],31:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar loader = require(\"loader\")\nvar mapOwn = require(44)\nvar stringify = require(22)\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar cleanURL = require(5)\nvar config = require(39)\n\nvar eventsPerMinute = 120\nvar harvestTimeSeconds = config.getConfiguration('ins.harvestTimeSeconds') || 30\nvar eventsPerHarvest = eventsPerMinute * harvestTimeSeconds / 60\nvar referrerUrl\nvar currentEvents\n\nvar events = []\nvar att = loader.info.jsAttributes = {}\n\nif (document.referrer) referrerUrl = cleanURL(document.referrer)\n\nregister('api-setCustomAttribute', setCustomAttribute, 'api')\n\nee.on('feat-ins', function () {\n  register('api-addPageAction', addPageAction)\n\n  harvest.on('ins', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'ins', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds, 0)\n})\n\nfunction onHarvestStarted (options) {\n  var payload = ({\n    qs: {\n      ua: loader.info.userAttributes,\n      at: loader.info.atts\n    },\n    body: {\n      ins: events\n    }\n  })\n\n  if (options.retry) {\n    currentEvents = events\n  }\n\n  events = []\n  return payload\n}\n\nfunction onHarvestFinished (result) {\n  if (result && result.sent && result.retry && currentEvents) {\n    events = events.concat(currentEvents)\n    currentEvents = null\n  }\n}\n\n// WARNING: Insights times are in seconds. EXCEPT timestamp, which is in ms.\nfunction addPageAction (t, name, attributes) {\n  if (events.length >= eventsPerHarvest) return\n  var width\n  var height\n  var eventAttributes = {}\n\n  if (typeof window !== 'undefined' && window.document && window.document.documentElement) {\n    // Doesn't include the nav bar when it disappears in mobile safari\n    // https://github.com/jquery/jquery/blob/10399ddcf8a239acc27bdec9231b996b178224d3/src/dimensions.js#L23\n    width = window.document.documentElement.clientWidth\n    height = window.document.documentElement.clientHeight\n  }\n\n  var defaults = {\n    timestamp: t + loader.offset,\n    timeSinceLoad: t / 1000,\n    browserWidth: width,\n    browserHeight: height,\n    referrerUrl: referrerUrl,\n    currentUrl: cleanURL('' + location),\n    pageUrl: cleanURL(loader.origin),\n    eventType: 'PageAction'\n  }\n\n  mapOwn(defaults, set)\n  mapOwn(att, set)\n  if (attributes && typeof attributes === 'object') {\n    mapOwn(attributes, set)\n  }\n  eventAttributes.actionName = name || ''\n\n  events.push(eventAttributes)\n\n  function set (key, val) {\n    eventAttributes[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nfunction setCustomAttribute (t, key, value) {\n  att[key] = value\n}\n\n},{}],32:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar baseEE = require(\"ee\")\nvar mapOwn = require(44)\nvar loader = require(\"loader\")\nvar InteractionNode = require(33)\n\nvar originals = NREUM.o\nvar originalSetTimeout = originals.ST\nvar originalClearTimeout = originals.CT\n\nvar REMAINING = 'remaining'\n\nvar lastId = 0\n\nmodule.exports = Interaction\n\nfunction Interaction (eventName, timestamp, url, routeName, onFinished) {\n  this.id = ++lastId\n  this.eventName = eventName\n  this.nodes = 0\n  this[REMAINING] = 0\n  this.finishTimer = null\n  this.checkingFinish = false\n  this.lastCb = this.lastFinish = timestamp\n  this.handlers = []\n  this.onFinished = onFinished\n\n  var root = this.root = new InteractionNode(this, null, 'interaction', timestamp)\n  var attrs = root.attrs\n\n  attrs.trigger = eventName\n  attrs.initialPageURL = loader.origin\n  attrs.oldRoute = routeName\n  attrs.newURL = attrs.oldURL = url\n  attrs.custom = {}\n  attrs.store = {}\n}\n\nvar InteractionPrototype = Interaction.prototype\n\nInteractionPrototype.checkFinish = function checkFinish (url, routeName) {\n  var interaction = this\n\n  if (interaction[REMAINING]) {\n    interaction._resetFinishCheck()\n    return\n  }\n\n  if (interaction.checkingFinish) {\n    return\n  }\n\n  interaction._resetFinishCheck()\n\n  var attrs = this.root.attrs\n  attrs.newURL = url\n  attrs.newRoute = routeName\n\n  interaction.checkingFinish = true\n  interaction.finishTimer = originalSetTimeout(function () {\n    interaction.checkingFinish = false\n    interaction.finishTimer = originalSetTimeout(function () {\n      interaction.finishTimer = null\n      if (!interaction[REMAINING]) interaction.finish()\n    }, 1)\n  }, 0)\n}\n\nInteractionPrototype.onNodeAdded = function onNodeAdded() {\n  this._resetFinishCheck()\n}\n\nInteractionPrototype._resetFinishCheck = function _resetFinishCheck() {\n  if (this.finishTimer) {\n    originalClearTimeout(this.finishTimer)\n    this.finishTimer = null\n    this.checkingFinish = false\n  }\n}\n\n// serialize report and remove nodes from map\nInteractionPrototype.finish = function finishInteraction () {\n  var interaction = this\n  var root = interaction.root\n  if (root.end) return\n  var endTimestamp = Math.max(interaction.lastCb, interaction.lastFinish)\n\n  var attrs = root.attrs\n  var customAttrs = attrs.custom\n\n  if (this.onFinished) {\n    this.onFinished(this)\n  }\n\n  mapOwn(loader.info.jsAttributes, function (attr, value) {\n    if (!(attr in customAttrs)) customAttrs[attr] = value\n  })\n\n  root.end = endTimestamp\n  baseEE.emit('interaction', [this])\n}\n\n},{}],33:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar INTERACTION = 'interaction'\nvar MAX_NODES = 128\nvar REMAINING = 'remaining'\n\nvar lastId = 0\n\nmodule.exports = InteractionNode\n\nfunction InteractionNode (interaction, parent, type, timestamp) {\n  this[INTERACTION] = interaction\n  this.parent = parent\n  this.id = ++lastId\n  this.type = type\n  this.children = []\n  this.end = null\n  this.jsEnd = this.start = timestamp\n  this.jsTime = 0\n  this.attrs = {}\n}\n\nvar InteractionNodePrototype = InteractionNode.prototype\n\n/**\n * @param {string} type\n * @param {number} timestamp\n * @param {string} name\n * @param {bool} dontWait - When true, the interaction will not immediately start waiting\n *                          for this node to complete. This is used when the creation of\n *                          the node and its start happen at different times (e.g. XHR).\n */\nInteractionNodePrototype.child = function child (type, timestamp, name, dontWait) {\n  var interaction = this[INTERACTION]\n  if (interaction.end || interaction.nodes >= MAX_NODES) return null\n\n  interaction.onNodeAdded(this)\n\n  var node = new InteractionNode(interaction, this, type, timestamp)\n  node.attrs.name = name\n  interaction.nodes++\n  if (!dontWait) interaction[REMAINING]++\n  return node\n}\n\nInteractionNodePrototype.callback = function addCallbackTime (exclusiveTime, end) {\n  var node = this\n\n  node.jsTime += exclusiveTime\n  if (end > node.jsEnd) {\n    node.jsEnd = end\n    node[INTERACTION].lastCb = end\n  }\n}\n\nInteractionNodePrototype.finish = function finish (timestamp) {\n  var node = this\n  if (node.end) return\n  node.end = timestamp\n  var parent = node.parent\n  while (parent.cancelled) parent = parent.parent\n  parent.children.push(node)\n  node.parent = null\n\n  var interaction = this[INTERACTION]\n  interaction[REMAINING]--\n  interaction.lastFinish = timestamp\n}\n\n},{}],34:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar register = require(17)\nvar parseUrl = require(38)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar serializer = require(35)\nvar loader = require(\"loader\")\nvar baseEE = require(\"ee\")\nvar mutationEE = baseEE.get('mutation')\nvar promiseEE = baseEE.get('promise')\nvar historyEE = baseEE.get('history')\nvar eventsEE = baseEE.get('events')\nvar timerEE = baseEE.get('timer')\nvar fetchEE = baseEE.get('fetch')\nvar jsonpEE = baseEE.get('jsonp')\nvar xhrEE = baseEE.get('xhr')\nvar tracerEE = baseEE.get('tracer')\nvar mapOwn = require(44)\nvar navTiming = require(15).nt\nvar dataSize = require(40)\nvar uniqueId = require(43)\nvar paintMetrics = require(16).metrics\nvar Interaction = require(32)\nvar config = require(39)\n\nvar INTERACTION_EVENTS = [\n  'click',\n  'submit',\n  'keypress',\n  'keydown',\n  'keyup',\n  'change'\n]\n\nvar MAX_TIMER_BUDGET = 999\nvar FN_START = 'fn-start'\nvar FN_END = 'fn-end'\nvar CB_START = 'cb-start'\nvar INTERACTION_API = 'api-ixn-'\nvar REMAINING = 'remaining'\nvar INTERACTION = 'interaction'\nvar SPA_NODE = 'spaNode'\nvar JSONP_NODE = 'jsonpNode'\nvar FETCH_START = 'fetch-start'\nvar FETCH_DONE = 'fetch-done'\nvar FETCH_BODY = 'fetch-body-'\nvar JSONP_END = 'jsonp-end'\n\nvar originals = NREUM.o\nvar origRequest = originals.REQ\nvar originalSetTimeout = originals.ST\nvar initialPageURL = loader.origin\nvar lastSeenUrl = initialPageURL\nvar lastSeenRouteName = null\n\nvar timerMap = {}\nvar timerBudget = MAX_TIMER_BUDGET\nvar currentNode = null\nvar prevNode = null\nvar nodeOnLastHashUpdate = null\nvar initialPageLoad = null\nvar pageLoaded = false\nvar childTime = 0\nvar depth = 0\n\nmodule.exports = function () {\n  return currentNode && currentNode.id\n}\n\n// childTime is used when calculating exclusive time for a cb duration.\n//\n// Exclusive time will be different than the total time for either callbacks\n// which synchronously invoke a customTracer callback or, trigger a synchronous\n// event (eg. onreadystate=1 or popstate).\n//\n// At fn-end, childTime will contain the total time of all timed callbacks and\n// event handlers which executed as a child of the current callback. At the\n// begining of every callback, childTime is saved to the event context (which at\n// that time contains the sum of its preceeding siblings) and is reset to 0. The\n// callback is then executed, and its children may increase childTime.  At the\n// end of the callback, it reports its exclusive time as its\n// execution time - exlcuded. childTime is then reset to its previous\n// value, and the totalTime of the callback that just finished executing is\n// added to the childTime time.\n//                                    | clock | childTime | ctx.ct | totalTime | exclusive |\n// click fn-start                     |   0   |    0     |    0   |           |           |\n//  | click begining:                 |   5   |    0     |    0   |           |           |\n//  |   | custom-1 fn-start           |   10  |    0     |    0   |           |           |\n//  |   |   |  custom-1 begining      |   15  |    0     |    0   |           |           |\n//  |   |   |    |  custom-2 fn-start |   20  |    0     |    0   |           |           |\n//  |   |   |    |  | custom-2        |   25  |    0     |    0   |           |           |\n//  |   |   |    |  custom-2 fn-end   |   30  |    10    |    0   |     10    |     10    |\n//  |   |   |  custom-1 middle        |   35  |    10    |    0   |           |           |\n//  |   |   |    |  custom-3 fn-start |   40  |    0     |    10  |           |           |\n//  |   |   |    |  | custom-3        |   45  |    0     |    10  |           |           |\n//  |   |   |    |  custom-3 fn-end   |   50  |    20    |    0   |     10    |     10    |\n//  |   |   |  custom-1 ending        |   55  |    20    |    0   |           |           |\n//  |     custom-1 fn-end             |   60  |    50    |    0   |     50    |     30    |\n//  | click ending:                   |   65  |    50    |        |           |           |\n// click fn-end                       |   70  |    0     |    0   |     70    |     20    |\n\nbaseEE.on('feat-spa', function () {\n  if (!isEnabled()) return\n\n  initialPageLoad = new Interaction('initialPageLoad', 0, lastSeenUrl, lastSeenRouteName, onInteractionFinished)\n  initialPageLoad.save = true\n  currentNode = initialPageLoad.root // hint\n  // ensure that checkFinish calls are safe during initialPageLoad\n  initialPageLoad[REMAINING]++\n\n  register.on(baseEE, FN_START, callbackStart)\n  register.on(promiseEE, CB_START, callbackStart)\n\n  // register plugins\n  var pluginApi = {\n    getCurrentNode: getCurrentNode,\n    setCurrentNode: setCurrentNode\n  }\n\n  register('spa-register', function(init) {\n    if (typeof init === 'function') {\n      init(pluginApi)\n    }\n  })\n\n  function callbackStart () {\n    depth++\n    this.prevNode = currentNode\n    this.ct = childTime\n    childTime = 0\n    timerBudget = MAX_TIMER_BUDGET\n  }\n\n  register.on(baseEE, FN_END, callbackEnd)\n  register.on(promiseEE, 'cb-end', callbackEnd)\n\n  function callbackEnd () {\n    depth--\n    var totalTime = this.jsTime || 0\n    var exclusiveTime = totalTime - childTime\n    childTime = this.ct + totalTime\n    if (currentNode) {\n      // transfer accumulated callback time to the active interaction node\n      // run even if jsTime is 0 to update jsEnd\n      currentNode.callback(exclusiveTime, this[FN_END])\n      if (this.isTraced) {\n        currentNode.attrs.tracedTime = exclusiveTime\n      }\n    }\n\n    this.jsTime = currentNode ? 0 : exclusiveTime\n    setCurrentNode(this.prevNode)\n    this.prevNode = null\n    timerBudget = MAX_TIMER_BUDGET\n  }\n\n  register.on(eventsEE, FN_START, function (args, eventSource) {\n    var ev = args[0]\n    var evName = ev.type\n    var eventNode = ev.__nrNode\n\n    if (!pageLoaded && evName === 'load' && eventSource === window) {\n      pageLoaded = true\n      // set to null so prevNode is set correctly\n      this.prevNode = currentNode = null\n      if (initialPageLoad) {\n        eventNode = initialPageLoad.root\n        initialPageLoad[REMAINING]--\n        originalSetTimeout(function () {\n          INTERACTION_EVENTS.push('popstate')\n        })\n      }\n    }\n\n    if (eventNode) {\n      // If we've already seen a previous handler for this specific event object,\n      // just restore that. We want multiple handlers for the same event to share\n      // a node.\n      setCurrentNode(eventNode)\n    } else if (evName === 'hashchange') {\n      setCurrentNode(nodeOnLastHashUpdate)\n      nodeOnLastHashUpdate = null\n    } else if (eventSource instanceof XMLHttpRequest) {\n      // If this event was emitted by an XHR, restore the node ID associated with\n      // that XHR.\n      setCurrentNode(baseEE.context(eventSource).spaNode)\n    } else if (!currentNode) {\n      // Otherwise, if no interaction is currently active, create a new node ID,\n      // and let the aggregator know that we entered a new event handler callback\n      // so that it has a chance to possibly start an interaction.\n      if (INTERACTION_EVENTS.indexOf(evName) !== -1) {\n        var ixn = new Interaction(evName, this[FN_START], lastSeenUrl, lastSeenRouteName, onInteractionFinished)\n        setCurrentNode(ixn.root)\n\n        if (evName === 'click') {\n          var value = getActionText(ev.target)\n          if (value) {\n            currentNode.attrs.custom['actionText'] = value\n          }\n        }\n      }\n    }\n\n    ev.__nrNode = currentNode\n  })\n\n  /**\n   * *** TIMERS ***\n   * setTimeout call needs to keep the interaction active in case a node is started\n   * in its callback.\n   */\n\n  // The context supplied to this callback will be shared with the fn-start/fn-end\n  // callbacks that fire around the callback passed to setTimeout originally.\n  register.on(timerEE, 'setTimeout-end', function saveId (args, obj, timerId) {\n    if (!currentNode || (timerBudget - this.timerDuration) < 0) return\n    currentNode[INTERACTION][REMAINING]++\n    this.timerId = timerId\n    timerMap[timerId] = currentNode\n    this.timerBudget = timerBudget - 50\n  })\n\n  register.on(timerEE, 'clearTimeout-start', function clear (args) {\n    var timerId = args[0]\n    var node = timerMap[timerId]\n    if (node) {\n      var interaction = node[INTERACTION]\n      interaction[REMAINING]--\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n      delete timerMap[timerId]\n    }\n  })\n\n  register.on(timerEE, FN_START, function () {\n    timerBudget = this.timerBudget || MAX_TIMER_BUDGET\n    var id = this.timerId\n    var node = timerMap[id]\n    setCurrentNode(node)\n    delete timerMap[id]\n    if (node) {\n      node[INTERACTION][REMAINING]--\n    }\n  })\n\n  /**\n   * *** XHR ***\n   * - `new-xhr` event is fired when new instance of XHR is created. Here we create\n   *    a new node and store it on the XHR object.\n   * -  When the send method is called (`send-xhr-start` event), we tell the interaction\n   *    to wait for this XHR to complete.\n   * -  When any direct event handlers are invoked (`fn-start` on the `xhr` emitter),\n   *    we restore the node in case other child nodes are started here.\n   * -  Callbacks attached using `addEventListener` are handled using `fn-start` on the\n   *    `events` emitter.\n   * -  When `xhr-resolved` is emitted, we end the node. The node.finish() call also\n   *    instructs the interaction to stop waiting for this node.\n   */\n\n  // context is shared with new-xhr event, and is stored on the xhr iteself.\n  register.on(xhrEE, FN_START, function () {\n    setCurrentNode(this[SPA_NODE])\n  })\n\n  // context is stored on the xhr and is shared with all callbacks associated\n  // with the new xhr\n  register.on(xhrEE, 'new-xhr', function () {\n    if (currentNode) {\n      this[SPA_NODE] = currentNode.child('ajax', null, null, true)\n    }\n  })\n\n  register.on(xhrEE, 'send-xhr-start', function () {\n    var node = this[SPA_NODE]\n    if (node && !this.sent) {\n      this.sent = true\n      node.dt = this.dt\n      node.jsEnd = node.start = this['send-xhr-start']\n      node[INTERACTION][REMAINING]++\n    }\n  })\n\n  register.on(baseEE, 'xhr-resolved', function () {\n    var node = this[SPA_NODE]\n    if (node) {\n      var attrs = node.attrs\n      attrs.params = this.params\n      attrs.metrics = this.metrics\n\n      node.finish(this['xhr-resolved'])\n    }\n  })\n\n  /**\n   * *** JSONP ***\n   *\n   */\n\n  register.on(jsonpEE, 'new-jsonp', function (url) {\n    if (currentNode) {\n      var node = this[JSONP_NODE] = currentNode.child('ajax', this[FETCH_START])\n      node.start = this['new-jsonp']\n      this.url = url\n      this.status = null\n    }\n  })\n\n  register.on(jsonpEE, 'cb-start', function (args) {\n    var node = this[JSONP_NODE]\n    if (node) {\n      setCurrentNode(node)\n      this.status = 200\n    }\n  })\n\n  register.on(jsonpEE, 'jsonp-error', function () {\n    var node = this[JSONP_NODE]\n    if (node) {\n      setCurrentNode(node)\n      this.status = 0\n    }\n  })\n\n  register.on(jsonpEE, JSONP_END, function () {\n    var node = this[JSONP_NODE]\n    if (node) {\n      // if no status is set then cb never fired - so it's not a valid JSONP\n      if (this.status === null) {\n        node[INTERACTION][REMAINING]--\n        node.cancelled = true\n        return\n      }\n      var attrs = node.attrs\n      var params = attrs.params = {}\n\n      var parsed = parseUrl(this.url)\n      params.method = 'GET'\n      params.pathname = parsed.pathname\n      params.host = parsed.hostname + ':' + parsed.port\n      params.status = this.status\n\n      attrs.metrics = {\n        txSize: 0,\n        rxSize: 0\n      }\n\n      attrs.isJSONP = true\n      node.jsEnd = this[JSONP_END]\n      node.jsTime = this[CB_START] ? (this[JSONP_END] - this[CB_START]) : 0\n      node.finish(node.jsEnd)\n    }\n  })\n\n  register.on(fetchEE, FETCH_START, function (fetchArguments, dtPayload) {\n    if (currentNode && fetchArguments) {\n      this[SPA_NODE] = currentNode.child('ajax', this[FETCH_START])\n      if (fetchArguments.length >= 1) this.target = fetchArguments[0]\n      if (fetchArguments.length >= 2) this.opts = fetchArguments[1]\n\n      if (dtPayload && this[SPA_NODE]) this[SPA_NODE].dt = dtPayload\n    }\n  })\n\n  register.on(fetchEE, FETCH_BODY + 'start', function (args) {\n    if (currentNode) {\n      this[SPA_NODE] = currentNode\n      currentNode[INTERACTION][REMAINING]++\n    }\n  })\n\n  register.on(fetchEE, FETCH_BODY + 'end', function (args, ctx, bodyPromise) {\n    var node = this[SPA_NODE]\n    if (node) {\n      node[INTERACTION][REMAINING]--\n    }\n  })\n\n  register.on(fetchEE, FETCH_DONE, function (err, res) {\n    var node = this[SPA_NODE]\n    var target = this.target\n    var opts = this.opts || {}\n    if (node) {\n      if (err) {\n        node.cancelled = true\n        node[INTERACTION][REMAINING]--\n        return\n      }\n\n      var url, method\n      if (typeof target === 'string') {\n        url = target\n      } else if (typeof target === 'object' && target instanceof origRequest) {\n        url = target.url\n      } else if (window.URL && typeof target === 'object' && target instanceof URL) {\n        url = target.href\n      }\n\n      method = ('' + ((target && target instanceof origRequest && target.method) || opts.method || 'GET')).toUpperCase()\n      var attrs = node.attrs\n      var params = attrs.params = {}\n\n      var parsed = parseUrl(url)\n      params.method = method\n      params.pathname = parsed.pathname\n      params.host = parsed.hostname + ':' + parsed.port\n      params.status = res.status\n\n      attrs.metrics = {\n        txSize: dataSize(opts.body) || 0,\n        rxSize: this.rxSize\n      }\n\n      attrs.isFetch = true\n\n      node.finish(this[FETCH_DONE])\n    }\n  })\n\n  register.on(historyEE, 'newURL', function (url, hashChangedDuringCb) {\n    if (currentNode) {\n      if (lastSeenUrl !== url) {\n        currentNode[INTERACTION].routeChange = true\n      }\n      if (hashChangedDuringCb) {\n        nodeOnLastHashUpdate = currentNode\n      }\n    }\n\n    lastSeenUrl = url\n  })\n\n  /**\n   * SCRIPTS\n   *   This is only needed to keep the interaction open while external scripts are being loaded.\n   *   The script that is loaded could continue the interaction by making additional AJAX\n   *   calls or changing the URL. The interaction context (currentNode) needs to be\n   *   restored somehow, but this differs based on the specific customer code. In some cases, we\n   *   could wrap a JSONP callback, in other cases we could wrap a higher-level API, and in\n   *   some cases we may not be able to restore context automatically (customer would need\n   *   to instrument their code manually).\n   *\n   * - We do not restore the original context in the load/error callbacks. This would not\n   *   work for the scripts themselves because by the time the load event fires, the\n   *   script content has already been executed.\n   */\n\n  // dom-start is emitted when appendChild or replaceChild are called. If the element being\n  // inserted is script and we are inside an interaction, we will keep the interaction open\n  // until the script is loaded.\n  jsonpEE.on('dom-start', function (args) {\n    if (!currentNode) return\n\n    var el = args[0]\n    var isScript = (el && el.nodeName === 'SCRIPT' && el.src !== '')\n    var interaction = currentNode.interaction\n\n    if (isScript) {\n      // increase remaining count to keep the interaction open\n      interaction[REMAINING]++\n      el.addEventListener('load', onload, false)\n      el.addEventListener('error', onerror, false)\n    }\n\n    function onload() {\n      // decrease remaining to allow interaction to finish\n      interaction[REMAINING]--\n\n      // checkFinish is what initiates closing interaction, but is only called\n      // when setCurrentNode is called. Since we are not restoring a node here,\n      // we need to initiate the check manually.\n      // The reason we are not restoring the node here is because 1) this is not\n      // where the code of the external script runs (by the time the load event\n      // fires, it has already executed), and 2) it would require storing the context\n      // probably on the DOM node and restoring in all callbacks, which is a different\n      // use case than lazy loading.\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n    }\n\n    function onerror() {\n      interaction[REMAINING]--\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n    }\n  })\n\n  register.on(mutationEE, FN_START, function () {\n    setCurrentNode(prevNode)\n  })\n\n  register.on(promiseEE, 'resolve-start', resolvePromise)\n  register.on(promiseEE, 'executor-err', resolvePromise)\n\n  register.on(promiseEE, 'propagate', saveNode)\n\n  register.on(promiseEE, CB_START, function () {\n    var ctx = this.getCtx ? this.getCtx() : this\n    setCurrentNode(ctx[SPA_NODE])\n  })\n\n  register(INTERACTION_API + 'get', function (t) {\n    var interaction = this.ixn = currentNode ? currentNode[INTERACTION] : new Interaction('api', t, lastSeenUrl, lastSeenRouteName, onInteractionFinished)\n\n    if (!currentNode) {\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n      if (depth) setCurrentNode(interaction.root)\n    }\n  })\n\n  register(INTERACTION_API + 'actionText', function (t, actionText) {\n    var customAttrs = this.ixn.root.attrs.custom\n    if (actionText) customAttrs.actionText = actionText\n  })\n\n  register(INTERACTION_API + 'setName', function (t, name, trigger) {\n    var attrs = this.ixn.root.attrs\n    if (name) attrs.customName = name\n    if (trigger) attrs.trigger = trigger\n  })\n\n  register(INTERACTION_API + 'setAttribute', function (t, name, value) {\n    this.ixn.root.attrs.custom[name] = value\n  })\n\n  register(INTERACTION_API + 'end', function (timestamp) {\n    var interaction = this.ixn\n    var node = activeNodeFor(interaction)\n    setCurrentNode(null)\n    node.child('customEnd', timestamp).finish(timestamp)\n    interaction.finish()\n  })\n\n  register(INTERACTION_API + 'ignore', function () {\n    this.ixn.ignored = true\n  })\n\n  register(INTERACTION_API + 'save', function () {\n    this.ixn.save = true\n  })\n\n  register(INTERACTION_API + 'tracer', function (timestamp, name, store) {\n    var interaction = this.ixn\n    var parent = activeNodeFor(interaction)\n    var ctx = baseEE.context(store)\n    if (!name) {\n      ctx.inc = ++interaction[REMAINING]\n      return (ctx[SPA_NODE] = parent)\n    }\n    ctx[SPA_NODE] = parent.child('customTracer', timestamp, name)\n  })\n\n  register.on(tracerEE, FN_START, tracerDone)\n  register.on(tracerEE, 'no-' + FN_START, tracerDone)\n\n  function tracerDone (timestamp, interactionContext, hasCb) {\n    var node = this[SPA_NODE]\n    if (!node) return\n    var interaction = node[INTERACTION]\n    var inc = this.inc\n    this.isTraced = true\n    if (inc) {\n      interaction[REMAINING]--\n    } else if (node) {\n      node.finish(timestamp)\n    }\n    hasCb ? setCurrentNode(node) : interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n  }\n\n  register(INTERACTION_API + 'getContext', function (t, cb) {\n    var store = this.ixn.root.attrs.store\n    setTimeout(function () {\n      cb(store)\n    }, 0)\n  })\n\n  register(INTERACTION_API + 'onEnd', function (t, cb) {\n    this.ixn.handlers.push(cb)\n  })\n\n  register('api-routeName', function (t, currentRouteName) {\n    lastSeenRouteName = currentRouteName\n  })\n\n  function activeNodeFor (interaction) {\n    return (currentNode && currentNode[INTERACTION] === interaction) ? currentNode : interaction.root\n  }\n})\n\nfunction saveNode (val, overwrite) {\n  if (overwrite || !this[SPA_NODE]) this[SPA_NODE] = currentNode\n}\n\nfunction resolvePromise () {\n  if (!this.resolved) {\n    this.resolved = true\n    this[SPA_NODE] = currentNode\n  }\n}\n\nfunction getCurrentNode() {\n  return currentNode\n}\n\nfunction setCurrentNode (newNode) {\n  if (!pageLoaded && !newNode && initialPageLoad) newNode = initialPageLoad.root\n  if (currentNode) {\n    currentNode[INTERACTION].checkFinish(lastSeenUrl, lastSeenRouteName)\n  }\n\n  prevNode = currentNode\n  currentNode = (newNode && !newNode[INTERACTION].root.end) ? newNode : null\n}\n\nfunction onInteractionFinished(interaction) {\n  if (interaction === initialPageLoad) initialPageLoad = null\n\n  var root = interaction.root\n  var attrs = root.attrs\n\n  // make sure that newrelic[INTERACTION]() works in end handler\n  currentNode = root\n  mapOwn(interaction.handlers, function (i, cb) {\n    cb(attrs.store)\n  })\n  setCurrentNode(null)\n}\n\nvar harvestTimeSeconds = config.getConfiguration('spa.harvestTimeSeconds') || 10\nvar interactionsToHarvest = []\nvar interactionsSent = []\n\nvar scheduler = new HarvestScheduler(loader, 'events', { onFinished: onHarvestFinished, retryDelay: harvestTimeSeconds })\n\nharvest.on('events', onHarvestStarted)\n\nfunction onHarvestStarted(options) {\n  if (interactionsToHarvest.length === 0) return {}\n  var payload = serializer.serializeMultiple(interactionsToHarvest, 0, navTiming)\n\n  if (options.retry) {\n    interactionsToHarvest.forEach(function(interaction) {\n      interactionsSent.push(interaction)\n    })\n  }\n  interactionsToHarvest = []\n\n  return { body: { e: payload } }\n}\n\nfunction onHarvestFinished(result) {\n  if (result.sent && result.retry && interactionsSent.length > 0) {\n    interactionsSent.forEach(function(interaction) {\n      interactionsToHarvest.push(interaction)\n    })\n    interactionsSent = []\n  }\n}\n\nbaseEE.on('errorAgg', function (type, name, params, metrics) {\n  if (!currentNode) return\n  params._interactionId = currentNode.interaction.id\n  // do not capture parentNodeId when in root node\n  if (currentNode.type && currentNode.type !== 'interaction') {\n    params._interactionNodeId = currentNode.id\n  }\n})\n\nbaseEE.on('interaction', saveInteraction)\n\nfunction getActionText (node) {\n  var nodeType = node.tagName.toLowerCase()\n  var goodNodeTypes = ['a', 'button', 'input']\n  var isGoodNode = goodNodeTypes.indexOf(nodeType) !== -1\n  if (isGoodNode) {\n    return node.title || node.value || node.innerText\n  }\n}\n\nfunction saveInteraction (interaction) {\n  if (interaction.ignored || (!interaction.save && !interaction.routeChange)) {\n    baseEE.emit('interactionDiscarded', [interaction])\n    return\n  }\n\n  // assign unique id, this is serialized and used to link interactions with errors\n  interaction.root.attrs.id = uniqueId.generateUuid()\n\n  if (interaction.root.attrs.trigger === 'initialPageLoad') {\n    interaction.root.attrs.firstPaint = paintMetrics['first-paint']\n    interaction.root.attrs.firstContentfulPaint = paintMetrics['first-contentful-paint']\n  }\n  baseEE.emit('interactionSaved', [interaction])\n  interactionsToHarvest.push(interaction)\n  scheduler.scheduleHarvest(0)\n}\n\nfunction isEnabled() {\n  var configuration = config.getConfiguration('spa')\n  if (configuration && configuration.enabled === false) {\n    return false\n  }\n  return true\n}\n\n},{}],35:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar cleanURL = require(5)\nvar loader = require(\"loader\")\nvar mapOwn = require(44)\nvar nullable = require(4).nullable\nvar numeric = require(4).numeric\nvar getAddStringContext = require(4).getAddStringContext\nvar addCustomAttributes = require(4).addCustomAttributes\n\nmodule.exports = serializeSingle\nmodule.exports.serializeMultiple = serializeMultiple\n\nfunction serializeMultiple(interactions, offset, navTiming) {\n  var addString = getAddStringContext()\n  var serialized = 'bel.7'\n  interactions.forEach(function(interaction) {\n    serialized += ';' + serializeInteraction(interaction.root, offset, navTiming, interaction.routeChange, addString)\n  })\n  return serialized\n}\n\nfunction serializeSingle(root, offset, navTiming, isRouteChange) {\n  var addString = getAddStringContext()\n  return 'bel.7;' + serializeInteraction(root, offset, navTiming, isRouteChange, addString)\n}\n\nfunction serializeInteraction (root, offset, navTiming, isRouteChange, addString) {\n  offset = offset || 0\n  var isInitialPage = root.attrs.trigger === 'initialPageLoad'\n  var firstTimestamp\n  var typeIdsByName = {\n    interaction: 1,\n    ajax: 2,\n    customTracer: 4\n  }\n\n  // Include the hash fragment with all SPA data\n  var includeHashFragment = true\n\n  return addNode(root, []).join(';')\n\n  function addNode (node, nodeList) {\n    if (node.type === 'customEnd') return nodeList.push([3, numeric(node.end - firstTimestamp)])\n    var typeName = node.type\n    var typeId = typeIdsByName[typeName]\n    var startTimestamp = node.start\n    var childCount = node.children.length\n    var attrCount = 0\n    var apmAttributes = loader.info.atts\n    var hasNavTiming = isInitialPage && navTiming.length && typeId === 1\n    var children = []\n    var attrs = node.attrs\n    var metrics = attrs.metrics\n    var params = attrs.params\n    var queueTime = loader.info.queueTime\n    var appTime = loader.info.applicationTime\n\n    if (typeof firstTimestamp === 'undefined') {\n      startTimestamp += offset\n      firstTimestamp = startTimestamp\n    } else {\n      startTimestamp -= firstTimestamp\n    }\n\n    var fields = [\n      numeric(startTimestamp),\n      numeric(node.end - node.start),\n      numeric(node.jsEnd - node.end),\n      numeric(node.jsTime)\n    ]\n\n    switch (typeId) {\n      case 1:\n        fields[2] = numeric(node.jsEnd - firstTimestamp)\n        fields.push(\n          addString(attrs.trigger),\n          addString(cleanURL(attrs.initialPageURL, includeHashFragment)),\n          addString(cleanURL(attrs.oldURL, includeHashFragment)),\n          addString(cleanURL(attrs.newURL, includeHashFragment)),\n          addString(attrs.customName),\n          isInitialPage ? '' : isRouteChange ? 1 : 2,\n          nullable(isInitialPage && queueTime, numeric, true) +\n          nullable(isInitialPage && appTime, numeric, true) +\n          nullable(attrs.oldRoute, addString, true) +\n          nullable(attrs.newRoute, addString, true) +\n          addString(attrs.id),\n          addString(node.id),\n          nullable(attrs.firstPaint, numeric, true) +\n          nullable(attrs.firstContentfulPaint, numeric, false)\n        )\n\n        var attrParts = addCustomAttributes(attrs.custom, addString)\n        children = children.concat(attrParts)\n        attrCount = attrParts.length\n\n        if (apmAttributes) {\n          childCount++\n          children.push('a,' + addString(apmAttributes))\n        }\n\n        break\n\n      case 2:\n        fields.push(\n          addString(params.method),\n          numeric(params.status),\n          addString(params.host),\n          addString(params.pathname),\n          numeric(metrics.txSize),\n          numeric(metrics.rxSize),\n          attrs.isFetch ? 1 : (attrs.isJSONP ? 2 : ''),\n          addString(node.id),\n          nullable(node.dt && node.dt.spanId, addString, true) +\n          nullable(node.dt && node.dt.traceId, addString, true) +\n          nullable(node.dt && node.dt.timestamp, numeric, false)\n        )\n        break\n\n      case 4:\n        var tracedTime = attrs.tracedTime\n        fields.push(\n          addString(attrs.name),\n          nullable(tracedTime, numeric, true) +\n          addString(node.id)\n        )\n        break\n    }\n\n    for (var i = 0; i < node.children.length; i++) {\n      addNode(node.children[i], children)\n    }\n\n    fields.unshift(\n      numeric(typeId),\n      numeric(childCount += attrCount)\n    )\n\n    nodeList.push(fields)\n\n    if (childCount) {\n      nodeList.push(children.join(';'))\n    }\n\n    if (hasNavTiming) {\n      // this build up the navTiming node\n      // it for each navTiming value (pre aggregated in nav-timing.js):\n      // we initialize the seperator to ',' (seperates the nodeType id from the first value)\n      // we initialize the navTiming node to 'b' (the nodeType id)\n      // if the value is present:\n      //   we add the seperator followed by the value\n      // otherwise\n      //   we add null seperator ('!') to the navTimingNode\n      //   we set the seperator to an empty string since we already wrote it above\n      //   the reason for writing the null seperator instead of setting the seperator\n      //   is to ensure we still write it if the null is the last navTiming value.\n\n      var seperator = ','\n      var navTimingNode = 'b'\n      var prev = 0\n\n      // get all navTiming values except navigationStart\n      // (since its the same as interaction.start)\n      // and limit to just the first 20 values we know about\n      mapOwn(navTiming.slice(1, 21), function (i, v) {\n        if (v !== void 0) {\n          navTimingNode += seperator + numeric(v - prev)\n          seperator = ','\n          prev = v\n        } else {\n          navTimingNode += seperator + '!'\n          seperator = ''\n        }\n      })\n      nodeList.push(navTimingNode)\n    } else if (typeId === 1) {\n      nodeList.push('')\n    }\n\n    return nodeList\n  }\n}\n\n},{}],36:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar loader = require(\"loader\")\nvar registerHandler = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar mapOwn = require(44)\nvar reduce = require(47)\nvar stringify = require(22)\nvar slice = require(45)\nvar parseUrl = require(38)\nvar config = require(39)\n\nif (!harvest.xhrUsable || !loader.xhrWrappable) return\n\nvar ptid = ''\nvar ignoredEvents = {mouseup: true, mousedown: true}\nvar toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n}\n\nvar rename = {\n  typing: {\n    keydown: true,\n    keyup: true,\n    keypress: true\n  },\n  mousing: {\n    mousemove: true,\n    mouseenter: true,\n    mouseleave: true,\n    mouseover: true,\n    mouseout: true\n  },\n  scrolling: {\n    scroll: true\n  },\n  touching: {\n    touchstart: true,\n    touchmove: true,\n    touchend: true,\n    touchcancel: true,\n    touchenter: true,\n    touchleave: true\n  }\n}\n\nvar trace = {}\nvar nodeCount = 0\nvar sentTrace = null\nvar harvestTimeSeconds = config.getConfiguration('stn.harvestTimeSeconds') || 10\nvar maxNodesPerHarvest = config.getConfiguration('stn.maxNodesPerHarvest') || 1000\n\nvar ee = require(\"ee\")\n\n// exports only used for testing\nmodule.exports = {\n  _takeSTNs: takeSTNs\n}\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.stn) return\n\nee.on('feat-stn', function () {\n  storeTiming(window.performance.timing)\n\n  harvest.on('resources', prepareHarvest)\n\n  var scheduler = new HarvestScheduler(loader, 'resources', { onFinished: onHarvestFinished, retryDelay: harvestTimeSeconds })\n  scheduler.runHarvest({ needResponse: true })\n\n  function onHarvestFinished(result) {\n    // start timer only if ptid was returned by server\n    if (result.sent && result.responseText && !ptid) {\n      ptid = result.responseText\n      scheduler.startTimer(harvestTimeSeconds)\n    }\n\n    if (result.sent && result.retry && sentTrace) {\n      mapOwn(sentTrace, function (name, nodes) {\n        mergeSTNs(name, nodes)\n      })\n      sentTrace = null\n    }\n  }\n\n  function prepareHarvest(options) {\n    if ((loader.now()) > (15 * 60 * 1000)) {\n      // been collecting for over 15 min, empty trace object and bail\n      scheduler.stopTimer()\n      trace = {}\n      return\n    }\n\n    // only send when there are more than 30 nodes to send\n    if (ptid && nodeCount <= 30) return\n\n    return takeSTNs(options.retry)\n  }\n\n  registerHandler('bst', storeEvent)\n  registerHandler('bstTimer', storeTimer)\n  registerHandler('bstResource', storeResources)\n  registerHandler('bstHist', storeHist)\n  registerHandler('bstXhrAgg', storeXhrAgg)\n  registerHandler('bstApi', storeSTN)\n  registerHandler('errorAgg', storeErrorAgg)\n})\n\nfunction storeTiming (_t) {\n  var key\n  var val\n  var timeOffset\n  var now = Date.now()\n\n  // loop iterates through prototype also (for FF)\n  for (key in _t) {\n    val = _t[key]\n\n    // ignore inherited methods, meaningless 0 values, and bogus timestamps\n    // that are in the future (Microsoft Edge seems to sometimes produce these)\n    if (!(typeof (val) === 'number' && val > 0 && val < now)) continue\n\n    timeOffset = _t[key] - loader.offset\n\n    storeSTN({\n      n: key,\n      s: timeOffset,\n      e: timeOffset,\n      o: 'document',\n      t: 'timing'\n    })\n  }\n}\n\nfunction storeTimer (target, start, end, type) {\n  var category = 'timer'\n  if (type === 'requestAnimationFrame') category = type\n\n  var evt = {\n    n: type,\n    s: start,\n    e: end,\n    o: 'window',\n    t: category\n  }\n\n  storeSTN(evt)\n}\n\nfunction storeEvent (currentEvent, target, start, end) {\n  // we find that certain events make the data too noisy to be useful\n  if (currentEvent.type in ignoredEvents) { return false }\n\n  var evt = {\n    n: evtName(currentEvent.type),\n    s: start,\n    e: end,\n    t: 'event'\n  }\n\n  try {\n    // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n    // it does not check currentEvent.currentTarget before calling getRootNode() on it\n    evt.o = evtOrigin(currentEvent.target, target)\n  } catch (e) {\n    evt.o = evtOrigin(null, target)\n  }\n\n  storeSTN(evt)\n}\n\nfunction evtName (type) {\n  var name = type\n\n  mapOwn(rename, function (key, val) {\n    if (type in val) name = key\n  })\n\n  return name\n}\n\nfunction evtOrigin (t, target) {\n  var origin = 'unknown'\n\n  if (t && t instanceof XMLHttpRequest) {\n    var params = ee.context(t).params\n    origin = params.status + ' ' + params.method + ': ' + params.host + params.pathname\n  } else if (t && typeof (t.tagName) === 'string') {\n    origin = t.tagName.toLowerCase()\n    if (t.id) origin += '#' + t.id\n    if (t.className) origin += '.' + slice(t.classList).join('.')\n  }\n\n  if (origin === 'unknown') {\n    if (target === document) origin = 'document'\n    else if (target === window) origin = 'window'\n    else if (target instanceof FileReader) origin = 'FileReader'\n  }\n\n  return origin\n}\n\nfunction storeHist (path, old, time) {\n  var node = {\n    n: 'history.pushState',\n    s: time,\n    e: time,\n    o: path,\n    t: old\n  }\n\n  storeSTN(node)\n}\n\nvar laststart = 0\n\nfunction storeResources (resources) {\n  resources.forEach(function (currentResource) {\n    var parsed = parseUrl(currentResource.name)\n    var res = {\n      n: currentResource.initiatorType,\n      s: currentResource.fetchStart | 0,\n      e: currentResource.responseEnd | 0,\n      o: parsed.protocol + '://' + parsed.hostname + ':' + parsed.port + parsed.pathname, // resource.name is actually a URL so it's the source\n      t: currentResource.entryType\n    }\n\n    // don't recollect old resources\n    if (res.s < laststart) return\n\n    laststart = res.s\n\n    storeSTN(res)\n  })\n}\n\nfunction storeErrorAgg (type, name, params, metrics) {\n  if (type !== 'err') return\n  var node = {\n    n: 'error',\n    s: metrics.time,\n    e: metrics.time,\n    o: params.message,\n    t: params.stackHash\n  }\n  storeSTN(node)\n}\n\nfunction storeXhrAgg (type, name, params, metrics) {\n  if (type !== 'xhr') return\n  var node = {\n    n: 'Ajax',\n    s: metrics.time,\n    e: metrics.time + metrics.duration,\n    o: params.status + ' ' + params.method + ': ' + params.host + params.pathname,\n    t: 'ajax'\n  }\n  storeSTN(node)\n}\n\nfunction storeSTN (stn) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[stn.n]\n  if (!traceArr) traceArr = trace[stn.n] = []\n\n  traceArr.push(stn)\n  nodeCount++\n}\n\nfunction mergeSTNs(key, nodes) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[key]\n  if (!traceArr) traceArr = trace[key] = []\n\n  trace[key] = nodes.concat(traceArr)\n  nodeCount += nodes.length\n}\n\nfunction takeSTNs (retry) {\n  storeResources(window.performance.getEntriesByType('resource'))\n  var stns = reduce(mapOwn(trace, function (name, nodes) {\n    if (!(name in toAggregate)) return nodes\n\n    return reduce(mapOwn(reduce(nodes.sort(byStart), smearEvtsByOrigin(name), {}), val), flatten, [])\n  }), flatten, [])\n\n  if (stns.length === 0) return {}\n\n  if (retry) {\n    sentTrace = trace\n  }\n  trace = {}\n  nodeCount = 0\n\n  var stnInfo = {\n    qs: {st: '' + loader.offset, ptid: ptid},\n    body: {res: stns}\n  }\n\n  if (!ptid) {\n    stnInfo.qs.ua = loader.info.userAttributes\n    stnInfo.qs.at = loader.info.atts\n    var ja = stringify(loader.info.jsAttributes)\n    stnInfo.qs.ja = ja === '{}' ? null : ja\n  }\n  return stnInfo\n}\n\nfunction byStart (a, b) {\n  return a.s - b.s\n}\n\nfunction smearEvtsByOrigin (name) {\n  var maxGap = toAggregate[name][0]\n  var maxLen = toAggregate[name][1]\n  var lastO = {}\n\n  return function (byOrigin, evt) {\n    var lastArr = byOrigin[evt.o]\n\n    lastArr || (lastArr = byOrigin[evt.o] = [])\n\n    var last = lastO[evt.o]\n\n    if (name === 'scrolling' && !trivial(evt)) {\n      lastO[evt.o] = null\n      evt.n = 'scroll'\n      lastArr.push(evt)\n    } else if (last && (evt.s - last.s) < maxLen && last.e > (evt.s - maxGap)) {\n      last.e = evt.e\n    } else {\n      lastO[evt.o] = evt\n      lastArr.push(evt)\n    }\n\n    return byOrigin\n  }\n}\n\nfunction val (key, value) {\n  return value\n}\n\nfunction flatten (a, b) {\n  return a.concat(b)\n}\n\nfunction trivial (node) {\n  var limit = 4\n  if (node && typeof node.e === 'number' && typeof node.s === 'number' && (node.e - node.s) < limit) return true\n  else return false\n}\n\n},{}],37:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar register = require(17)\nvar harvest = require(10)\nvar stringify = require(22)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar handle = require(\"handle\")\n\n// bail if not instrumented\nif (!loader.features.xhr) return\n\nharvest.on('jserrors', function () {\n  return { body: agg.take([ 'xhr' ]) }\n})\n\nee.on('feat-err', function () { register('xhr', storeXhr) })\n\nmodule.exports = storeXhr\n\nfunction storeXhr (params, metrics, start) {\n  metrics.time = start\n\n  var type = 'xhr'\n  var hash\n  if (params.cat) {\n    hash = stringify([params.status, params.cat])\n  } else {\n    hash = stringify([params.status, params.host, params.pathname])\n  }\n\n  handle('bstXhrAgg', [type, hash, params, metrics])\n  agg.store(type, hash, params, metrics)\n}\n\n},{}],38:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stringsToParsedUrls = {}\n\nmodule.exports = function parseUrl (url) {\n  if (url in stringsToParsedUrls) {\n    return stringsToParsedUrls[url]\n  }\n\n  var urlEl = document.createElement('a')\n  var location = window.location\n  var ret = {}\n\n  // Use an anchor dom element to resolve the url natively.\n  urlEl.href = url\n\n  ret.port = urlEl.port\n\n  var firstSplit = urlEl.href.split('://')\n\n  if (!ret.port && firstSplit[1]) {\n    ret.port = firstSplit[1].split('/')[0].split('@').pop().split(':')[1]\n  }\n  if (!ret.port || ret.port === '0') ret.port = (firstSplit[0] === 'https' ? '443' : '80')\n\n  // Host not provided in IE for relative urls\n  ret.hostname = (urlEl.hostname || location.hostname)\n\n  ret.pathname = urlEl.pathname\n\n  ret.protocol = firstSplit[0]\n\n  // Pathname sometimes doesn't have leading slash (IE 8 and 9)\n  if (ret.pathname.charAt(0) !== '/') ret.pathname = '/' + ret.pathname\n\n  // urlEl.protocol is ':' in old ie when protocol is not specified\n  var sameProtocol = !urlEl.protocol || urlEl.protocol === ':' || urlEl.protocol === location.protocol\n  var sameDomain = urlEl.hostname === document.domain && urlEl.port === location.port\n\n  // urlEl.hostname is not provided by IE for relative urls, but relative urls are also same-origin\n  ret.sameOrigin = sameProtocol && (!urlEl.hostname || sameDomain)\n\n  // Only cache if url doesn't have a path\n  if (ret.pathname === '/') {\n    stringsToParsedUrls[url] = ret\n  }\n\n  return ret\n}\n\n},{}],39:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getConfiguration: getConfiguration\n}\n\nfunction getConfiguration(path) {\n  if (!NREUM.init) return\n  var val = NREUM.init\n  var parts = path.split('.')\n  for (var i = 0; i < parts.length - 1; i++) {\n    val = val[parts[i]]\n    if (typeof val !== 'object') return\n  }\n  val = val[parts[parts.length - 1]]\n  return val\n}\n\n},{}],40:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = function dataSize (data) {\n  if (typeof data === 'string' && data.length) return data.length\n  if (typeof data !== 'object') return undefined\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer && data.byteLength) return data.byteLength\n  if (typeof Blob !== 'undefined' && data instanceof Blob && data.size) return data.size\n  if (typeof FormData !== 'undefined' && data instanceof FormData) return undefined\n\n  try {\n    return JSON.stringify(data).length\n  } catch (e) {\n    return undefined\n  }\n}\n\n},{}],41:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = 0\nvar match = navigator.userAgent.match(/Firefox[\\/\\s](\\d+\\.\\d+)/)\nif (match) ffVersion = +match[1]\n\nmodule.exports = ffVersion\n\n},{}],42:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar lastTimestamp = new Date().getTime()\nvar offset = lastTimestamp\n\nvar performanceCheck = require(46)\n\nmodule.exports = now\nmodule.exports.offset = offset\nmodule.exports.getLastTimestamp = getLastTimestamp\n\nfunction now () {\n  if (performanceCheck.exists && performance.now) {\n    return Math.round(performance.now())\n  }\n  // ensure a new timestamp is never smaller than a previous timestamp\n  return (lastTimestamp = Math.max(new Date().getTime(), lastTimestamp)) - offset\n}\n\nfunction getLastTimestamp() {\n  return lastTimestamp\n}\n\n},{}],43:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  generateUuid: generateUuid,\n  generateSpanId: generateSpanId,\n  generateTraceId: generateTraceId\n}\n\nfunction generateUuid () {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n\n  // v4 UUID\n  var template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  var id = ''\n  var c\n  for (var i = 0; i < template.length; i++) {\n    c = template[i]\n    if (c === 'x') {\n      id += getRandomValue().toString(16)\n    } else if (c === 'y') {\n      // this is the uuid variant per spec (8, 9, a, b)\n      // % 4, then shift to get values 8-11\n      c = getRandomValue() & 0x3 | 0x8\n      id += c.toString(16)\n    } else {\n      id += c\n    }\n  }\n\n  return id\n}\n\n// 16-character hex string (per DT spec)\nfunction generateSpanId () {\n  return generateRandomHexString(16)\n}\n\n// 32-character hex string (per DT spec)\nfunction generateTraceId() {\n  return generateRandomHexString(32)\n}\n\nfunction generateRandomHexString(length) {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues && Uint8Array) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  var chars = []\n  for (var i = 0; i < length; i++) {\n    chars.push(getRandomValue().toString(16))\n  }\n  return chars.join('')\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n}\n\n},{}],44:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = mapOwn\n\nfunction mapOwn (obj, fn) {\n  var results = []\n  var key = ''\n  var i = 0\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      results[i] = fn(key, obj[key])\n      i += 1\n    }\n  }\n\n  return results\n}\n\n},{}],45:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n\n},{}],46:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  exists: typeof (window.performance) !== 'undefined' && window.performance.timing && typeof (window.performance.timing.navigationStart) !== 'undefined'\n}\n\n},{}],47:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = reduce\n\nfunction reduce (arr, fn, next) {\n  var i = 0\n  if (typeof next === 'undefined') {\n    next = arr[0]\n    i = 1\n  }\n\n  for (i; i < arr.length; i++) {\n    next = fn(next, arr[i])\n  }\n\n  return next\n}\n\n},{}]},{},[29,37,36,31,34,12])\n\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\n\nvar aggregatedData = {}\n\nmodule.exports = {\n  store: store,\n  take: take,\n  get: get,\n  merge: mergeMetrics\n}\n\n// Items with the same type and name get aggregated together\n// params are example data from the aggregated items\n// metrics are the numeric values to be aggregated\nfunction store (type, name, params, newMetrics, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  bucket.metrics = aggregateMetrics(newMetrics, bucket.metrics)\n  return bucket\n}\n\nfunction aggregateMetrics (newMetrics, oldMetrics) {\n  if (!oldMetrics) oldMetrics = {count: 0}\n  oldMetrics.count += 1\n  mapOwn(newMetrics, function (key, value) {\n    oldMetrics[key] = updateMetric(value, oldMetrics[key])\n  })\n  return oldMetrics\n}\n\nfunction updateMetric (value, metric) {\n  // When there is only one data point, the c (count), min, max, and sos (sum of squares) params are superfluous.\n  if (!metric) return {t: value}\n\n  // but on the second data point, we need to calculate the other values before aggregating in new values\n  if (!metric.c) {\n    metric = createMetricObject(metric.t)\n  }\n\n  // at this point, metric is always uncondensed\n  metric.c += 1\n  metric.t += value\n  metric.sos += value * value\n  if (value > metric.max) metric.max = value\n  if (value < metric.min) metric.min = value\n\n  return metric\n}\n\n/**\n * Merge metrics object into existing metrics.\n *\n * @param {string} type\n * @param {string} name\n * @param {object} metrics - Metrics to merge.\n */\nfunction mergeMetrics (type, name, metrics, params, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  if (!bucket.metrics) {\n    bucket.metrics = metrics\n    return\n  }\n\n  var oldMetrics = bucket.metrics\n  oldMetrics.count += metrics.count\n\n  // iterate through each new metric and merge\n  mapOwn(metrics, function (key, value) {\n    // count is a special case handled above\n    if (key === 'count') return\n\n    var oldMetric = oldMetrics[key]\n    var newMetric = metrics[key]\n\n    // handling the case where newMetric is a single-value first\n    if (newMetric && !newMetric.c) {\n      oldMetrics[key] = updateMetric(newMetric.t, oldMetric)\n    } else { // newMetric is a metric object\n      oldMetrics[key] = mergeMetric(newMetric, oldMetrics[key])\n    }\n  })\n}\n\nfunction mergeMetric(newMetric, oldMetric) {\n  if (!oldMetric) return newMetric\n\n  if (!oldMetric.c) {\n    // oldMetric is a single-value\n    oldMetric = createMetricObject(oldMetric.t)\n  }\n\n  oldMetric.min = Math.min(newMetric.min, oldMetric.min)\n  oldMetric.max = Math.max(newMetric.max, oldMetric.max)\n  oldMetric.t += newMetric.t\n  oldMetric.sos += newMetric.sos\n  oldMetric.c += newMetric.c\n\n  return oldMetric\n}\n\n// take a value and create a metric object\nfunction createMetricObject (value) {\n  return {\n    t: value,\n    min: value,\n    max: value,\n    sos: value * value,\n    c: 1\n  }\n}\n\nfunction getBucket (type, name, params, customParams) {\n  if (!aggregatedData[type]) aggregatedData[type] = {}\n  var bucket = aggregatedData[type][name]\n  if (!bucket) {\n    bucket = aggregatedData[type][name] = { params: params || {} }\n    if (customParams) {\n      bucket.custom = customParams\n    }\n  }\n  return bucket\n}\n\nfunction get (type, name) {\n  // if name is passed, get a single bucket\n  if (name) return aggregatedData[type] && aggregatedData[type][name]\n  // else, get all buckets of that type\n  return aggregatedData[type]\n}\n\n// Like get, but for many types and it deletes the retrieved content from the aggregatedData\nfunction take (types) {\n  var results = {}\n  var type = ''\n  var hasData = false\n  for (var i = 0; i < types.length; i++) {\n    type = types[i]\n    results[type] = toArray(aggregatedData[type])\n    if (results[type].length) hasData = true\n    delete aggregatedData[type]\n  }\n  return hasData ? results : null\n}\n\nfunction toArray (obj) {\n  if (typeof obj !== 'object') return []\n\n  return mapOwn(obj, getValue)\n}\n\nfunction getValue (key, value) {\n  return value\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar register = require(17)\nvar harvest = require(10)\nvar agg = require(2)\nvar single = require(19)\nvar submitData = require(23)\nvar mapOwn = require(44)\nvar loader = require(\"loader\")\nvar handle = require(\"handle\")\nvar config = require(39)\nvar cycle = 0\n\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\nharvest.on('jserrors', function () {\n  return { qs: agg.take([ 'cm' ]) }\n})\n\nvar api = {\n  finished: single(finished),\n  setPageViewName: setPageViewName,\n  setErrorHandler: setErrorHandler,\n  addToTrace: addToTrace,\n  inlineHit: inlineHit,\n  addRelease: addRelease\n}\n\n// Hook all of the api functions up to the queues/stubs created in loader/api.js\nmapOwn(api, function (fnName, fn) {\n  register('api-' + fnName, fn, 'api')\n})\n\n// All API functions get passed the time they were called as their\n// first parameter. These functions can be called asynchronously.\n\nfunction setPageViewName (t, name, host) {\n  if (typeof name !== 'string') return\n  if (name.charAt(0) !== '/') name = '/' + name\n  loader.customTransaction = (host || 'http://custom.transaction') + name\n}\n\nfunction finished (t, providedTime) {\n  var time = providedTime ? providedTime - loader.offset : t\n  agg.store('cm', 'finished', { name: 'finished' }, { time: time })\n  addToTrace(t, { name: 'finished', start: time + loader.offset, origin: 'nr' })\n  handle('api-addPageAction', [ time, 'finished' ])\n}\n\nfunction addToTrace (t, evt) {\n  if (!(evt && typeof evt === 'object' && evt.name && evt.start)) return\n\n  var report = {\n    n: evt.name,\n    s: evt.start - loader.offset,\n    e: (evt.end || evt.start) - loader.offset,\n    o: evt.origin || '',\n    t: 'api'\n  }\n\n  handle('bstApi', [report])\n}\n\n// NREUM.inlineHit(request_name, queue_time, app_time, total_be_time, dom_time, fe_time)\n//\n// request_name - the 'web page' name or service name\n// queue_time - the amount of time spent in the app tier queue\n// app_time - the amount of time spent in the application code\n// total_be_time - the total roundtrip time of the remote service call\n// dom_time - the time spent processing the result of the service call (or user defined)\n// fe_time - the time spent rendering the result of the service call (or user defined)\nfunction inlineHit (t, request_name, queue_time, app_time, total_be_time, dom_time, fe_time) {\n  request_name = window.encodeURIComponent(request_name)\n  cycle += 1\n\n  if (!loader.info.beacon) return\n\n  var url = scheme + '://' + loader.info.beacon + '/1/' + loader.info.licenseKey\n\n  url += '?a=' + loader.info.applicationID + '&'\n  url += 't=' + request_name + '&'\n  url += 'qt=' + ~~queue_time + '&'\n  url += 'ap=' + ~~app_time + '&'\n  url += 'be=' + ~~total_be_time + '&'\n  url += 'dc=' + ~~dom_time + '&'\n  url += 'fe=' + ~~fe_time + '&'\n  url += 'c=' + cycle\n\n  submitData.img(url)\n}\n\nfunction setErrorHandler (t, handler) {\n  loader.onerror = handler\n}\n\nvar releaseCount = 0\nfunction addRelease (t, name, id) {\n  if (++releaseCount > 10) return\n  loader.releaseIds[name.slice(-200)] = ('' + id).slice(-200)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar stringify = require(22)\n\nvar hasOwnProp = Object.prototype.hasOwnProperty\nvar MAX_ATTRIBUTES = 64\n\nmodule.exports = {\n  nullable: nullable,\n  numeric: numeric,\n  getAddStringContext: getAddStringContext,\n  addCustomAttributes: addCustomAttributes\n}\n\nfunction nullable (val, fn, comma) {\n  return val || val === 0 || val === ''\n    ? fn(val) + (comma ? ',' : '')\n    : '!'\n}\n\nfunction numeric (n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36)\n  }\n  return (n === undefined || n === 0) ? '' : Math.floor(n).toString(36)\n}\n\nfunction getAddStringContext () {\n  var stringTable = Object.hasOwnProperty('create') ? Object.create(null) : {}\n  var stringTableIdx = 0\n\n  return addString\n\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return ''\n    str = String(str)\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true)\n    } else {\n      stringTable[str] = stringTableIdx++\n      return quoteString(str)\n    }\n  }\n}\n\nfunction addCustomAttributes (attrs, addString) {\n  var attrParts = []\n\n  mapOwn(attrs, function (key, val) {\n    if (attrParts.length >= MAX_ATTRIBUTES) return\n    var type = 5\n    var serializedValue\n    // add key to string table first\n    key = addString(key)\n\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val))\n        } else {\n          // null attribute type\n          type = 9\n        }\n        break\n      case 'number':\n        type = 6\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.'\n        break\n      case 'boolean':\n        type = val ? 7 : 8\n        break\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9\n        break\n      default:\n        serializedValue = addString(val)\n    }\n\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')])\n  })\n\n  return attrParts\n}\n\nvar escapable = /([,\\\\;])/g\n\nfunction quoteString (str) {\n  return \"'\" + str.replace(escapable, '\\\\$1')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar withHash = /([^?#]*)[^#]*(#[^?]*|$).*/\nvar withoutHash = /([^?#]*)().*/\nmodule.exports = function cleanURL (url, keepHash) {\n  return url.replace(keepHash ? withHash : withoutHash, '$1$2')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar baseEE = require(\"ee\")\nvar mapOwn = require(44)\nvar handlers = require(17).handlers\n\nmodule.exports = function drain (group) {\n  var bufferedEventsInGroup = baseEE.backlog[group]\n  var groupHandlers = handlers[group]\n  if (groupHandlers) {\n    // don't cache length, buffer can grow while processing\n    for (var i = 0; bufferedEventsInGroup && i < bufferedEventsInGroup.length; ++i) { // eslint-disable-line no-unmodified-loop-condition\n      emitEvent(bufferedEventsInGroup[i], groupHandlers)\n    }\n\n    mapOwn(groupHandlers, function (eventType, handlerRegistrationList) {\n      mapOwn(handlerRegistrationList, function (i, registration) {\n        // registration is an array of: [targetEE, eventHandler]\n        registration[0].on(eventType, registration[1])\n      })\n    })\n  }\n\n  delete handlers[group]\n  // Keep the group as a property so we know it was created and drained\n  baseEE.backlog[group] = null\n}\n\nfunction emitEvent (evt, groupHandlers) {\n  var type = evt[1]\n  mapOwn(groupHandlers[type], function (i, registration) {\n    var sourceEE = evt[0]\n    var ee = registration[0]\n    if (ee === sourceEE) {\n      var handler = registration[1]\n      var ctx = evt[3]\n      var args = evt[2]\n      handler.apply(ctx, args)\n    }\n  })\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar stringify = require(22)\n\n  // Characters that are safe in a qs, but get encoded.\nvar charMap = {\n  '%2C': ',',\n  '%3A': ':',\n  '%2F': '/',\n  '%40': '@',\n  '%24': '$',\n  '%3B': ';'\n}\n\nvar charList = mapOwn(charMap, function (k) { return k })\nvar safeEncoded = new RegExp(charList.join('|'), 'g')\n\nfunction real (c) {\n  return charMap[c]\n}\n\n// Encode as URI Component, then unescape anything that is ok in the\n// query string position.\nfunction qs (value) {\n  if (value === null || value === undefined) return 'null'\n  return encodeURIComponent(value).replace(safeEncoded, real)\n}\n\nmodule.exports = {obj: obj, fromArray: fromArray, qs: qs, param: param}\n\nfunction fromArray (qs, maxBytes) {\n  var bytes = 0\n  for (var i = 0; i < qs.length; i++) {\n    bytes += qs[i].length\n    if (bytes > maxBytes) return qs.slice(0, i).join('')\n  }\n  return qs.join('')\n}\n\nfunction obj (payload, maxBytes) {\n  var total = 0\n  var result = ''\n\n  mapOwn(payload, function (feature, dataArray) {\n    var intermediate = []\n    var next\n    var i\n\n    if (typeof dataArray === 'string') {\n      next = '&' + feature + '=' + qs(dataArray)\n      total += next.length\n      result += next\n    } else if (dataArray.length) {\n      total += 9\n      for (i = 0; i < dataArray.length; i++) {\n        next = qs(stringify(dataArray[i]))\n        total += next.length\n        if (typeof maxBytes !== 'undefined' && total >= maxBytes) break\n        intermediate.push(next)\n      }\n      result += '&' + feature + '=%5B' + intermediate.join(',') + '%5D'\n    }\n  })\n  return result\n}\n\n// Constructs an HTTP parameter to add to the BAM router URL\nfunction param (name, value) {\n  if (value && typeof (value) === 'string') {\n    return '&' + name + '=' + qs(value)\n  }\n  return ''\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar ee = require(\"ee\")\nvar drain = require(6)\n\nmodule.exports = function activateFeatures (flags) {\n  if (!(flags && typeof flags === 'object')) return\n  mapOwn(flags, function (flag, val) {\n    if (!val || activatedFeatures[flag]) return\n    ee.emit('feat-' + flag, [])\n    activatedFeatures[flag] = true\n  })\n\n  drain('feature')\n}\n\nvar activatedFeatures = module.exports.active = {}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar harvest = require(10)\nvar submitData = require(23)\n\nmodule.exports = HarvestScheduler\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nfunction HarvestScheduler(loader, endpoint, opts) {\n  this.loader = loader\n  this.endpoint = endpoint\n  this.opts = opts || {}\n  this.started = false\n  this.timeoutHandle = null\n}\n\nHarvestScheduler.prototype.startTimer = function startTimer(interval, initialDelay) {\n  this.interval = interval\n  this.started = true\n  this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval)\n}\n\nHarvestScheduler.prototype.stopTimer = function stopTimer() {\n  this.started = false\n  if (this.timeoutHandle) {\n    clearTimeout(this.timeoutHandle)\n  }\n}\n\nHarvestScheduler.prototype.scheduleHarvest = function scheduleHarvest(delay, opts) {\n  if (this.timeoutHandle) return\n  var timer = this\n\n  if (delay == null) {\n    delay = this.interval\n  }\n  this.timeoutHandle = setTimeout(function() {\n    timer.timeoutHandle = null\n    timer.runHarvest(opts)\n  }, delay * 1000)\n}\n\nHarvestScheduler.prototype.runHarvest = function runHarvest(opts) {\n  var scheduler = this\n\n  if (this.opts.getPayload) {\n    var submitMethod = harvest.getSubmitMethod(this.endpoint)\n    if (!submitMethod) return false\n\n    var retry = submitMethod.method === submitData.xhr\n    var payload = this.opts.getPayload({ retry: retry })\n    if (payload) {\n      harvest.send(this.endpoint, this.loader, payload, opts, submitMethod, onHarvestFinished)\n    }\n  } else {\n    harvest.sendX(this.endpoint, this.loader, opts, onHarvestFinished)\n  }\n\n  if (this.started) {\n    this.scheduleHarvest()\n  }\n\n  function onHarvestFinished(result) {\n    scheduler.onHarvestFinished(opts, result)\n  }\n}\n\nHarvestScheduler.prototype.onHarvestFinished = function onHarvestFinished(opts, result) {\n  if (this.opts.onFinished) {\n    this.opts.onFinished(result)\n  }\n\n  if (result.sent && result.retry) {\n    var delay = result.delay || this.opts.retryDelay\n    // reschedule next harvest if should be delayed longer\n    if (this.started && delay) {\n      clearTimeout(this.timeoutHandle)\n      this.timeoutHandle = null\n      this.scheduleHarvest(delay, opts)\n    } else if (!this.started && delay) {\n      // if not running on a timer, schedule a single retry\n      this.scheduleHarvest(delay, opts)\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar single = require(19)\nvar mapOwn = require(44)\nvar timing = require(15)\nvar encode = require(7)\nvar stringify = require(22)\nvar submitData = require(23)\nvar reduce = require(47)\nvar aggregator = require(2)\nvar stopwatch = require(21)\nvar locationUtil = require(13)\nvar config = require(39)\n\nvar cleanURL = require(5)\n\nvar version = 'DEVELOPMENT'\nvar jsonp = 'NREUM.setToken'\nvar _events = {}\nvar haveSendBeacon = !!navigator.sendBeacon\nvar tooManyRequestsDelay = config.getConfiguration('harvest.tooManyRequestsDelay') || 60\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\n// requiring ie version updates the IE version on the loader object\nvar ieVersion = require(11)\nvar xhrUsable = ieVersion > 9 || ieVersion === 0\n\nvar addPaintMetric = require(16).addMetric\n\nmodule.exports = {\n  sendRUM: single(sendRUM), // wrapping this in single makes it so that it can only be called once from outside\n  sendFinal: sendAllFromUnload,\n  pingErrors: pingErrors,\n  sendX: sendX,\n  send: send,\n  on: on,\n  xhrUsable: xhrUsable,\n  resetListeners: resetListeners,\n  getSubmitMethod: getSubmitMethod\n}\n\n// nr is injected into all send methods. This allows for easier testing\n// we could require('loader') instead\nfunction sendRUM (nr) {\n  if (!nr.info.beacon) return\n  if (nr.info.queueTime) aggregator.store('measures', 'qt', { value: nr.info.queueTime })\n  if (nr.info.applicationTime) aggregator.store('measures', 'ap', { value: nr.info.applicationTime })\n\n  // some time in the past some code will have called stopwatch.mark('starttime', Date.now())\n  // calling measure like this will create a metric that measures the time differential between\n  // the two marks.\n  stopwatch.measure('be', 'starttime', 'firstbyte')\n  stopwatch.measure('fe', 'firstbyte', 'onload')\n  stopwatch.measure('dc', 'firstbyte', 'domContent')\n\n  var measuresMetrics = aggregator.get('measures')\n\n  var measuresQueryString = mapOwn(measuresMetrics, function (metricName, measure) {\n    return '&' + metricName + '=' + measure.params.value\n  }).join('')\n\n  if (measuresQueryString) {\n    // currently we only have one version of our protocol\n    // in the future we may add more\n    var protocol = '1'\n\n    var chunksForQueryString = [baseQueryString(nr)]\n\n    chunksForQueryString.push(measuresQueryString)\n\n    chunksForQueryString.push(encode.param('tt', nr.info.ttGuid))\n    chunksForQueryString.push(encode.param('us', nr.info.user))\n    chunksForQueryString.push(encode.param('ac', nr.info.account))\n    chunksForQueryString.push(encode.param('pr', nr.info.product))\n    chunksForQueryString.push(encode.param('af', mapOwn(nr.features, function (k) { return k }).join(',')))\n\n    if (window.performance && typeof (window.performance.timing) !== 'undefined') {\n      var navTimingApiData = ({\n        timing: timing.addPT(window.performance.timing, {}),\n        navigation: timing.addPN(window.performance.navigation, {})\n      })\n      chunksForQueryString.push(encode.param('perf', stringify(navTimingApiData)))\n    }\n\n    if (window.performance && window.performance.getEntriesByType) {\n      var entries = window.performance.getEntriesByType('paint')\n      if (entries && entries.length > 0) {\n        entries.forEach(function(entry) {\n          if (!entry.startTime || entry.startTime <= 0) return\n\n          if (entry.name === 'first-paint') {\n            chunksForQueryString.push(encode.param('fp',\n              String(Math.floor(entry.startTime))))\n          } else if (entry.name === 'first-contentful-paint') {\n            chunksForQueryString.push(encode.param('fcp',\n              String(Math.floor(entry.startTime))))\n          }\n          addPaintMetric(entry.name, Math.floor(entry.startTime))\n        })\n      }\n    }\n\n    chunksForQueryString.push(encode.param('xx', nr.info.extra))\n    chunksForQueryString.push(encode.param('ua', nr.info.userAttributes))\n    chunksForQueryString.push(encode.param('at', nr.info.atts))\n\n    var customJsAttributes = stringify(nr.info.jsAttributes)\n    chunksForQueryString.push(encode.param('ja', customJsAttributes === '{}' ? null : customJsAttributes))\n\n    var queryString = encode.fromArray(chunksForQueryString, nr.maxBytes)\n\n    submitData.jsonp(\n      scheme + '://' + nr.info.beacon + '/' + protocol + '/' + nr.info.licenseKey + queryString,\n      jsonp\n    )\n  }\n}\n\nfunction sendAllFromUnload (nr) {\n  var sents = mapOwn(_events, function (endpoint) {\n    return sendX(endpoint, nr, { unload: true })\n  })\n  return reduce(sents, or)\n}\n\nfunction or (a, b) { return a || b }\n\nfunction createPayload (type, options) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  var listeners = (_events[type] && _events[type] || [])\n\n  for (var i = 0; i < listeners.length; i++) {\n    var singlePayload = listeners[i](options)\n    if (!singlePayload) continue\n    if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n    if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n  }\n  return { body: makeBody(), qs: makeQueryString() }\n}\n\n/**\n * Initiate a harvest from multiple sources. An event that corresponds to the endpoint\n * name is emitted, which gives any listeners the opportunity to provide payload data.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction sendX (endpoint, nr, opts, cbFinished) {\n  var submitMethod = getSubmitMethod(endpoint, opts)\n  if (!submitMethod) return false\n  var options = {\n    retry: submitMethod.method === submitData.xhr\n  }\n  return _send(endpoint, nr, createPayload(endpoint, options), opts, submitMethod, cbFinished)\n}\n\n/**\n * Initiate a harvest call.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} singlePayload - Object representing payload.\n * @param {object} singlePayload.qs - Map of values that should be sent as part of the request query string.\n * @param {string} singlePayload.body - String that should be sent as the body of the request.\n * @param {string} singlePayload.body.e - Special case of body used for browser interactions.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction send (endpoint, nr, singlePayload, opts, submitMethod, cbFinished) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n  if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n\n  var payload = { body: makeBody(), qs: makeQueryString() }\n  return _send(endpoint, nr, payload, opts, submitMethod, cbFinished)\n}\n\nfunction _send (endpoint, nr, payload, opts, submitMethod, cbFinished) {\n  if (!nr.info.errorBeacon) return false\n\n  // custom metrics data (cm) is sent as a query parameter to /jserrors\n  if (!payload.body && !(endpoint === 'jserrors' && payload.qs && payload.qs.cm)) {\n    if (cbFinished) {\n      cbFinished({ sent: false })\n    }\n    return false\n  }\n\n  if (!opts) opts = {}\n\n  var url = scheme + '://' + nr.info.errorBeacon + '/' + endpoint + '/1/' + nr.info.licenseKey + baseQueryString(nr)\n  if (payload.qs) url += encode.obj(payload.qs, nr.maxBytes)\n\n  if (!submitMethod) {\n    submitMethod = getSubmitMethod(endpoint, opts)\n  }\n  var method = submitMethod.method\n  var useBody = submitMethod.useBody\n\n  var body\n  var fullUrl = url\n  if (useBody && endpoint === 'events') {\n    body = payload.body.e\n  } else if (useBody) {\n    body = stringify(payload.body)\n  } else {\n    fullUrl = url + encode.obj(payload.body, nr.maxBytes)\n  }\n\n  var result = method(fullUrl, body)\n\n  if (cbFinished && method === submitData.xhr) {\n    var xhr = result\n    xhr.addEventListener('load', function () {\n      var result = { sent: true }\n      if (this.status === 429) {\n        result.retry = true\n        result.delay = tooManyRequestsDelay\n      } else if (this.status === 408 || this.status === 500 || this.status === 503) {\n        result.retry = true\n      }\n\n      if (opts.needResponse) {\n        result.responseText = this.responseText\n      }\n      cbFinished(result)\n    }, false)\n  }\n\n  // if beacon request failed, retry with an alternative method\n  if (!result && method === submitData.beacon) {\n    method = submitData.img\n    result = method(url + encode.obj(payload.body, nr.maxBytes))\n  }\n\n  return result\n}\n\nfunction getSubmitMethod(endpoint, opts) {\n  opts = opts || {}\n  var method\n  var useBody\n\n  if (opts.needResponse) {\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else {\n      return false\n    }\n  } else if (opts.unload) {\n    useBody = haveSendBeacon\n    method = haveSendBeacon ? submitData.beacon : submitData.img\n  } else {\n    // `submitData.beacon` was removed, there is an upper limit to the\n    // number of data allowed before it starts failing, so we save it for\n    // unload data\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else if (endpoint === 'events' || endpoint === 'jserrors') {\n      method = submitData.img\n    } else {\n      return false\n    }\n  }\n\n  return {\n    method: method,\n    useBody: useBody\n  }\n}\n\nfunction pingErrors (nr) {\n  if (scheme === 'http' || !(nr && nr.info && nr.info.errorBeacon && nr.ieVersion)) return\n\n  var url = 'https://' + nr.info.errorBeacon + '/jserrors/ping/' + nr.info.licenseKey + baseQueryString(nr)\n\n  submitData.img(url)\n}\n\n// Constructs the transaction name param for the beacon URL.\n// Prefers the obfuscated transaction name over the plain text.\n// Falls back to making up a name.\nfunction transactionNameParam (nr) {\n  if (nr.info.transactionName) return encode.param('to', nr.info.transactionName)\n  return encode.param('t', nr.info.tNamePlain || 'Unnamed Transaction')\n}\n\nfunction on (type, listener) {\n  var listeners = (_events[type] || (_events[type] = []))\n  listeners.push(listener)\n}\n\nfunction resetListeners() {\n  mapOwn(_events, function(key) {\n    _events[key] = []\n  })\n}\n\n// The stuff that gets sent every time.\nfunction baseQueryString (nr) {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  return ([\n    '?a=' + nr.info.applicationID,\n    encode.param('sa', (nr.info.sa ? '' + nr.info.sa : '')),\n    encode.param('v', version),\n    transactionNameParam(nr),\n    encode.param('ct', nr.customTransaction),\n    '&rst=' + nr.now(),\n    '&ck=' + (areCookiesEnabled ? '1' : '0'),\n    encode.param('ref', cleanURL(locationUtil.getLocation()))\n  ].join(''))\n}\n\n// returns a function that can be called to accumulate values to a single object\n// when the function is called without parameters, then the accumulator is returned\nfunction createAccumulator () {\n  var accumulator = {}\n  var hasData = false\n  return function (key, val) {\n    if (val && val.length) {\n      accumulator[key] = val\n      hasData = true\n    }\n    if (hasData) return accumulator\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar div = document.createElement('div')\n\ndiv.innerHTML = '<!--[if lte IE 6]><div></div><![endif]-->' +\n  '<!--[if lte IE 7]><div></div><![endif]-->' +\n  '<!--[if lte IE 8]><div></div><![endif]-->' +\n  '<!--[if lte IE 9]><div></div><![endif]-->'\n\nvar len = div.getElementsByTagName('div').length\n\nvar ieVersion\nif (len === 4) ieVersion = 6\nelse if (len === 3) ieVersion = 7\nelse if (len === 2) ieVersion = 8\nelse if (len === 1) ieVersion = 9\nelse ieVersion = 0\n\nmodule.exports = ieVersion\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stopwatch = require(21)\nvar subscribeToUnload = require(25)\nvar harvest = require(10)\nvar registerHandler = require(17)\nvar activateFeatures = require(8)\nvar loader = require(\"loader\")\nvar drain = require(6)\nvar navCookie = require(14)\nvar config = require(39)\n\n// api loads registers several event listeners, but does not have any exports\nrequire(3)\n\n// Register event listeners and schedule harvests for performance timings.\nrequire(24).init(loader, config.getConfiguration('page_view_timing'))\n\nvar autorun = typeof (window.NREUM.autorun) !== 'undefined' ? window.NREUM.autorun : true\n\n// Features are activated using the legacy setToken function name via JSONP\nwindow.NREUM.setToken = activateFeatures\n\nif (require(11) === 6) loader.maxBytes = 2000\nelse loader.maxBytes = 30000\n\nloader.releaseIds = {}\n\nsubscribeToUnload(finalHarvest)\n\nregisterHandler('mark', stopwatch.mark, 'api')\n\nstopwatch.mark('done')\n\ndrain('api')\n\nif (autorun) harvest.sendRUM(loader)\n\n// Set a cookie when the page unloads. Consume this cookie on the next page to get a 'start time'.\n// The navigation start time cookie is removed when the browser supports the web timing API.\n// Doesn't work in some browsers (Opera).\nfunction finalHarvest (e) {\n  harvest.sendFinal(loader, false)\n  // write navigation start time cookie if needed\n  navCookie.conditionallySet()\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getLocation: getLocation\n}\n\nfunction getLocation() {\n  return '' + location\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar sHash = require(18)\nvar startTime = require(20)\n\n// functions are on object, so that they can be mocked\nvar exp = {\n  conditionallySet: conditionallySet,\n  setCookie: setCookie\n}\n\nmodule.exports = exp\n\nfunction conditionallySet() {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  if (startTime.navCookie && areCookiesEnabled) {\n    exp.setCookie()\n  }\n}\n\nfunction setCookie() {\n  document.cookie = 'NREUM=s=' + Number(new Date()) + '&r=' + sHash(document.location.href) + '&p=' + sHash(document.referrer) + '; path=/'\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\n\nvar START = 'Start'\nvar END = 'End'\nvar UNLOAD_EVENT = 'unloadEvent'\nvar REDIRECT = 'redirect'\nvar DOMAIN_LOOKUP = 'domainLookup'\nvar ONNECT = 'onnect'\nvar REQUEST = 'request'\nvar RESPONSE = 'response'\nvar LOAD_EVENT = 'loadEvent'\nvar DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent'\n\nvar navTimingValues = []\nmodule.exports = {\n  addPT: addPT,\n  addPN: addPN,\n  nt: navTimingValues\n}\n\nfunction addPT (pt, v) {\n  var offset = pt['navigation' + START]\n  v.of = offset\n  addRel(offset, offset, v, 'n')\n  addRel(pt[UNLOAD_EVENT + START], offset, v, 'u')\n  addRel(pt[REDIRECT + START], offset, v, 'r')\n  addRel(pt[UNLOAD_EVENT + END], offset, v, 'ue')\n  addRel(pt[REDIRECT + END], offset, v, 're')\n  addRel(pt['fetch' + START], offset, v, 'f')\n  addRel(pt[DOMAIN_LOOKUP + START], offset, v, 'dn')\n  addRel(pt[DOMAIN_LOOKUP + END], offset, v, 'dne')\n  addRel(pt['c' + ONNECT + START], offset, v, 'c')\n  addRel(pt['secureC' + ONNECT + 'ion' + START], offset, v, 's')\n  addRel(pt['c' + ONNECT + END], offset, v, 'ce')\n  addRel(pt[REQUEST + START], offset, v, 'rq')\n  addRel(pt[RESPONSE + START], offset, v, 'rp')\n  addRel(pt[RESPONSE + END], offset, v, 'rpe')\n  addRel(pt.domLoading, offset, v, 'dl')\n  addRel(pt.domInteractive, offset, v, 'di')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + START], offset, v, 'ds')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + END], offset, v, 'de')\n  addRel(pt.domComplete, offset, v, 'dc')\n  addRel(pt[LOAD_EVENT + START], offset, v, 'l')\n  addRel(pt[LOAD_EVENT + END], offset, v, 'le')\n  return v\n}\n\n// Add Performance Navigation values to the given object\nfunction addPN (pn, v) {\n  addRel(pn.type, 0, v, 'ty')\n  addRel(pn.redirectCount, 0, v, 'rc')\n  return v\n}\n\nfunction addRel (value, offset, obj, prop) {\n  var relativeValue\n  if (typeof (value) === 'number' && (value > 0)) {\n    relativeValue = Math.round(value - offset)\n    obj[prop] = relativeValue\n  }\n  navTimingValues.push(relativeValue)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar paintMetrics = {}\n\nmodule.exports = {\n  addMetric: addMetric,\n  metrics: paintMetrics\n}\n\nfunction addMetric (name, value) {\n  paintMetrics[name] = value\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handleEE = require(\"handle\").ee\n\nmodule.exports = defaultRegister\n\ndefaultRegister.on = registerWithSpecificEmitter\n\nvar handlers = defaultRegister.handlers = {}\n\nfunction defaultRegister (type, handler, group, ee) {\n  registerWithSpecificEmitter(ee || handleEE, type, handler, group)\n}\n\nfunction registerWithSpecificEmitter (ee, type, handler, group) {\n  if (!group) group = 'feature'\n  if (!ee) ee = handleEE\n  var groupHandlers = handlers[group] = handlers[group] || {}\n  var list = groupHandlers[type] = groupHandlers[type] || []\n  list.push([ee, handler])\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = sHash\n\nfunction sHash (s) {\n  var i\n  var h = 0\n\n  for (i = 0; i < s.length; i++) {\n    h += ((i + 1) * s.charCodeAt(i))\n  }\n  return Math.abs(h)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar slice = require(45)\n\nmodule.exports = single\n\nfunction single (fn) {\n  var called = false\n  var res\n\n  return function () {\n    if (called) return res\n    called = true\n    res = fn.apply(this, slice(arguments))\n    return res\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Use various techniques to determine the time at which this page started and whether to capture navigation timing information\n\nvar sHash = require(18)\nvar stopwatch = require(21)\nvar loader = require(\"loader\")\nvar ffVersion = require(41)\n\nmodule.exports = { navCookie: true }\n\nfindStartTime()\n\nfunction findStartTime () {\n  var starttime = findStartWebTiming() || findStartCookie()\n\n  if (!starttime) return\n\n  stopwatch.mark('starttime', starttime)\n  // Refine loader.offset\n  loader.offset = starttime\n}\n\n// Find the start time from the Web Timing 'performance' object.\n// http://test.w3.org/webperf/specs/NavigationTiming/\n// http://blog.chromium.org/2010/07/do-you-know-how-slow-your-web-page-is.html\nfunction findStartWebTiming () {\n  // FF 7/8 has a bug with the navigation start time, so use cookie instead of native interface\n  if (ffVersion && ffVersion < 9) return\n\n  var performanceCheck = require(46)\n  if (performanceCheck.exists) {\n    // note that we don't need to use a cookie to record navigation start time\n    module.exports.navCookie = false\n    return window.performance.timing.navigationStart\n  }\n}\n\n// Find the start time based on a cookie set by Episodes in the unload handler.\nfunction findStartCookie () {\n  var aCookies = document.cookie.split(' ')\n\n  for (var i = 0; i < aCookies.length; i++) {\n    if (aCookies[i].indexOf('NREUM=') === 0) {\n      var startPage\n      var referrerPage\n      var aSubCookies = aCookies[i].substring('NREUM='.length).split('&')\n      var startTime\n      var bReferrerMatch\n\n      for (var j = 0; j < aSubCookies.length; j++) {\n        if (aSubCookies[j].indexOf('s=') === 0) {\n          startTime = aSubCookies[j].substring(2)\n        } else if (aSubCookies[j].indexOf('p=') === 0) {\n          referrerPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (referrerPage.charAt(referrerPage.length - 1) === ';') {\n            referrerPage = referrerPage.substr(0, referrerPage.length - 1)\n          }\n        } else if (aSubCookies[j].indexOf('r=') === 0) {\n          startPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (startPage.charAt(startPage.length - 1) === ';') {\n            startPage = startPage.substr(0, startPage.length - 1)\n          }\n        }\n      }\n\n      if (startPage) {\n        var docReferrer = sHash(document.referrer)\n        bReferrerMatch = (docReferrer == startPage) // eslint-disable-line\n        if (!bReferrerMatch) {\n          // Navigation did not start at the page that was just exited, check for re-load\n          // (i.e. the page just exited is the current page and the referring pages match)\n          bReferrerMatch = sHash(document.location.href) == startPage && docReferrer == referrerPage // eslint-disable-line\n        }\n      }\n      if (bReferrerMatch && startTime) {\n        var now = new Date().getTime()\n        if ((now - startTime) > 60000) {\n          return\n        }\n        return startTime\n      }\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar aggregator = require(2)\nvar now = require(42)\n\nvar marks = {}\n\nmodule.exports = {\n  mark: mark,\n  measure: measure\n}\n\nfunction mark (markName, markTime) {\n  if (typeof markTime === 'undefined') markTime = (now() + now.offset)\n  marks[markName] = markTime\n}\n\nfunction measure (metricName, startMark, endMark) {\n  var start = marks[startMark]\n  var end = marks[endMark]\n\n  if (typeof start === 'undefined' || typeof end === 'undefined') return\n\n  aggregator.store('measures', metricName, { value: end - start })\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar ee = require(\"ee\")\n\nvar escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g // eslint-disable-line\nvar meta = {\n  '\\b': '\\\\b',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\f': '\\\\f',\n  '\\r': '\\\\r',\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\'\n}\n\nmodule.exports = stringify\n\nfunction stringify (val) {\n  try {\n    return str('', {'': val})\n  } catch (e) {\n    try {\n      ee.emit('internal-error', [e])\n    } catch (err) {\n    }\n  }\n}\n\nfunction quote (string) {\n  escapable.lastIndex = 0\n  return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n    var c = meta[a]\n    return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4)\n  }) + '\"' : '\"' + string + '\"'\n}\n\nfunction str (key, holder) {\n  var value = holder[key]\n\n  switch (typeof value) {\n    case 'string':\n      return quote(value)\n    case 'number':\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return String(value)\n    case 'object':\n      if (!value) { return 'null' }\n      var partial = []\n\n      // The value is an array. Stringify every element. Use null as a placeholder\n      // for non-JSON values.\n      if (value instanceof window.Array || Object.prototype.toString.apply(value) === '[object Array]') {\n        var length = value.length\n        for (var i = 0; i < length; i += 1) {\n          partial[i] = str(i, value) || 'null'\n        }\n\n        return partial.length === 0 ? '[]' : '[' + partial.join(',') + ']'\n      }\n\n      mapOwn(value, function (k) {\n        var v = str(k, value)\n        if (v) partial.push(quote(k) + ':' + v)\n      })\n\n      return partial.length === 0 ? '{}' : '{' + partial.join(',') + '}'\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar submitData = module.exports = {}\n\nsubmitData.jsonp = function jsonp (url, jsonp) {\n  var element = document.createElement('script')\n  element.type = 'text/javascript'\n  element.src = url + '&jsonp=' + jsonp\n  var firstScript = document.getElementsByTagName('script')[0]\n  firstScript.parentNode.insertBefore(element, firstScript)\n  return element\n}\n\nsubmitData.xhr = function xhr (url, body, sync) {\n  var request = new XMLHttpRequest()\n\n  request.open('POST', url, !sync)\n  try {\n    // Set cookie\n    if ('withCredentials' in request) request.withCredentials = true\n  } catch (e) {}\n\n  request.setRequestHeader('content-type', 'text/plain')\n  request.send(body)\n  return request\n}\n\nsubmitData.xhrSync = function xhrSync (url, body) {\n  return submitData.xhr(url, body, true)\n}\n\nsubmitData.img = function img (url) {\n  var element = new Image()\n  element.src = url\n  return element\n}\n\nsubmitData.beacon = function (url, body) {\n  return navigator.sendBeacon(url, body)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar nullable = require(4).nullable\nvar numeric = require(4).numeric\nvar getAddStringContext = require(4).getAddStringContext\nvar addCustomAttributes = require(4).addCustomAttributes\nvar now = require(42)\nvar mapOwn = require(44)\n\nvar loader = null\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar register = require(17)\nvar subscribeToUnload = require(25)\n\nvar timings = []\nvar timingsSent = []\nvar lcpRecorded = false\nvar lcp = null\nvar cls = null\nvar pageHideRecorded = false\n\nmodule.exports = {\n  getPayload: getPayload,\n  timings: timings,\n  init: init,\n  finalHarvest: finalHarvest\n}\n\nvar harvestTimeSeconds = 30\n\nfunction init(nr, options) {\n  if (!isEnabled(options)) return\n\n  loader = nr\n\n  if (!options) options = {}\n  var maxLCPTimeSeconds = options.maxLCPTimeSeconds || 60\n  var initialHarvestSeconds = options.initialHarvestSeconds || 10\n  harvestTimeSeconds = options.harvestTimeSeconds || 30\n\n  var scheduler = new HarvestScheduler(loader, 'events', { onFinished: onHarvestFinished, getPayload: prepareHarvest })\n\n  register('timing', processTiming)\n  register('lcp', updateLatestLcp)\n  register('cls', updateClsScore)\n  register('pageHide', updatePageHide)\n\n  // final harvest is initiated from the main agent module, but since harvesting\n  // here is not initiated by the harvester, we need to subscribe to the unload event\n  // separately\n  subscribeToUnload(finalHarvest)\n\n  // After 1 minute has passed, record LCP value if no user interaction has occurred first\n  setTimeout(function() {\n    recordLcp()\n    lcpRecorded = true\n  }, maxLCPTimeSeconds * 1000)\n\n  // send initial data sooner, then start regular\n  scheduler.startTimer(harvestTimeSeconds, initialHarvestSeconds)\n}\n\nfunction recordLcp() {\n  if (!lcpRecorded && lcp !== null) {\n    var lcpEntry = lcp[0]\n    var cls = lcp[1]\n\n    var attrs = {\n      'size': lcpEntry.size,\n      'eid': lcpEntry.id\n    }\n\n    if (cls) {\n      attrs['cls'] = cls\n    }\n\n    addTiming('lcp', Math.floor(lcpEntry.startTime), attrs, false)\n    lcpRecorded = true\n  }\n}\n\nfunction updateLatestLcp(lcpEntry) {\n  if (lcp) {\n    var previous = lcp[0]\n    if (previous.size >= lcpEntry.size) {\n      return\n    }\n  }\n  lcp = [lcpEntry, cls]\n}\n\nfunction updateClsScore(clsEntry) {\n  if (cls === null) {\n    cls = 0\n  }\n  cls += clsEntry.value\n}\n\nfunction updatePageHide(timestamp, state) {\n  if (!pageHideRecorded && state === 'hidden') {\n    addTiming('pageHide', timestamp, null, true)\n    pageHideRecorded = true\n  }\n}\n\nfunction recordUnload() {\n  addTiming('unload', now(), null, true)\n}\n\nfunction addTiming(name, value, attrs, addCls) {\n  attrs = attrs || {}\n\n  if (addCls && cls !== null) {\n    attrs['cls'] = cls\n  }\n\n  timings.push({\n    name: name,\n    value: value,\n    attrs: attrs\n  })\n}\n\nfunction processTiming(name, value, attrs) {\n  // Upon user interaction, the Browser stops executing LCP logic, so we can send here\n  // We're using setTimeout to give the Browser time to finish collecting LCP value\n  if (name === 'fi') {\n    setTimeout(recordLcp, 0)\n  }\n\n  addTiming(name, value, attrs, true)\n}\n\nfunction onHarvestFinished(result) {\n  if (result.retry && timingsSent.length > 0) {\n    for (var i = 0; i < timingsSent.length; i++) {\n      timings.push(timingsSent[i])\n    }\n    timingsSent = []\n  }\n}\n\nfunction finalHarvest() {\n  recordLcp()\n  recordUnload()\n  var payload = prepareHarvest({ retry: false })\n  harvest.send('events', loader, payload, { unload: true })\n}\n\nfunction appendGlobalCustomAttributes(timing) {\n  var timingAttributes = timing.attrs || {}\n  var customAttributes = loader.info.jsAttributes || {}\n\n  mapOwn(customAttributes, function (key, val) {\n    if (key !== 'size' && key !== 'eid' && key !== 'cls' && key !== 'type' && key !== 'fid') {\n      timingAttributes[key] = val\n    }\n  })\n}\n\n// serialize and return current timing data, clear and save current data for retry\nfunction prepareHarvest(options) {\n  if (timings.length === 0) return\n\n  var payload = getPayload(timings)\n  if (options.retry) {\n    for (var i = 0; i < timings.length; i++) {\n      timingsSent.push(timings[i])\n    }\n  }\n  timings = []\n  return { body: { e: payload } }\n}\n\n// serialize array of timing data\nfunction getPayload(data) {\n  var addString = getAddStringContext()\n\n  var payload = 'bel.6;'\n\n  for (var i = 0; i < data.length; i++) {\n    var timing = data[i]\n\n    payload += 'e,'\n    payload += addString(timing.name) + ','\n    payload += nullable(timing.value, numeric, false) + ','\n\n    appendGlobalCustomAttributes(timing)\n\n    var attrParts = addCustomAttributes(timing.attrs, addString)\n    if (attrParts && attrParts.length > 0) {\n      payload += numeric(attrParts.length) + ';' + attrParts.join(';')\n    }\n\n    if ((i + 1) < data.length) payload += ';'\n  }\n\n  return payload\n}\n\nfunction isEnabled(config) {\n  // collect page view timings unless the feature is explicitly disabled\n  if (config && config.enabled === false) {\n    return false\n  }\n  return true\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = require(41)\nvar single = require(19)\nvar addE = require(1)\n\nmodule.exports = subscribeToUnload\n\n// Used to subscribe a callback to when a page is being unloaded. This is used,\n// for example, to submit a final harvest.\nfunction subscribeToUnload (cb) {\n  var oneCall = single(cb)\n\n  // Firefox has a bug wherein a slow-loading resource loaded from the 'pagehide'\n  // or 'unload' event will delay the 'load' event firing on the next page load.\n  // In Firefox versions that support sendBeacon, this doesn't matter, because\n  // we'll use it instead of an image load for our final harvest.\n  //\n  // Some Safari versions never fire the 'unload' event for pages that are being\n  // put into the WebKit page cache, so we *need* to use the pagehide event for\n  // the final submission from Safari.\n  //\n  // Generally speaking, we will try to submit our final harvest from either\n  // pagehide or unload, whichever comes first, but in Firefox, we need to avoid\n  // attempting to submit from pagehide to ensure that we don't slow down loading\n  // of the next page.\n  if (!ffVersion || navigator.sendBeacon) {\n    addE('pagehide', oneCall)\n  } else {\n    addE('beforeunload', oneCall)\n  }\n  addE('unload', oneCall)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar canonicalFunctionNameRe = /([a-z0-9]+)$/i\nfunction canonicalFunctionName (orig) {\n  if (!orig) return\n\n  var match = orig.match(canonicalFunctionNameRe)\n  if (match) return match[1]\n\n  return\n}\n\nmodule.exports = canonicalFunctionName\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// computeStackTrace: cross-browser stack traces in JavaScript\n//\n// Syntax:\n//   s = computeStackTrace(exception) // consider using TraceKit.report instead\n// Returns:\n//   s.name              - exception name\n//   s.message           - exception message\n//   s.stack[i].url      - JavaScript or HTML file URL\n//   s.stack[i].func     - function name, or empty for anonymous functions\n//   s.stack[i].line     - line number, if known\n//   s.stack[i].column   - column number, if known\n//   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n//   s.mode              - 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace\n//\n// Supports:\n//   - Firefox:  full stack trace with line numbers and unreliable column\n//               number on top frame\n//   - Opera 10: full stack trace with line and column numbers\n//   - Opera 9-: full stack trace with line numbers\n//   - Chrome:   full stack trace with line and column numbers\n//   - Safari:   line and column number for the topmost stacktrace element\n//               only\n//   - IE:       no line numbers whatsoever\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n//\n// OPERA:\n// ex.message = ...message... (see the example below)\n// ex.name = ReferenceError\n// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\nvar reduce = require(47)\nvar formatStackTrace = require(28)\n\nvar has = Object.prototype.hasOwnProperty\nvar debug = false\n\nvar classNameRegex = /function (.+?)\\s*\\(/\nvar chrome = /^\\s*at (?:((?:\\[object object\\])?(?:[^(]*\\([^)]*\\))*[^()]*(?: \\[as \\S+\\])?) )?\\(?((?:file|http|https|chrome-extension):.*?)?:(\\d+)(?::(\\d+))?\\)?\\s*$/i\nvar gecko = /^\\s*(?:(\\S*|global code)(?:\\(.*?\\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\\d+)(?::(\\d+))?\\s*$/i\nvar chrome_eval = /^\\s*at .+ \\(eval at \\S+ \\((?:(?:file|http|https):[^)]+)?\\)(?:, [^:]*:\\d+:\\d+)?\\)$/i\nvar ie_eval = /^\\s*at Function code \\(Function code:\\d+:\\d+\\)\\s*/i\n\nmodule.exports = computeStackTrace\n\nfunction computeStackTrace (ex) {\n  var stack = null\n\n  try {\n    // This must be tried first because Opera 10 *destroys*\n    // its stacktrace property if you try to access the stack\n    // property first!!\n    stack = computeStackTraceFromStacktraceProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromStackProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromOperaMultiLineMessage(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceBySourceAndLine(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceWithMessageOnly(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  return {\n    'mode': 'failed',\n    'stackString': '',\n    'frames': []\n  }\n}\n\n/**\n * Computes stack trace information from the stack property.\n * Chrome and Gecko use this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStackProp (ex) {\n  if (!ex.stack) {\n    return null\n  }\n\n  var errorInfo = reduce(\n    ex.stack.split('\\n'),\n    parseStackProp,\n    {frames: [], stackLines: [], wrapperSeen: false}\n  )\n\n  if (!errorInfo.frames.length) return null\n\n  return {\n    'mode': 'stack',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(errorInfo.stackLines),\n    'frames': errorInfo.frames\n  }\n}\n\nfunction parseStackProp (info, line) {\n  var element = getElement(line)\n\n  if (!element) {\n    info.stackLines.push(line)\n    return info\n  }\n\n  if (isWrapper(element.func)) info.wrapperSeen = true\n  else info.stackLines.push(line)\n\n  if (!info.wrapperSeen) info.frames.push(element)\n  return info\n}\n\nfunction getElement (line) {\n  var parts = line.match(gecko)\n  if (!parts) parts = line.match(chrome)\n\n  if (parts) {\n    return ({\n      'url': parts[2],\n      'func': (parts[1] !== 'Anonymous function' && parts[1] !== 'global code' && parts[1]) || null,\n      'line': +parts[3],\n      'column': parts[4] ? +parts[4] : null\n    })\n  }\n\n  if (line.match(chrome_eval) || line.match(ie_eval) || line === 'anonymous') {\n    return { 'func': 'evaluated code' }\n  }\n}\n\nfunction computeStackTraceBySourceAndLine (ex) {\n  if (!('line' in ex)) return null\n\n  var className = ex.name || getClassName(ex)\n\n  // Safari does not provide a URL for errors in eval'd code\n  if (!ex.sourceURL) {\n    return ({\n      'mode': 'sourceline',\n      'name': className,\n      'message': ex.message,\n      'stackString': getClassName(ex) + ': ' + ex.message + '\\n    in evaluated code',\n      'frames': [{\n        'func': 'evaluated code'\n      }]\n    })\n  }\n\n  var stackString = className + ': ' + ex.message + '\\n    at ' + ex.sourceURL\n  if (ex.line) {\n    stackString += ':' + ex.line\n    if (ex.column) {\n      stackString += ':' + ex.column\n    }\n  }\n\n  return ({\n    'mode': 'sourceline',\n    'name': className,\n    'message': ex.message,\n    'stackString': stackString,\n    'frames': [{ 'url': ex.sourceURL,\n      'line': ex.line,\n      'column': ex.column\n    }]\n  })\n}\n\nfunction computeStackTraceWithMessageOnly (ex) {\n  var className = ex.name || getClassName(ex)\n  if (!className) return null\n\n  return ({\n    'mode': 'nameonly',\n    'name': className,\n    'message': ex.message,\n    'stackString': className + ': ' + ex.message,\n    'frames': []\n  })\n}\n\nfunction getClassName (obj) {\n  var results = classNameRegex.exec(String(obj.constructor))\n  return (results && results.length > 1) ? results[1] : 'unknown'\n}\n\nfunction isWrapper (functionName) {\n  return (functionName && functionName.indexOf('nrWrapper') >= 0)\n}\n\n/**\n * Computes stack trace information from the stacktrace property.\n * Opera 10 uses this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStacktraceProp (ex) {\n  if (!ex.stacktrace) {\n    return null\n  }\n\n  // Access and store the stacktrace property before doing anything\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = ex.stacktrace\n\n  var testRE = / line (\\d+), column (\\d+) in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\(.*\\) in (.*):\\s*$/i\n  var lines = stacktrace.split('\\n')\n  var frames = []\n  var stackLines = []\n  var parts\n  var wrapperSeen = false\n\n  for (var i = 0, j = lines.length; i < j; i += 2) {\n    if ((parts = testRE.exec(lines[i]))) {\n      var element = {\n        'line': +parts[1],\n        'column': +parts[2],\n        'func': parts[3] || parts[4],\n        'url': parts[5]\n      }\n\n      if (isWrapper(element.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(element)\n    } else {\n      stackLines.push(lines[i])\n    }\n  }\n\n  if (!frames.length) {\n    return null\n  }\n\n  return {\n    'mode': 'stacktrace',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n/**\n * Computes stack trace information from an error message that includes\n * the stack trace.\n * Opera 9 and earlier use this method if the option to show stack\n * traces is turned on in opera:config.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack information.\n */\nfunction computeStackTraceFromOperaMultiLineMessage (ex) {\n  // Opera includes a stack trace into the exception message. An example is:\n  //\n  // Statement on line 3: Undefined variable: undefinedFunc\n  // Backtrace:\n  //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz\n  //         undefinedFunc(a)\n  //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy\n  //           zzz(x, y, z)\n  //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx\n  //           yyy(a, a, a)\n  //   Line 1 of function script\n  //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }\n  //   ...\n\n  var lines = ex.message.split('\\n')\n  if (lines.length < 4) {\n    return null\n  }\n\n  var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i\n  var frames = []\n  var stackLines = []\n  var scripts = document.getElementsByTagName('script')\n  var inlineScriptBlocks = []\n  var parts\n  var i\n  var len\n  var wrapperSeen = false\n\n  for (i in scripts) {\n    if (has.call(scripts, i) && !scripts[i].src) {\n      inlineScriptBlocks.push(scripts[i])\n    }\n  }\n\n  for (i = 2, len = lines.length; i < len; i += 2) {\n    var item = null\n    if ((parts = lineRE1.exec(lines[i]))) {\n      item = {\n        'url': parts[2],\n        'func': parts[3],\n        'line': +parts[1]\n      }\n    } else if ((parts = lineRE2.exec(lines[i]))) {\n      item = {\n        'url': parts[3],\n        'func': parts[4]\n      }\n    } else if ((parts = lineRE3.exec(lines[i]))) {\n      var url = window.location.href.replace(/#.*$/, '')\n      var line = parts[1]\n\n      item = {\n        'url': url,\n        'line': line,\n        'func': ''\n      }\n    }\n\n    if (item) {\n      if (isWrapper(item.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(item)\n    }\n  }\n  if (!frames.length) {\n    return null // could not parse multiline exception message as Opera stack trace\n  }\n\n  return {\n    'mode': 'multiline',\n    'name': ex.name || getClassName(ex),\n    'message': lines[0],\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stripNewlinesRegex = /^\\n+|\\n+$/g\nvar MAX_STACK_TRACE_LENGTH = 65530\n\nmodule.exports = function (stackLines) {\n  return truncateStackLines(stackLines).replace(stripNewlinesRegex, '')\n}\n\nmodule.exports.truncateSize = truncateSize\n\n// takes array of stack lines and returns string with top 50 and buttom 50 lines\nfunction truncateStackLines(stackLines) {\n  var stackString\n  if (stackLines.length > 100) {\n    var truncatedLines = stackLines.length - 100\n    stackString = stackLines.slice(0, 50).join('\\n')\n    stackString += '\\n< ...truncated ' + truncatedLines + ' lines... >\\n'\n    stackString += stackLines.slice(-50).join('\\n')\n  } else {\n    stackString = stackLines.join('\\n')\n  }\n  return stackString\n}\n\n// truncates stack string to limit what is sent to backend\nfunction truncateSize(stackString) {\n  return (stackString.length > MAX_STACK_TRACE_LENGTH) ? stackString.substr(0, MAX_STACK_TRACE_LENGTH) : stackString\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar canonicalFunctionName = require(26)\nvar cleanURL = require(5)\nvar computeStackTrace = require(27)\nvar stringHashCode = require(30)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar stackReported = {}\nvar pageviewReported = {}\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar stringify = require(22)\nvar handle = require(\"handle\")\nvar baseEE = require(\"ee\")\nvar mapOwn = require(44)\nvar config = require(39)\nvar truncateSize = require(28).truncateSize\nvar errorCache = {}\nvar currentBody\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.err) return\nvar errorOnPage = false\n\nvar harvestTimeSeconds = config.getConfiguration('jserrors.harvestTimeSeconds') || 60\n\nee.on('feat-err', function () {\n  register('err', storeError)\n  register('ierr', storeError)\n\n  harvest.on('jserrors', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'jserrors', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds)\n})\n\nfunction onHarvestStarted(options) {\n  var body = agg.take([ 'err', 'ierr' ])\n\n  if (options.retry) {\n    currentBody = body\n  }\n\n  var payload = { body: body, qs: {} }\n  var releaseIds = stringify(loader.releaseIds)\n\n  if (releaseIds !== '{}') {\n    payload.qs.ri = releaseIds\n  }\n\n  if (body && body.err && body.err.length && !errorOnPage) {\n    payload.qs.pve = '1'\n    errorOnPage = true\n  }\n  return payload\n}\n\nfunction onHarvestFinished(result) {\n  if (!result.sent) {\n    // keep connection open\n    harvest.pingErrors(loader)\n  }\n\n  if (result.retry && currentBody) {\n    mapOwn(currentBody, function(key, value) {\n      for (var i = 0; i < value.length; i++) {\n        var bucket = value[i]\n        var name = getBucketName(bucket.params, bucket.custom)\n        agg.merge(key, name, bucket.metrics, bucket.params, bucket.custom)\n      }\n    })\n    currentBody = null\n  }\n}\n\n// open HTTPS connection, which is needed for sending data during page unload on older browsers\nharvest.pingErrors(loader)\n\nfunction nameHash (params) {\n  return stringHashCode(params.exceptionClass) ^ params.stackHash\n}\n\nfunction getBucketName(params, customParams) {\n  return nameHash(params) + ':' + stringHashCode(stringify(customParams))\n}\n\nfunction canonicalizeURL (url, cleanedOrigin) {\n  if (typeof url !== 'string') return ''\n\n  var cleanedURL = cleanURL(url)\n  if (cleanedURL === cleanedOrigin) {\n    return '<inline>'\n  } else {\n    return cleanedURL\n  }\n}\n\nfunction buildCanonicalStackString (stackInfo, cleanedOrigin) {\n  var canonicalStack = ''\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var func = canonicalFunctionName(frame.func)\n\n    if (canonicalStack) canonicalStack += '\\n'\n    if (func) canonicalStack += func + '@'\n    if (typeof frame.url === 'string') canonicalStack += frame.url\n    if (frame.line) canonicalStack += ':' + frame.line\n  }\n\n  return canonicalStack\n}\n\n// Strip query parameters and fragments from the stackString property of the\n// given stackInfo, along with the 'url' properties of each frame in\n// stackInfo.frames.\n//\n// Any URLs that are equivalent to the cleaned version of the origin will also\n// be replaced with the string '<inline>'.\n//\nfunction canonicalizeStackURLs (stackInfo) {\n  // Currently, loader.origin might contain a fragment, but we don't want to use it\n  // for comparing with frame URLs.\n  var cleanedOrigin = cleanURL(loader.origin)\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var originalURL = frame.url\n    var cleanedURL = canonicalizeURL(originalURL, cleanedOrigin)\n    if (cleanedURL && cleanedURL !== frame.url) {\n      frame.url = cleanedURL\n      stackInfo.stackString = stackInfo.stackString.split(originalURL).join(cleanedURL)\n    }\n  }\n\n  return stackInfo\n}\n\nfunction storeError (err, time, internal, customAttributes) {\n  // are we in an interaction\n  time = time || loader.now()\n  if (!internal && loader.onerror && loader.onerror(err)) return\n\n  var stackInfo = canonicalizeStackURLs(computeStackTrace(err))\n  var canonicalStack = buildCanonicalStackString(stackInfo)\n\n  var params = {\n    stackHash: stringHashCode(canonicalStack),\n    exceptionClass: stackInfo.name,\n    request_uri: window.location.pathname\n  }\n  if (stackInfo.message) {\n    params.message = '' + stackInfo.message\n  }\n\n  if (!stackReported[params.stackHash]) {\n    stackReported[params.stackHash] = true\n    params.stack_trace = truncateSize(stackInfo.stackString)\n  } else {\n    params.browser_stack_hash = stringHashCode(stackInfo.stackString)\n  }\n  params.releaseIds = stringify(loader.releaseIds)\n\n  // When debugging stack canonicalization/hashing, uncomment these lines for\n  // more output in the test logs\n  // params.origStack = err.stack\n  // params.canonicalStack = canonicalStack\n\n  var hash = nameHash(params)\n\n  if (!pageviewReported[hash]) {\n    params.pageview = 1\n    pageviewReported[hash] = true\n  }\n\n  var type = internal ? 'ierr' : 'err'\n  var newMetrics = { time: time }\n\n  // stn and spa aggregators listen to this event - stn sends the error in its payload,\n  // and spa annotates the error with interaction info\n  handle('errorAgg', [type, hash, params, newMetrics])\n\n  if (params._interactionId != null) {\n    // hold on to the error until the interaction finishes\n    errorCache[params._interactionId] = errorCache[params._interactionId] || []\n    errorCache[params._interactionId].push([type, hash, params, newMetrics, att, customAttributes])\n  } else {\n    // store custom attributes\n    var customParams = {}\n    var att = loader.info.jsAttributes\n    mapOwn(att, setCustom)\n    if (customAttributes) {\n      mapOwn(customAttributes, setCustom)\n    }\n\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n    agg.store(type, aggregateHash, params, newMetrics, customParams)\n  }\n\n  function setCustom (key, val) {\n    customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nbaseEE.on('interactionSaved', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    params.browserInteractionId = interaction.root.attrs.id\n    delete params._interactionId\n\n    if (params._interactionNodeId) {\n      params.parentNodeId = params._interactionNodeId.toString()\n      delete params._interactionNodeId\n    }\n\n    var hash = item[1] + interaction.root.attrs.id\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, params, item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n\nbaseEE.on('interactionDiscarded', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    delete params._interactionId\n    delete params._interactionNodeId\n\n    var hash = item[1]\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, item[2], item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nfunction stringHashCode (string) {\n  var hash = 0\n  var charVal\n\n  if (!string || !string.length) return hash\n  for (var i = 0; i < string.length; i++) {\n    charVal = string.charCodeAt(i)\n    hash = ((hash << 5) - hash) + charVal\n    hash = hash | 0 // Convert to 32bit integer\n  }\n  return hash\n}\n\nmodule.exports = stringHashCode\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar loader = require(\"loader\")\nvar mapOwn = require(44)\nvar stringify = require(22)\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar cleanURL = require(5)\nvar config = require(39)\n\nvar eventsPerMinute = 120\nvar harvestTimeSeconds = config.getConfiguration('ins.harvestTimeSeconds') || 30\nvar eventsPerHarvest = eventsPerMinute * harvestTimeSeconds / 60\nvar referrerUrl\nvar currentEvents\n\nvar events = []\nvar att = loader.info.jsAttributes = {}\n\nif (document.referrer) referrerUrl = cleanURL(document.referrer)\n\nregister('api-setCustomAttribute', setCustomAttribute, 'api')\n\nee.on('feat-ins', function () {\n  register('api-addPageAction', addPageAction)\n\n  harvest.on('ins', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'ins', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds, 0)\n})\n\nfunction onHarvestStarted (options) {\n  var payload = ({\n    qs: {\n      ua: loader.info.userAttributes,\n      at: loader.info.atts\n    },\n    body: {\n      ins: events\n    }\n  })\n\n  if (options.retry) {\n    currentEvents = events\n  }\n\n  events = []\n  return payload\n}\n\nfunction onHarvestFinished (result) {\n  if (result && result.sent && result.retry && currentEvents) {\n    events = events.concat(currentEvents)\n    currentEvents = null\n  }\n}\n\n// WARNING: Insights times are in seconds. EXCEPT timestamp, which is in ms.\nfunction addPageAction (t, name, attributes) {\n  if (events.length >= eventsPerHarvest) return\n  var width\n  var height\n  var eventAttributes = {}\n\n  if (typeof window !== 'undefined' && window.document && window.document.documentElement) {\n    // Doesn't include the nav bar when it disappears in mobile safari\n    // https://github.com/jquery/jquery/blob/10399ddcf8a239acc27bdec9231b996b178224d3/src/dimensions.js#L23\n    width = window.document.documentElement.clientWidth\n    height = window.document.documentElement.clientHeight\n  }\n\n  var defaults = {\n    timestamp: t + loader.offset,\n    timeSinceLoad: t / 1000,\n    browserWidth: width,\n    browserHeight: height,\n    referrerUrl: referrerUrl,\n    currentUrl: cleanURL('' + location),\n    pageUrl: cleanURL(loader.origin),\n    eventType: 'PageAction'\n  }\n\n  mapOwn(defaults, set)\n  mapOwn(att, set)\n  if (attributes && typeof attributes === 'object') {\n    mapOwn(attributes, set)\n  }\n  eventAttributes.actionName = name || ''\n\n  events.push(eventAttributes)\n\n  function set (key, val) {\n    eventAttributes[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nfunction setCustomAttribute (t, key, value) {\n  att[key] = value\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar baseEE = require(\"ee\")\nvar mapOwn = require(44)\nvar loader = require(\"loader\")\nvar InteractionNode = require(33)\n\nvar originals = NREUM.o\nvar originalSetTimeout = originals.ST\nvar originalClearTimeout = originals.CT\n\nvar REMAINING = 'remaining'\n\nvar lastId = 0\n\nmodule.exports = Interaction\n\nfunction Interaction (eventName, timestamp, url, routeName, onFinished) {\n  this.id = ++lastId\n  this.eventName = eventName\n  this.nodes = 0\n  this[REMAINING] = 0\n  this.finishTimer = null\n  this.checkingFinish = false\n  this.lastCb = this.lastFinish = timestamp\n  this.handlers = []\n  this.onFinished = onFinished\n\n  var root = this.root = new InteractionNode(this, null, 'interaction', timestamp)\n  var attrs = root.attrs\n\n  attrs.trigger = eventName\n  attrs.initialPageURL = loader.origin\n  attrs.oldRoute = routeName\n  attrs.newURL = attrs.oldURL = url\n  attrs.custom = {}\n  attrs.store = {}\n}\n\nvar InteractionPrototype = Interaction.prototype\n\nInteractionPrototype.checkFinish = function checkFinish (url, routeName) {\n  var interaction = this\n\n  if (interaction[REMAINING]) {\n    interaction._resetFinishCheck()\n    return\n  }\n\n  if (interaction.checkingFinish) {\n    return\n  }\n\n  interaction._resetFinishCheck()\n\n  var attrs = this.root.attrs\n  attrs.newURL = url\n  attrs.newRoute = routeName\n\n  interaction.checkingFinish = true\n  interaction.finishTimer = originalSetTimeout(function () {\n    interaction.checkingFinish = false\n    interaction.finishTimer = originalSetTimeout(function () {\n      interaction.finishTimer = null\n      if (!interaction[REMAINING]) interaction.finish()\n    }, 1)\n  }, 0)\n}\n\nInteractionPrototype.onNodeAdded = function onNodeAdded() {\n  this._resetFinishCheck()\n}\n\nInteractionPrototype._resetFinishCheck = function _resetFinishCheck() {\n  if (this.finishTimer) {\n    originalClearTimeout(this.finishTimer)\n    this.finishTimer = null\n    this.checkingFinish = false\n  }\n}\n\n// serialize report and remove nodes from map\nInteractionPrototype.finish = function finishInteraction () {\n  var interaction = this\n  var root = interaction.root\n  if (root.end) return\n  var endTimestamp = Math.max(interaction.lastCb, interaction.lastFinish)\n\n  var attrs = root.attrs\n  var customAttrs = attrs.custom\n\n  if (this.onFinished) {\n    this.onFinished(this)\n  }\n\n  mapOwn(loader.info.jsAttributes, function (attr, value) {\n    if (!(attr in customAttrs)) customAttrs[attr] = value\n  })\n\n  root.end = endTimestamp\n  baseEE.emit('interaction', [this])\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar INTERACTION = 'interaction'\nvar MAX_NODES = 128\nvar REMAINING = 'remaining'\n\nvar lastId = 0\n\nmodule.exports = InteractionNode\n\nfunction InteractionNode (interaction, parent, type, timestamp) {\n  this[INTERACTION] = interaction\n  this.parent = parent\n  this.id = ++lastId\n  this.type = type\n  this.children = []\n  this.end = null\n  this.jsEnd = this.start = timestamp\n  this.jsTime = 0\n  this.attrs = {}\n}\n\nvar InteractionNodePrototype = InteractionNode.prototype\n\n/**\n * @param {string} type\n * @param {number} timestamp\n * @param {string} name\n * @param {bool} dontWait - When true, the interaction will not immediately start waiting\n *                          for this node to complete. This is used when the creation of\n *                          the node and its start happen at different times (e.g. XHR).\n */\nInteractionNodePrototype.child = function child (type, timestamp, name, dontWait) {\n  var interaction = this[INTERACTION]\n  if (interaction.end || interaction.nodes >= MAX_NODES) return null\n\n  interaction.onNodeAdded(this)\n\n  var node = new InteractionNode(interaction, this, type, timestamp)\n  node.attrs.name = name\n  interaction.nodes++\n  if (!dontWait) interaction[REMAINING]++\n  return node\n}\n\nInteractionNodePrototype.callback = function addCallbackTime (exclusiveTime, end) {\n  var node = this\n\n  node.jsTime += exclusiveTime\n  if (end > node.jsEnd) {\n    node.jsEnd = end\n    node[INTERACTION].lastCb = end\n  }\n}\n\nInteractionNodePrototype.finish = function finish (timestamp) {\n  var node = this\n  if (node.end) return\n  node.end = timestamp\n  var parent = node.parent\n  while (parent.cancelled) parent = parent.parent\n  parent.children.push(node)\n  node.parent = null\n\n  var interaction = this[INTERACTION]\n  interaction[REMAINING]--\n  interaction.lastFinish = timestamp\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar register = require(17)\nvar parseUrl = require(38)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar serializer = require(35)\nvar loader = require(\"loader\")\nvar baseEE = require(\"ee\")\nvar mutationEE = baseEE.get('mutation')\nvar promiseEE = baseEE.get('promise')\nvar historyEE = baseEE.get('history')\nvar eventsEE = baseEE.get('events')\nvar timerEE = baseEE.get('timer')\nvar fetchEE = baseEE.get('fetch')\nvar jsonpEE = baseEE.get('jsonp')\nvar xhrEE = baseEE.get('xhr')\nvar tracerEE = baseEE.get('tracer')\nvar mapOwn = require(44)\nvar navTiming = require(15).nt\nvar dataSize = require(40)\nvar uniqueId = require(43)\nvar paintMetrics = require(16).metrics\nvar Interaction = require(32)\nvar config = require(39)\n\nvar INTERACTION_EVENTS = [\n  'click',\n  'submit',\n  'keypress',\n  'keydown',\n  'keyup',\n  'change'\n]\n\nvar MAX_TIMER_BUDGET = 999\nvar FN_START = 'fn-start'\nvar FN_END = 'fn-end'\nvar CB_START = 'cb-start'\nvar INTERACTION_API = 'api-ixn-'\nvar REMAINING = 'remaining'\nvar INTERACTION = 'interaction'\nvar SPA_NODE = 'spaNode'\nvar JSONP_NODE = 'jsonpNode'\nvar FETCH_START = 'fetch-start'\nvar FETCH_DONE = 'fetch-done'\nvar FETCH_BODY = 'fetch-body-'\nvar JSONP_END = 'jsonp-end'\n\nvar originals = NREUM.o\nvar origRequest = originals.REQ\nvar originalSetTimeout = originals.ST\nvar initialPageURL = loader.origin\nvar lastSeenUrl = initialPageURL\nvar lastSeenRouteName = null\n\nvar timerMap = {}\nvar timerBudget = MAX_TIMER_BUDGET\nvar currentNode = null\nvar prevNode = null\nvar nodeOnLastHashUpdate = null\nvar initialPageLoad = null\nvar pageLoaded = false\nvar childTime = 0\nvar depth = 0\n\nmodule.exports = function () {\n  return currentNode && currentNode.id\n}\n\n// childTime is used when calculating exclusive time for a cb duration.\n//\n// Exclusive time will be different than the total time for either callbacks\n// which synchronously invoke a customTracer callback or, trigger a synchronous\n// event (eg. onreadystate=1 or popstate).\n//\n// At fn-end, childTime will contain the total time of all timed callbacks and\n// event handlers which executed as a child of the current callback. At the\n// begining of every callback, childTime is saved to the event context (which at\n// that time contains the sum of its preceeding siblings) and is reset to 0. The\n// callback is then executed, and its children may increase childTime.  At the\n// end of the callback, it reports its exclusive time as its\n// execution time - exlcuded. childTime is then reset to its previous\n// value, and the totalTime of the callback that just finished executing is\n// added to the childTime time.\n//                                    | clock | childTime | ctx.ct | totalTime | exclusive |\n// click fn-start                     |   0   |    0     |    0   |           |           |\n//  | click begining:                 |   5   |    0     |    0   |           |           |\n//  |   | custom-1 fn-start           |   10  |    0     |    0   |           |           |\n//  |   |   |  custom-1 begining      |   15  |    0     |    0   |           |           |\n//  |   |   |    |  custom-2 fn-start |   20  |    0     |    0   |           |           |\n//  |   |   |    |  | custom-2        |   25  |    0     |    0   |           |           |\n//  |   |   |    |  custom-2 fn-end   |   30  |    10    |    0   |     10    |     10    |\n//  |   |   |  custom-1 middle        |   35  |    10    |    0   |           |           |\n//  |   |   |    |  custom-3 fn-start |   40  |    0     |    10  |           |           |\n//  |   |   |    |  | custom-3        |   45  |    0     |    10  |           |           |\n//  |   |   |    |  custom-3 fn-end   |   50  |    20    |    0   |     10    |     10    |\n//  |   |   |  custom-1 ending        |   55  |    20    |    0   |           |           |\n//  |     custom-1 fn-end             |   60  |    50    |    0   |     50    |     30    |\n//  | click ending:                   |   65  |    50    |        |           |           |\n// click fn-end                       |   70  |    0     |    0   |     70    |     20    |\n\nbaseEE.on('feat-spa', function () {\n  if (!isEnabled()) return\n\n  initialPageLoad = new Interaction('initialPageLoad', 0, lastSeenUrl, lastSeenRouteName, onInteractionFinished)\n  initialPageLoad.save = true\n  currentNode = initialPageLoad.root // hint\n  // ensure that checkFinish calls are safe during initialPageLoad\n  initialPageLoad[REMAINING]++\n\n  register.on(baseEE, FN_START, callbackStart)\n  register.on(promiseEE, CB_START, callbackStart)\n\n  // register plugins\n  var pluginApi = {\n    getCurrentNode: getCurrentNode,\n    setCurrentNode: setCurrentNode\n  }\n\n  register('spa-register', function(init) {\n    if (typeof init === 'function') {\n      init(pluginApi)\n    }\n  })\n\n  function callbackStart () {\n    depth++\n    this.prevNode = currentNode\n    this.ct = childTime\n    childTime = 0\n    timerBudget = MAX_TIMER_BUDGET\n  }\n\n  register.on(baseEE, FN_END, callbackEnd)\n  register.on(promiseEE, 'cb-end', callbackEnd)\n\n  function callbackEnd () {\n    depth--\n    var totalTime = this.jsTime || 0\n    var exclusiveTime = totalTime - childTime\n    childTime = this.ct + totalTime\n    if (currentNode) {\n      // transfer accumulated callback time to the active interaction node\n      // run even if jsTime is 0 to update jsEnd\n      currentNode.callback(exclusiveTime, this[FN_END])\n      if (this.isTraced) {\n        currentNode.attrs.tracedTime = exclusiveTime\n      }\n    }\n\n    this.jsTime = currentNode ? 0 : exclusiveTime\n    setCurrentNode(this.prevNode)\n    this.prevNode = null\n    timerBudget = MAX_TIMER_BUDGET\n  }\n\n  register.on(eventsEE, FN_START, function (args, eventSource) {\n    var ev = args[0]\n    var evName = ev.type\n    var eventNode = ev.__nrNode\n\n    if (!pageLoaded && evName === 'load' && eventSource === window) {\n      pageLoaded = true\n      // set to null so prevNode is set correctly\n      this.prevNode = currentNode = null\n      if (initialPageLoad) {\n        eventNode = initialPageLoad.root\n        initialPageLoad[REMAINING]--\n        originalSetTimeout(function () {\n          INTERACTION_EVENTS.push('popstate')\n        })\n      }\n    }\n\n    if (eventNode) {\n      // If we've already seen a previous handler for this specific event object,\n      // just restore that. We want multiple handlers for the same event to share\n      // a node.\n      setCurrentNode(eventNode)\n    } else if (evName === 'hashchange') {\n      setCurrentNode(nodeOnLastHashUpdate)\n      nodeOnLastHashUpdate = null\n    } else if (eventSource instanceof XMLHttpRequest) {\n      // If this event was emitted by an XHR, restore the node ID associated with\n      // that XHR.\n      setCurrentNode(baseEE.context(eventSource).spaNode)\n    } else if (!currentNode) {\n      // Otherwise, if no interaction is currently active, create a new node ID,\n      // and let the aggregator know that we entered a new event handler callback\n      // so that it has a chance to possibly start an interaction.\n      if (INTERACTION_EVENTS.indexOf(evName) !== -1) {\n        var ixn = new Interaction(evName, this[FN_START], lastSeenUrl, lastSeenRouteName, onInteractionFinished)\n        setCurrentNode(ixn.root)\n\n        if (evName === 'click') {\n          var value = getActionText(ev.target)\n          if (value) {\n            currentNode.attrs.custom['actionText'] = value\n          }\n        }\n      }\n    }\n\n    ev.__nrNode = currentNode\n  })\n\n  /**\n   * *** TIMERS ***\n   * setTimeout call needs to keep the interaction active in case a node is started\n   * in its callback.\n   */\n\n  // The context supplied to this callback will be shared with the fn-start/fn-end\n  // callbacks that fire around the callback passed to setTimeout originally.\n  register.on(timerEE, 'setTimeout-end', function saveId (args, obj, timerId) {\n    if (!currentNode || (timerBudget - this.timerDuration) < 0) return\n    currentNode[INTERACTION][REMAINING]++\n    this.timerId = timerId\n    timerMap[timerId] = currentNode\n    this.timerBudget = timerBudget - 50\n  })\n\n  register.on(timerEE, 'clearTimeout-start', function clear (args) {\n    var timerId = args[0]\n    var node = timerMap[timerId]\n    if (node) {\n      var interaction = node[INTERACTION]\n      interaction[REMAINING]--\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n      delete timerMap[timerId]\n    }\n  })\n\n  register.on(timerEE, FN_START, function () {\n    timerBudget = this.timerBudget || MAX_TIMER_BUDGET\n    var id = this.timerId\n    var node = timerMap[id]\n    setCurrentNode(node)\n    delete timerMap[id]\n    if (node) {\n      node[INTERACTION][REMAINING]--\n    }\n  })\n\n  /**\n   * *** XHR ***\n   * - `new-xhr` event is fired when new instance of XHR is created. Here we create\n   *    a new node and store it on the XHR object.\n   * -  When the send method is called (`send-xhr-start` event), we tell the interaction\n   *    to wait for this XHR to complete.\n   * -  When any direct event handlers are invoked (`fn-start` on the `xhr` emitter),\n   *    we restore the node in case other child nodes are started here.\n   * -  Callbacks attached using `addEventListener` are handled using `fn-start` on the\n   *    `events` emitter.\n   * -  When `xhr-resolved` is emitted, we end the node. The node.finish() call also\n   *    instructs the interaction to stop waiting for this node.\n   */\n\n  // context is shared with new-xhr event, and is stored on the xhr iteself.\n  register.on(xhrEE, FN_START, function () {\n    setCurrentNode(this[SPA_NODE])\n  })\n\n  // context is stored on the xhr and is shared with all callbacks associated\n  // with the new xhr\n  register.on(xhrEE, 'new-xhr', function () {\n    if (currentNode) {\n      this[SPA_NODE] = currentNode.child('ajax', null, null, true)\n    }\n  })\n\n  register.on(xhrEE, 'send-xhr-start', function () {\n    var node = this[SPA_NODE]\n    if (node && !this.sent) {\n      this.sent = true\n      node.dt = this.dt\n      node.jsEnd = node.start = this['send-xhr-start']\n      node[INTERACTION][REMAINING]++\n    }\n  })\n\n  register.on(baseEE, 'xhr-resolved', function () {\n    var node = this[SPA_NODE]\n    if (node) {\n      var attrs = node.attrs\n      attrs.params = this.params\n      attrs.metrics = this.metrics\n\n      node.finish(this['xhr-resolved'])\n    }\n  })\n\n  /**\n   * *** JSONP ***\n   *\n   */\n\n  register.on(jsonpEE, 'new-jsonp', function (url) {\n    if (currentNode) {\n      var node = this[JSONP_NODE] = currentNode.child('ajax', this[FETCH_START])\n      node.start = this['new-jsonp']\n      this.url = url\n      this.status = null\n    }\n  })\n\n  register.on(jsonpEE, 'cb-start', function (args) {\n    var node = this[JSONP_NODE]\n    if (node) {\n      setCurrentNode(node)\n      this.status = 200\n    }\n  })\n\n  register.on(jsonpEE, 'jsonp-error', function () {\n    var node = this[JSONP_NODE]\n    if (node) {\n      setCurrentNode(node)\n      this.status = 0\n    }\n  })\n\n  register.on(jsonpEE, JSONP_END, function () {\n    var node = this[JSONP_NODE]\n    if (node) {\n      // if no status is set then cb never fired - so it's not a valid JSONP\n      if (this.status === null) {\n        node[INTERACTION][REMAINING]--\n        node.cancelled = true\n        return\n      }\n      var attrs = node.attrs\n      var params = attrs.params = {}\n\n      var parsed = parseUrl(this.url)\n      params.method = 'GET'\n      params.pathname = parsed.pathname\n      params.host = parsed.hostname + ':' + parsed.port\n      params.status = this.status\n\n      attrs.metrics = {\n        txSize: 0,\n        rxSize: 0\n      }\n\n      attrs.isJSONP = true\n      node.jsEnd = this[JSONP_END]\n      node.jsTime = this[CB_START] ? (this[JSONP_END] - this[CB_START]) : 0\n      node.finish(node.jsEnd)\n    }\n  })\n\n  register.on(fetchEE, FETCH_START, function (fetchArguments, dtPayload) {\n    if (currentNode && fetchArguments) {\n      this[SPA_NODE] = currentNode.child('ajax', this[FETCH_START])\n      if (fetchArguments.length >= 1) this.target = fetchArguments[0]\n      if (fetchArguments.length >= 2) this.opts = fetchArguments[1]\n\n      if (dtPayload && this[SPA_NODE]) this[SPA_NODE].dt = dtPayload\n    }\n  })\n\n  register.on(fetchEE, FETCH_BODY + 'start', function (args) {\n    if (currentNode) {\n      this[SPA_NODE] = currentNode\n      currentNode[INTERACTION][REMAINING]++\n    }\n  })\n\n  register.on(fetchEE, FETCH_BODY + 'end', function (args, ctx, bodyPromise) {\n    var node = this[SPA_NODE]\n    if (node) {\n      node[INTERACTION][REMAINING]--\n    }\n  })\n\n  register.on(fetchEE, FETCH_DONE, function (err, res) {\n    var node = this[SPA_NODE]\n    var target = this.target\n    var opts = this.opts || {}\n    if (node) {\n      if (err) {\n        node.cancelled = true\n        node[INTERACTION][REMAINING]--\n        return\n      }\n\n      var url, method\n      if (typeof target === 'string') {\n        url = target\n      } else if (typeof target === 'object' && target instanceof origRequest) {\n        url = target.url\n      } else if (window.URL && typeof target === 'object' && target instanceof URL) {\n        url = target.href\n      }\n\n      method = ('' + ((target && target instanceof origRequest && target.method) || opts.method || 'GET')).toUpperCase()\n      var attrs = node.attrs\n      var params = attrs.params = {}\n\n      var parsed = parseUrl(url)\n      params.method = method\n      params.pathname = parsed.pathname\n      params.host = parsed.hostname + ':' + parsed.port\n      params.status = res.status\n\n      attrs.metrics = {\n        txSize: dataSize(opts.body) || 0,\n        rxSize: this.rxSize\n      }\n\n      attrs.isFetch = true\n\n      node.finish(this[FETCH_DONE])\n    }\n  })\n\n  register.on(historyEE, 'newURL', function (url, hashChangedDuringCb) {\n    if (currentNode) {\n      if (lastSeenUrl !== url) {\n        currentNode[INTERACTION].routeChange = true\n      }\n      if (hashChangedDuringCb) {\n        nodeOnLastHashUpdate = currentNode\n      }\n    }\n\n    lastSeenUrl = url\n  })\n\n  /**\n   * SCRIPTS\n   *   This is only needed to keep the interaction open while external scripts are being loaded.\n   *   The script that is loaded could continue the interaction by making additional AJAX\n   *   calls or changing the URL. The interaction context (currentNode) needs to be\n   *   restored somehow, but this differs based on the specific customer code. In some cases, we\n   *   could wrap a JSONP callback, in other cases we could wrap a higher-level API, and in\n   *   some cases we may not be able to restore context automatically (customer would need\n   *   to instrument their code manually).\n   *\n   * - We do not restore the original context in the load/error callbacks. This would not\n   *   work for the scripts themselves because by the time the load event fires, the\n   *   script content has already been executed.\n   */\n\n  // dom-start is emitted when appendChild or replaceChild are called. If the element being\n  // inserted is script and we are inside an interaction, we will keep the interaction open\n  // until the script is loaded.\n  jsonpEE.on('dom-start', function (args) {\n    if (!currentNode) return\n\n    var el = args[0]\n    var isScript = (el && el.nodeName === 'SCRIPT' && el.src !== '')\n    var interaction = currentNode.interaction\n\n    if (isScript) {\n      // increase remaining count to keep the interaction open\n      interaction[REMAINING]++\n      el.addEventListener('load', onload, false)\n      el.addEventListener('error', onerror, false)\n    }\n\n    function onload() {\n      // decrease remaining to allow interaction to finish\n      interaction[REMAINING]--\n\n      // checkFinish is what initiates closing interaction, but is only called\n      // when setCurrentNode is called. Since we are not restoring a node here,\n      // we need to initiate the check manually.\n      // The reason we are not restoring the node here is because 1) this is not\n      // where the code of the external script runs (by the time the load event\n      // fires, it has already executed), and 2) it would require storing the context\n      // probably on the DOM node and restoring in all callbacks, which is a different\n      // use case than lazy loading.\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n    }\n\n    function onerror() {\n      interaction[REMAINING]--\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n    }\n  })\n\n  register.on(mutationEE, FN_START, function () {\n    setCurrentNode(prevNode)\n  })\n\n  register.on(promiseEE, 'resolve-start', resolvePromise)\n  register.on(promiseEE, 'executor-err', resolvePromise)\n\n  register.on(promiseEE, 'propagate', saveNode)\n\n  register.on(promiseEE, CB_START, function () {\n    var ctx = this.getCtx ? this.getCtx() : this\n    setCurrentNode(ctx[SPA_NODE])\n  })\n\n  register(INTERACTION_API + 'get', function (t) {\n    var interaction = this.ixn = currentNode ? currentNode[INTERACTION] : new Interaction('api', t, lastSeenUrl, lastSeenRouteName, onInteractionFinished)\n\n    if (!currentNode) {\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n      if (depth) setCurrentNode(interaction.root)\n    }\n  })\n\n  register(INTERACTION_API + 'actionText', function (t, actionText) {\n    var customAttrs = this.ixn.root.attrs.custom\n    if (actionText) customAttrs.actionText = actionText\n  })\n\n  register(INTERACTION_API + 'setName', function (t, name, trigger) {\n    var attrs = this.ixn.root.attrs\n    if (name) attrs.customName = name\n    if (trigger) attrs.trigger = trigger\n  })\n\n  register(INTERACTION_API + 'setAttribute', function (t, name, value) {\n    this.ixn.root.attrs.custom[name] = value\n  })\n\n  register(INTERACTION_API + 'end', function (timestamp) {\n    var interaction = this.ixn\n    var node = activeNodeFor(interaction)\n    setCurrentNode(null)\n    node.child('customEnd', timestamp).finish(timestamp)\n    interaction.finish()\n  })\n\n  register(INTERACTION_API + 'ignore', function () {\n    this.ixn.ignored = true\n  })\n\n  register(INTERACTION_API + 'save', function () {\n    this.ixn.save = true\n  })\n\n  register(INTERACTION_API + 'tracer', function (timestamp, name, store) {\n    var interaction = this.ixn\n    var parent = activeNodeFor(interaction)\n    var ctx = baseEE.context(store)\n    if (!name) {\n      ctx.inc = ++interaction[REMAINING]\n      return (ctx[SPA_NODE] = parent)\n    }\n    ctx[SPA_NODE] = parent.child('customTracer', timestamp, name)\n  })\n\n  register.on(tracerEE, FN_START, tracerDone)\n  register.on(tracerEE, 'no-' + FN_START, tracerDone)\n\n  function tracerDone (timestamp, interactionContext, hasCb) {\n    var node = this[SPA_NODE]\n    if (!node) return\n    var interaction = node[INTERACTION]\n    var inc = this.inc\n    this.isTraced = true\n    if (inc) {\n      interaction[REMAINING]--\n    } else if (node) {\n      node.finish(timestamp)\n    }\n    hasCb ? setCurrentNode(node) : interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n  }\n\n  register(INTERACTION_API + 'getContext', function (t, cb) {\n    var store = this.ixn.root.attrs.store\n    setTimeout(function () {\n      cb(store)\n    }, 0)\n  })\n\n  register(INTERACTION_API + 'onEnd', function (t, cb) {\n    this.ixn.handlers.push(cb)\n  })\n\n  register('api-routeName', function (t, currentRouteName) {\n    lastSeenRouteName = currentRouteName\n  })\n\n  function activeNodeFor (interaction) {\n    return (currentNode && currentNode[INTERACTION] === interaction) ? currentNode : interaction.root\n  }\n})\n\nfunction saveNode (val, overwrite) {\n  if (overwrite || !this[SPA_NODE]) this[SPA_NODE] = currentNode\n}\n\nfunction resolvePromise () {\n  if (!this.resolved) {\n    this.resolved = true\n    this[SPA_NODE] = currentNode\n  }\n}\n\nfunction getCurrentNode() {\n  return currentNode\n}\n\nfunction setCurrentNode (newNode) {\n  if (!pageLoaded && !newNode && initialPageLoad) newNode = initialPageLoad.root\n  if (currentNode) {\n    currentNode[INTERACTION].checkFinish(lastSeenUrl, lastSeenRouteName)\n  }\n\n  prevNode = currentNode\n  currentNode = (newNode && !newNode[INTERACTION].root.end) ? newNode : null\n}\n\nfunction onInteractionFinished(interaction) {\n  if (interaction === initialPageLoad) initialPageLoad = null\n\n  var root = interaction.root\n  var attrs = root.attrs\n\n  // make sure that newrelic[INTERACTION]() works in end handler\n  currentNode = root\n  mapOwn(interaction.handlers, function (i, cb) {\n    cb(attrs.store)\n  })\n  setCurrentNode(null)\n}\n\nvar harvestTimeSeconds = config.getConfiguration('spa.harvestTimeSeconds') || 10\nvar interactionsToHarvest = []\nvar interactionsSent = []\n\nvar scheduler = new HarvestScheduler(loader, 'events', { onFinished: onHarvestFinished, retryDelay: harvestTimeSeconds })\n\nharvest.on('events', onHarvestStarted)\n\nfunction onHarvestStarted(options) {\n  if (interactionsToHarvest.length === 0) return {}\n  var payload = serializer.serializeMultiple(interactionsToHarvest, 0, navTiming)\n\n  if (options.retry) {\n    interactionsToHarvest.forEach(function(interaction) {\n      interactionsSent.push(interaction)\n    })\n  }\n  interactionsToHarvest = []\n\n  return { body: { e: payload } }\n}\n\nfunction onHarvestFinished(result) {\n  if (result.sent && result.retry && interactionsSent.length > 0) {\n    interactionsSent.forEach(function(interaction) {\n      interactionsToHarvest.push(interaction)\n    })\n    interactionsSent = []\n  }\n}\n\nbaseEE.on('errorAgg', function (type, name, params, metrics) {\n  if (!currentNode) return\n  params._interactionId = currentNode.interaction.id\n  // do not capture parentNodeId when in root node\n  if (currentNode.type && currentNode.type !== 'interaction') {\n    params._interactionNodeId = currentNode.id\n  }\n})\n\nbaseEE.on('interaction', saveInteraction)\n\nfunction getActionText (node) {\n  var nodeType = node.tagName.toLowerCase()\n  var goodNodeTypes = ['a', 'button', 'input']\n  var isGoodNode = goodNodeTypes.indexOf(nodeType) !== -1\n  if (isGoodNode) {\n    return node.title || node.value || node.innerText\n  }\n}\n\nfunction saveInteraction (interaction) {\n  if (interaction.ignored || (!interaction.save && !interaction.routeChange)) {\n    baseEE.emit('interactionDiscarded', [interaction])\n    return\n  }\n\n  // assign unique id, this is serialized and used to link interactions with errors\n  interaction.root.attrs.id = uniqueId.generateUuid()\n\n  if (interaction.root.attrs.trigger === 'initialPageLoad') {\n    interaction.root.attrs.firstPaint = paintMetrics['first-paint']\n    interaction.root.attrs.firstContentfulPaint = paintMetrics['first-contentful-paint']\n  }\n  baseEE.emit('interactionSaved', [interaction])\n  interactionsToHarvest.push(interaction)\n  scheduler.scheduleHarvest(0)\n}\n\nfunction isEnabled() {\n  var configuration = config.getConfiguration('spa')\n  if (configuration && configuration.enabled === false) {\n    return false\n  }\n  return true\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar cleanURL = require(5)\nvar loader = require(\"loader\")\nvar mapOwn = require(44)\nvar nullable = require(4).nullable\nvar numeric = require(4).numeric\nvar getAddStringContext = require(4).getAddStringContext\nvar addCustomAttributes = require(4).addCustomAttributes\n\nmodule.exports = serializeSingle\nmodule.exports.serializeMultiple = serializeMultiple\n\nfunction serializeMultiple(interactions, offset, navTiming) {\n  var addString = getAddStringContext()\n  var serialized = 'bel.7'\n  interactions.forEach(function(interaction) {\n    serialized += ';' + serializeInteraction(interaction.root, offset, navTiming, interaction.routeChange, addString)\n  })\n  return serialized\n}\n\nfunction serializeSingle(root, offset, navTiming, isRouteChange) {\n  var addString = getAddStringContext()\n  return 'bel.7;' + serializeInteraction(root, offset, navTiming, isRouteChange, addString)\n}\n\nfunction serializeInteraction (root, offset, navTiming, isRouteChange, addString) {\n  offset = offset || 0\n  var isInitialPage = root.attrs.trigger === 'initialPageLoad'\n  var firstTimestamp\n  var typeIdsByName = {\n    interaction: 1,\n    ajax: 2,\n    customTracer: 4\n  }\n\n  // Include the hash fragment with all SPA data\n  var includeHashFragment = true\n\n  return addNode(root, []).join(';')\n\n  function addNode (node, nodeList) {\n    if (node.type === 'customEnd') return nodeList.push([3, numeric(node.end - firstTimestamp)])\n    var typeName = node.type\n    var typeId = typeIdsByName[typeName]\n    var startTimestamp = node.start\n    var childCount = node.children.length\n    var attrCount = 0\n    var apmAttributes = loader.info.atts\n    var hasNavTiming = isInitialPage && navTiming.length && typeId === 1\n    var children = []\n    var attrs = node.attrs\n    var metrics = attrs.metrics\n    var params = attrs.params\n    var queueTime = loader.info.queueTime\n    var appTime = loader.info.applicationTime\n\n    if (typeof firstTimestamp === 'undefined') {\n      startTimestamp += offset\n      firstTimestamp = startTimestamp\n    } else {\n      startTimestamp -= firstTimestamp\n    }\n\n    var fields = [\n      numeric(startTimestamp),\n      numeric(node.end - node.start),\n      numeric(node.jsEnd - node.end),\n      numeric(node.jsTime)\n    ]\n\n    switch (typeId) {\n      case 1:\n        fields[2] = numeric(node.jsEnd - firstTimestamp)\n        fields.push(\n          addString(attrs.trigger),\n          addString(cleanURL(attrs.initialPageURL, includeHashFragment)),\n          addString(cleanURL(attrs.oldURL, includeHashFragment)),\n          addString(cleanURL(attrs.newURL, includeHashFragment)),\n          addString(attrs.customName),\n          isInitialPage ? '' : isRouteChange ? 1 : 2,\n          nullable(isInitialPage && queueTime, numeric, true) +\n          nullable(isInitialPage && appTime, numeric, true) +\n          nullable(attrs.oldRoute, addString, true) +\n          nullable(attrs.newRoute, addString, true) +\n          addString(attrs.id),\n          addString(node.id),\n          nullable(attrs.firstPaint, numeric, true) +\n          nullable(attrs.firstContentfulPaint, numeric, false)\n        )\n\n        var attrParts = addCustomAttributes(attrs.custom, addString)\n        children = children.concat(attrParts)\n        attrCount = attrParts.length\n\n        if (apmAttributes) {\n          childCount++\n          children.push('a,' + addString(apmAttributes))\n        }\n\n        break\n\n      case 2:\n        fields.push(\n          addString(params.method),\n          numeric(params.status),\n          addString(params.host),\n          addString(params.pathname),\n          numeric(metrics.txSize),\n          numeric(metrics.rxSize),\n          attrs.isFetch ? 1 : (attrs.isJSONP ? 2 : ''),\n          addString(node.id),\n          nullable(node.dt && node.dt.spanId, addString, true) +\n          nullable(node.dt && node.dt.traceId, addString, true) +\n          nullable(node.dt && node.dt.timestamp, numeric, false)\n        )\n        break\n\n      case 4:\n        var tracedTime = attrs.tracedTime\n        fields.push(\n          addString(attrs.name),\n          nullable(tracedTime, numeric, true) +\n          addString(node.id)\n        )\n        break\n    }\n\n    for (var i = 0; i < node.children.length; i++) {\n      addNode(node.children[i], children)\n    }\n\n    fields.unshift(\n      numeric(typeId),\n      numeric(childCount += attrCount)\n    )\n\n    nodeList.push(fields)\n\n    if (childCount) {\n      nodeList.push(children.join(';'))\n    }\n\n    if (hasNavTiming) {\n      // this build up the navTiming node\n      // it for each navTiming value (pre aggregated in nav-timing.js):\n      // we initialize the seperator to ',' (seperates the nodeType id from the first value)\n      // we initialize the navTiming node to 'b' (the nodeType id)\n      // if the value is present:\n      //   we add the seperator followed by the value\n      // otherwise\n      //   we add null seperator ('!') to the navTimingNode\n      //   we set the seperator to an empty string since we already wrote it above\n      //   the reason for writing the null seperator instead of setting the seperator\n      //   is to ensure we still write it if the null is the last navTiming value.\n\n      var seperator = ','\n      var navTimingNode = 'b'\n      var prev = 0\n\n      // get all navTiming values except navigationStart\n      // (since its the same as interaction.start)\n      // and limit to just the first 20 values we know about\n      mapOwn(navTiming.slice(1, 21), function (i, v) {\n        if (v !== void 0) {\n          navTimingNode += seperator + numeric(v - prev)\n          seperator = ','\n          prev = v\n        } else {\n          navTimingNode += seperator + '!'\n          seperator = ''\n        }\n      })\n      nodeList.push(navTimingNode)\n    } else if (typeId === 1) {\n      nodeList.push('')\n    }\n\n    return nodeList\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar loader = require(\"loader\")\nvar registerHandler = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar mapOwn = require(44)\nvar reduce = require(47)\nvar stringify = require(22)\nvar slice = require(45)\nvar parseUrl = require(38)\nvar config = require(39)\n\nif (!harvest.xhrUsable || !loader.xhrWrappable) return\n\nvar ptid = ''\nvar ignoredEvents = {mouseup: true, mousedown: true}\nvar toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n}\n\nvar rename = {\n  typing: {\n    keydown: true,\n    keyup: true,\n    keypress: true\n  },\n  mousing: {\n    mousemove: true,\n    mouseenter: true,\n    mouseleave: true,\n    mouseover: true,\n    mouseout: true\n  },\n  scrolling: {\n    scroll: true\n  },\n  touching: {\n    touchstart: true,\n    touchmove: true,\n    touchend: true,\n    touchcancel: true,\n    touchenter: true,\n    touchleave: true\n  }\n}\n\nvar trace = {}\nvar nodeCount = 0\nvar sentTrace = null\nvar harvestTimeSeconds = config.getConfiguration('stn.harvestTimeSeconds') || 10\nvar maxNodesPerHarvest = config.getConfiguration('stn.maxNodesPerHarvest') || 1000\n\nvar ee = require(\"ee\")\n\n// exports only used for testing\nmodule.exports = {\n  _takeSTNs: takeSTNs\n}\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.stn) return\n\nee.on('feat-stn', function () {\n  storeTiming(window.performance.timing)\n\n  harvest.on('resources', prepareHarvest)\n\n  var scheduler = new HarvestScheduler(loader, 'resources', { onFinished: onHarvestFinished, retryDelay: harvestTimeSeconds })\n  scheduler.runHarvest({ needResponse: true })\n\n  function onHarvestFinished(result) {\n    // start timer only if ptid was returned by server\n    if (result.sent && result.responseText && !ptid) {\n      ptid = result.responseText\n      scheduler.startTimer(harvestTimeSeconds)\n    }\n\n    if (result.sent && result.retry && sentTrace) {\n      mapOwn(sentTrace, function (name, nodes) {\n        mergeSTNs(name, nodes)\n      })\n      sentTrace = null\n    }\n  }\n\n  function prepareHarvest(options) {\n    if ((loader.now()) > (15 * 60 * 1000)) {\n      // been collecting for over 15 min, empty trace object and bail\n      scheduler.stopTimer()\n      trace = {}\n      return\n    }\n\n    // only send when there are more than 30 nodes to send\n    if (ptid && nodeCount <= 30) return\n\n    return takeSTNs(options.retry)\n  }\n\n  registerHandler('bst', storeEvent)\n  registerHandler('bstTimer', storeTimer)\n  registerHandler('bstResource', storeResources)\n  registerHandler('bstHist', storeHist)\n  registerHandler('bstXhrAgg', storeXhrAgg)\n  registerHandler('bstApi', storeSTN)\n  registerHandler('errorAgg', storeErrorAgg)\n})\n\nfunction storeTiming (_t) {\n  var key\n  var val\n  var timeOffset\n  var now = Date.now()\n\n  // loop iterates through prototype also (for FF)\n  for (key in _t) {\n    val = _t[key]\n\n    // ignore inherited methods, meaningless 0 values, and bogus timestamps\n    // that are in the future (Microsoft Edge seems to sometimes produce these)\n    if (!(typeof (val) === 'number' && val > 0 && val < now)) continue\n\n    timeOffset = _t[key] - loader.offset\n\n    storeSTN({\n      n: key,\n      s: timeOffset,\n      e: timeOffset,\n      o: 'document',\n      t: 'timing'\n    })\n  }\n}\n\nfunction storeTimer (target, start, end, type) {\n  var category = 'timer'\n  if (type === 'requestAnimationFrame') category = type\n\n  var evt = {\n    n: type,\n    s: start,\n    e: end,\n    o: 'window',\n    t: category\n  }\n\n  storeSTN(evt)\n}\n\nfunction storeEvent (currentEvent, target, start, end) {\n  // we find that certain events make the data too noisy to be useful\n  if (currentEvent.type in ignoredEvents) { return false }\n\n  var evt = {\n    n: evtName(currentEvent.type),\n    s: start,\n    e: end,\n    t: 'event'\n  }\n\n  try {\n    // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n    // it does not check currentEvent.currentTarget before calling getRootNode() on it\n    evt.o = evtOrigin(currentEvent.target, target)\n  } catch (e) {\n    evt.o = evtOrigin(null, target)\n  }\n\n  storeSTN(evt)\n}\n\nfunction evtName (type) {\n  var name = type\n\n  mapOwn(rename, function (key, val) {\n    if (type in val) name = key\n  })\n\n  return name\n}\n\nfunction evtOrigin (t, target) {\n  var origin = 'unknown'\n\n  if (t && t instanceof XMLHttpRequest) {\n    var params = ee.context(t).params\n    origin = params.status + ' ' + params.method + ': ' + params.host + params.pathname\n  } else if (t && typeof (t.tagName) === 'string') {\n    origin = t.tagName.toLowerCase()\n    if (t.id) origin += '#' + t.id\n    if (t.className) origin += '.' + slice(t.classList).join('.')\n  }\n\n  if (origin === 'unknown') {\n    if (target === document) origin = 'document'\n    else if (target === window) origin = 'window'\n    else if (target instanceof FileReader) origin = 'FileReader'\n  }\n\n  return origin\n}\n\nfunction storeHist (path, old, time) {\n  var node = {\n    n: 'history.pushState',\n    s: time,\n    e: time,\n    o: path,\n    t: old\n  }\n\n  storeSTN(node)\n}\n\nvar laststart = 0\n\nfunction storeResources (resources) {\n  resources.forEach(function (currentResource) {\n    var parsed = parseUrl(currentResource.name)\n    var res = {\n      n: currentResource.initiatorType,\n      s: currentResource.fetchStart | 0,\n      e: currentResource.responseEnd | 0,\n      o: parsed.protocol + '://' + parsed.hostname + ':' + parsed.port + parsed.pathname, // resource.name is actually a URL so it's the source\n      t: currentResource.entryType\n    }\n\n    // don't recollect old resources\n    if (res.s < laststart) return\n\n    laststart = res.s\n\n    storeSTN(res)\n  })\n}\n\nfunction storeErrorAgg (type, name, params, metrics) {\n  if (type !== 'err') return\n  var node = {\n    n: 'error',\n    s: metrics.time,\n    e: metrics.time,\n    o: params.message,\n    t: params.stackHash\n  }\n  storeSTN(node)\n}\n\nfunction storeXhrAgg (type, name, params, metrics) {\n  if (type !== 'xhr') return\n  var node = {\n    n: 'Ajax',\n    s: metrics.time,\n    e: metrics.time + metrics.duration,\n    o: params.status + ' ' + params.method + ': ' + params.host + params.pathname,\n    t: 'ajax'\n  }\n  storeSTN(node)\n}\n\nfunction storeSTN (stn) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[stn.n]\n  if (!traceArr) traceArr = trace[stn.n] = []\n\n  traceArr.push(stn)\n  nodeCount++\n}\n\nfunction mergeSTNs(key, nodes) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[key]\n  if (!traceArr) traceArr = trace[key] = []\n\n  trace[key] = nodes.concat(traceArr)\n  nodeCount += nodes.length\n}\n\nfunction takeSTNs (retry) {\n  storeResources(window.performance.getEntriesByType('resource'))\n  var stns = reduce(mapOwn(trace, function (name, nodes) {\n    if (!(name in toAggregate)) return nodes\n\n    return reduce(mapOwn(reduce(nodes.sort(byStart), smearEvtsByOrigin(name), {}), val), flatten, [])\n  }), flatten, [])\n\n  if (stns.length === 0) return {}\n\n  if (retry) {\n    sentTrace = trace\n  }\n  trace = {}\n  nodeCount = 0\n\n  var stnInfo = {\n    qs: {st: '' + loader.offset, ptid: ptid},\n    body: {res: stns}\n  }\n\n  if (!ptid) {\n    stnInfo.qs.ua = loader.info.userAttributes\n    stnInfo.qs.at = loader.info.atts\n    var ja = stringify(loader.info.jsAttributes)\n    stnInfo.qs.ja = ja === '{}' ? null : ja\n  }\n  return stnInfo\n}\n\nfunction byStart (a, b) {\n  return a.s - b.s\n}\n\nfunction smearEvtsByOrigin (name) {\n  var maxGap = toAggregate[name][0]\n  var maxLen = toAggregate[name][1]\n  var lastO = {}\n\n  return function (byOrigin, evt) {\n    var lastArr = byOrigin[evt.o]\n\n    lastArr || (lastArr = byOrigin[evt.o] = [])\n\n    var last = lastO[evt.o]\n\n    if (name === 'scrolling' && !trivial(evt)) {\n      lastO[evt.o] = null\n      evt.n = 'scroll'\n      lastArr.push(evt)\n    } else if (last && (evt.s - last.s) < maxLen && last.e > (evt.s - maxGap)) {\n      last.e = evt.e\n    } else {\n      lastO[evt.o] = evt\n      lastArr.push(evt)\n    }\n\n    return byOrigin\n  }\n}\n\nfunction val (key, value) {\n  return value\n}\n\nfunction flatten (a, b) {\n  return a.concat(b)\n}\n\nfunction trivial (node) {\n  var limit = 4\n  if (node && typeof node.e === 'number' && typeof node.s === 'number' && (node.e - node.s) < limit) return true\n  else return false\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar register = require(17)\nvar harvest = require(10)\nvar stringify = require(22)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar handle = require(\"handle\")\n\n// bail if not instrumented\nif (!loader.features.xhr) return\n\nharvest.on('jserrors', function () {\n  return { body: agg.take([ 'xhr' ]) }\n})\n\nee.on('feat-err', function () { register('xhr', storeXhr) })\n\nmodule.exports = storeXhr\n\nfunction storeXhr (params, metrics, start) {\n  metrics.time = start\n\n  var type = 'xhr'\n  var hash\n  if (params.cat) {\n    hash = stringify([params.status, params.cat])\n  } else {\n    hash = stringify([params.status, params.host, params.pathname])\n  }\n\n  handle('bstXhrAgg', [type, hash, params, metrics])\n  agg.store(type, hash, params, metrics)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stringsToParsedUrls = {}\n\nmodule.exports = function parseUrl (url) {\n  if (url in stringsToParsedUrls) {\n    return stringsToParsedUrls[url]\n  }\n\n  var urlEl = document.createElement('a')\n  var location = window.location\n  var ret = {}\n\n  // Use an anchor dom element to resolve the url natively.\n  urlEl.href = url\n\n  ret.port = urlEl.port\n\n  var firstSplit = urlEl.href.split('://')\n\n  if (!ret.port && firstSplit[1]) {\n    ret.port = firstSplit[1].split('/')[0].split('@').pop().split(':')[1]\n  }\n  if (!ret.port || ret.port === '0') ret.port = (firstSplit[0] === 'https' ? '443' : '80')\n\n  // Host not provided in IE for relative urls\n  ret.hostname = (urlEl.hostname || location.hostname)\n\n  ret.pathname = urlEl.pathname\n\n  ret.protocol = firstSplit[0]\n\n  // Pathname sometimes doesn't have leading slash (IE 8 and 9)\n  if (ret.pathname.charAt(0) !== '/') ret.pathname = '/' + ret.pathname\n\n  // urlEl.protocol is ':' in old ie when protocol is not specified\n  var sameProtocol = !urlEl.protocol || urlEl.protocol === ':' || urlEl.protocol === location.protocol\n  var sameDomain = urlEl.hostname === document.domain && urlEl.port === location.port\n\n  // urlEl.hostname is not provided by IE for relative urls, but relative urls are also same-origin\n  ret.sameOrigin = sameProtocol && (!urlEl.hostname || sameDomain)\n\n  // Only cache if url doesn't have a path\n  if (ret.pathname === '/') {\n    stringsToParsedUrls[url] = ret\n  }\n\n  return ret\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getConfiguration: getConfiguration\n}\n\nfunction getConfiguration(path) {\n  if (!NREUM.init) return\n  var val = NREUM.init\n  var parts = path.split('.')\n  for (var i = 0; i < parts.length - 1; i++) {\n    val = val[parts[i]]\n    if (typeof val !== 'object') return\n  }\n  val = val[parts[parts.length - 1]]\n  return val\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = function dataSize (data) {\n  if (typeof data === 'string' && data.length) return data.length\n  if (typeof data !== 'object') return undefined\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer && data.byteLength) return data.byteLength\n  if (typeof Blob !== 'undefined' && data instanceof Blob && data.size) return data.size\n  if (typeof FormData !== 'undefined' && data instanceof FormData) return undefined\n\n  try {\n    return JSON.stringify(data).length\n  } catch (e) {\n    return undefined\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = 0\nvar match = navigator.userAgent.match(/Firefox[\\/\\s](\\d+\\.\\d+)/)\nif (match) ffVersion = +match[1]\n\nmodule.exports = ffVersion\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar lastTimestamp = new Date().getTime()\nvar offset = lastTimestamp\n\nvar performanceCheck = require(46)\n\nmodule.exports = now\nmodule.exports.offset = offset\nmodule.exports.getLastTimestamp = getLastTimestamp\n\nfunction now () {\n  if (performanceCheck.exists && performance.now) {\n    return Math.round(performance.now())\n  }\n  // ensure a new timestamp is never smaller than a previous timestamp\n  return (lastTimestamp = Math.max(new Date().getTime(), lastTimestamp)) - offset\n}\n\nfunction getLastTimestamp() {\n  return lastTimestamp\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  generateUuid: generateUuid,\n  generateSpanId: generateSpanId,\n  generateTraceId: generateTraceId\n}\n\nfunction generateUuid () {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n\n  // v4 UUID\n  var template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  var id = ''\n  var c\n  for (var i = 0; i < template.length; i++) {\n    c = template[i]\n    if (c === 'x') {\n      id += getRandomValue().toString(16)\n    } else if (c === 'y') {\n      // this is the uuid variant per spec (8, 9, a, b)\n      // % 4, then shift to get values 8-11\n      c = getRandomValue() & 0x3 | 0x8\n      id += c.toString(16)\n    } else {\n      id += c\n    }\n  }\n\n  return id\n}\n\n// 16-character hex string (per DT spec)\nfunction generateSpanId () {\n  return generateRandomHexString(16)\n}\n\n// 32-character hex string (per DT spec)\nfunction generateTraceId() {\n  return generateRandomHexString(32)\n}\n\nfunction generateRandomHexString(length) {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues && Uint8Array) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  var chars = []\n  for (var i = 0; i < length; i++) {\n    chars.push(getRandomValue().toString(16))\n  }\n  return chars.join('')\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = mapOwn\n\nfunction mapOwn (obj, fn) {\n  var results = []\n  var key = ''\n  var i = 0\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      results[i] = fn(key, obj[key])\n      i += 1\n    }\n  }\n\n  return results\n}\n","/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  exists: typeof (window.performance) !== 'undefined' && window.performance.timing && typeof (window.performance.timing.navigationStart) !== 'undefined'\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = reduce\n\nfunction reduce (arr, fn, next) {\n  var i = 0\n  if (typeof next === 'undefined') {\n    next = arr[0]\n    i = 1\n  }\n\n  for (i; i < arr.length; i++) {\n    next = fn(next, arr[i])\n  }\n\n  return next\n}\n"],"sourceRoot":"/source/"}