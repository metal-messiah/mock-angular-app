{"version":3,"sources":["node_modules/browser-pack/_prelude.js","agent/add-e.js","nr.min.js","agent/aggregator.js","agent/api.js","agent/bel-serializer.js","agent/clean-url.js","agent/drain.js","agent/encode.js","agent/feature-flags.js","agent/harvest-scheduler.js","agent/harvest.js","agent/ie-version.js","agent/index.js","agent/location.js","agent/nav-cookie.js","agent/nav-timing.js","agent/paint-metrics.js","agent/register-handler.js","agent/s-hash.js","agent/single.js","agent/start-time.js","agent/stopwatch.js","agent/stringify.js","agent/submit-data.js","agent/timings.js","agent/unload.js","feature/err/aggregate/canonical-function-name.js","feature/err/aggregate/compute-stack-trace.js","feature/err/aggregate/format-stack-trace.js","feature/err/aggregate/index.js","feature/err/aggregate/string-hash-code.js","feature/ins/aggregate/index.js","feature/stn/aggregate/index.js","feature/xhr/aggregate/index.js","feature/xhr/instrument/parse-url.js","loader/config.js","loader/firefox-version.js","loader/now.js","map-own/index.js","node_modules/lodash._slice/index.js","performance-check/index.js","reduce/index.js"],"names":["modules","cache","entry","newRequire","name","jumped","currentRequire","__nr_require","previousRequire","Error","m","exports","call","x","id","i","length","1","require","module","sType","callback","window","addEventListener","attachEvent","2","store","type","params","newMetrics","customParams","bucket","getBucket","metrics","aggregateMetrics","oldMetrics","count","mapOwn","key","value","updateMetric","metric","c","createMetricObject","t","sos","max","min","mergeMetrics","oldMetric","newMetric","mergeMetric","Math","aggregatedData","custom","get","take","types","results","hasData","toArray","obj","getValue","merge","3","setPageViewName","host","charAt","loader","customTransaction","finished","providedTime","time","offset","agg","addToTrace","start","origin","handle","evt","report","n","s","e","end","o","inlineHit","request_name","queue_time","app_time","total_be_time","dom_time","fe_time","encodeURIComponent","cycle","info","beacon","url","scheme","licenseKey","applicationID","submitData","img","setErrorHandler","handler","onerror","addRelease","releaseCount","releaseIds","slice","register","harvest","single","config","getConfiguration","on","qs","api","fnName","fn","4","nullable","val","comma","numeric","noDefault","floor","toString","undefined","getAddStringContext","addString","str","String","hasOwnProp","stringTable","stringTableIdx","quoteString","Object","hasOwnProperty","create","addCustomAttributes","attrs","attrParts","MAX_ATTRIBUTES","serializedValue","stringify","push","replace","escapable","prototype","5","withHash","withoutHash","keepHash","6","emitEvent","groupHandlers","registration","sourceEE","ee","ctx","args","apply","baseEE","handlers","group","bufferedEventsInGroup","backlog","eventType","handlerRegistrationList","7","real","charMap","safeEncoded","fromArray","maxBytes","bytes","join","payload","total","result","feature","dataArray","next","intermediate","param","%2C","%3A","%2F","%40","%24","%3B","charList","k","RegExp","8","drain","flags","flag","activatedFeatures","emit","active","9","HarvestScheduler","endpoint","opts","this","started","timeoutHandle","startTimer","interval","initialDelay","scheduleHarvest","stopTimer","clearTimeout","delay","timer","setTimeout","runHarvest","onHarvestFinished","scheduler","getPayload","submitMethod","getSubmitMethod","retry","method","xhr","send","sendX","onFinished","sent","retryDelay","10","sendRUM","nr","queueTime","aggregator","applicationTime","stopwatch","measure","measuresMetrics","measuresQueryString","metricName","protocol","chunksForQueryString","baseQueryString","encode","ttGuid","user","account","product","features","performance","navTimingApiData","timing","addPT","navigation","addPN","getEntriesByType","entries","forEach","startTime","addPaintMetric","extra","userAttributes","atts","customJsAttributes","jsAttributes","queryString","jsonp","sendAllFromUnload","sents","_events","unload","reduce","or","a","b","createPayload","options","makeBody","createAccumulator","makeQueryString","listeners","singlePayload","body","cbFinished","_send","errorBeacon","cm","useBody","fullUrl","status","tooManyRequestsDelay","needResponse","responseText","xhrUsable","haveSendBeacon","pingErrors","ieVersion","transactionNameParam","transactionName","tNamePlain","listener","resetListeners","areCookiesEnabled","NREUM","init","privacy","cookies_enabled","sa","version","now","cleanURL","locationUtil","getLocation","accumulator","navigator","sendBeacon","addMetric","sendFinal","11","div","document","createElement","innerHTML","len","getElementsByTagName","12","finalHarvest","navCookie","conditionallySet","subscribeToUnload","registerHandler","activateFeatures","autorun","setToken","mark","13","location","14","exp","setCookie","cookie","Number","Date","sHash","href","referrer","15","pt","v","START","of","addRel","UNLOAD_EVENT","REDIRECT","END","DOMAIN_LOOKUP","ONNECT","REQUEST","RESPONSE","domLoading","domInteractive","DOM_CONTENT_LOAD_EVENT","domComplete","LOAD_EVENT","pn","redirectCount","prop","relativeValue","round","navTimingValues","nt","16","paintMetrics","17","defaultRegister","registerWithSpecificEmitter","handleEE","list","18","h","charCodeAt","abs","19","res","called","arguments","20","findStartTime","starttime","findStartWebTiming","findStartCookie","ffVersion","performanceCheck","exists","navigationStart","aCookies","split","indexOf","startPage","referrerPage","bReferrerMatch","aSubCookies","substring","j","substr","docReferrer","getTime","21","markName","markTime","marks","startMark","endMark","22","","err","quote","string","lastIndex","test","meta","holder","isFinite","partial","Array","\b","\t","\n","\f","\r","\"","\\","23","element","src","firstScript","parentNode","insertBefore","sync","request","XMLHttpRequest","open","withCredentials","setRequestHeader","xhrSync","Image","24","isEnabled","maxLCPTimeSeconds","initialHarvestSeconds","harvestTimeSeconds","prepareHarvest","processTiming","updateLatestLcp","updateClsScore","updatePageHide","recordLcp","lcpRecorded","lcp","lcpEntry","cls","size","eid","addTiming","previous","clsEntry","timestamp","state","pageHideRecorded","recordUnload","addCls","timings","timingsSent","appendGlobalCustomAttributes","timingAttributes","customAttributes","data","enabled","25","cb","oneCall","addE","26","canonicalFunctionName","orig","match","canonicalFunctionNameRe","27","computeStackTrace","ex","stack","computeStackTraceFromStacktraceProp","debug","computeStackTraceFromStackProp","computeStackTraceFromOperaMultiLineMessage","computeStackTraceBySourceAndLine","computeStackTraceWithMessageOnly","mode","stackString","frames","errorInfo","parseStackProp","stackLines","wrapperSeen","getClassName","message","formatStackTrace","line","getElement","isWrapper","func","parts","gecko","chrome","column","chrome_eval","ie_eval","className","sourceURL","classNameRegex","exec","constructor","functionName","stacktrace","testRE","lines","lineRE1","lineRE2","lineRE3","scripts","inlineScriptBlocks","has","item","28","truncateStackLines","truncatedLines","truncateSize","MAX_STACK_TRACE_LENGTH","stripNewlinesRegex","29","onHarvestStarted","currentBody","ri","errorOnPage","pve","getBucketName","nameHash","stringHashCode","exceptionClass","stackHash","canonicalizeURL","cleanedOrigin","cleanedURL","buildCanonicalStackString","stackInfo","canonicalStack","frame","canonicalizeStackURLs","originalURL","storeError","internal","setCustom","request_uri","pathname","stackReported","browser_stack_hash","stack_trace","hash","pageviewReported","pageview","_interactionId","errorCache","att","jsAttributesHash","aggregateHash","interaction","globalCustomParams","localCustomParams","root","browserInteractionId","_interactionNodeId","parentNodeId","30","charVal","31","ua","at","ins","events","currentEvents","concat","addPageAction","attributes","set","eventAttributes","eventsPerHarvest","width","height","documentElement","clientWidth","clientHeight","defaults","timeSinceLoad","browserWidth","browserHeight","referrerUrl","currentUrl","pageUrl","actionName","setCustomAttribute","eventsPerMinute","32","storeTiming","_t","timeOffset","storeSTN","storeTimer","target","category","storeEvent","currentEvent","ignoredEvents","evtName","evtOrigin","rename","context","tagName","toLowerCase","classList","FileReader","storeHist","path","old","node","storeResources","resources","currentResource","parsed","parseUrl","initiatorType","fetchStart","responseEnd","hostname","port","entryType","laststart","storeErrorAgg","storeXhrAgg","duration","stn","nodeCount","maxNodesPerHarvest","traceArr","trace","mergeSTNs","nodes","takeSTNs","stns","toAggregate","sort","byStart","smearEvtsByOrigin","flatten","sentTrace","stnInfo","st","ptid","ja","maxGap","maxLen","lastO","byOrigin","lastArr","last","trivial","limit","xhrWrappable","mouseup","mousedown","typing","scrolling","mousing","touching","keydown","keyup","keypress","mousemove","mouseenter","mouseleave","mouseover","mouseout","scroll","touchstart","touchmove","touchend","touchcancel","touchenter","touchleave","_takeSTNs","33","storeXhr","cat","34","stringsToParsedUrls","urlEl","ret","firstSplit","pop","sameProtocol","sameDomain","domain","sameOrigin","35","36","userAgent","37","lastTimestamp","getLastTimestamp","38","39","array","index","40","41","arr"],"mappings":"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","file":"nr.min.js","sourcesContent":["// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requireuires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  // Save the require from previous bundle to this closure if any\n  var previousRequire = typeof __nr_require === 'function' && __nr_require\n\n  function newRequire (name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire = typeof __nr_require === 'function' && __nr_require\n        if (!jumped && currentRequire) return currentRequire(name, true)\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) return previousRequire(name, true)\n        throw new Error(\"Cannot find module '\" + name + \"'\")\n      }\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  // Override the current require with this new one\n  return newRequire\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Safely add an event listener to window in any browser\nmodule.exports = function (sType, callback) {\n  if ('addEventListener' in window) {\n    return window.addEventListener(sType, callback, false)\n  } else if ('attachEvent' in window) {\n    return window.attachEvent('on' + sType, callback)\n  }\n}\n","// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requireuires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  // Save the require from previous bundle to this closure if any\n  var previousRequire = typeof __nr_require === 'function' && __nr_require\n\n  function newRequire (name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire = typeof __nr_require === 'function' && __nr_require\n        if (!jumped && currentRequire) return currentRequire(name, true)\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) return previousRequire(name, true)\n        throw new Error(\"Cannot find module '\" + name + \"'\")\n      }\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  // Override the current require with this new one\n  return newRequire\n})\n({1:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Safely add an event listener to window in any browser\nmodule.exports = function (sType, callback) {\n  if ('addEventListener' in window) {\n    return window.addEventListener(sType, callback, false)\n  } else if ('attachEvent' in window) {\n    return window.attachEvent('on' + sType, callback)\n  }\n}\n\n},{}],2:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\n\nvar aggregatedData = {}\n\nmodule.exports = {\n  store: store,\n  take: take,\n  get: get,\n  merge: mergeMetrics\n}\n\n// Items with the same type and name get aggregated together\n// params are example data from the aggregated items\n// metrics are the numeric values to be aggregated\nfunction store (type, name, params, newMetrics, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  bucket.metrics = aggregateMetrics(newMetrics, bucket.metrics)\n  return bucket\n}\n\nfunction aggregateMetrics (newMetrics, oldMetrics) {\n  if (!oldMetrics) oldMetrics = {count: 0}\n  oldMetrics.count += 1\n  mapOwn(newMetrics, function (key, value) {\n    oldMetrics[key] = updateMetric(value, oldMetrics[key])\n  })\n  return oldMetrics\n}\n\nfunction updateMetric (value, metric) {\n  // When there is only one data point, the c (count), min, max, and sos (sum of squares) params are superfluous.\n  if (!metric) return {t: value}\n\n  // but on the second data point, we need to calculate the other values before aggregating in new values\n  if (!metric.c) {\n    metric = createMetricObject(metric.t)\n  }\n\n  // at this point, metric is always uncondensed\n  metric.c += 1\n  metric.t += value\n  metric.sos += value * value\n  if (value > metric.max) metric.max = value\n  if (value < metric.min) metric.min = value\n\n  return metric\n}\n\n/**\n * Merge metrics object into existing metrics.\n *\n * @param {string} type\n * @param {string} name\n * @param {object} metrics - Metrics to merge.\n */\nfunction mergeMetrics (type, name, metrics, params, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  if (!bucket.metrics) {\n    bucket.metrics = metrics\n    return\n  }\n\n  var oldMetrics = bucket.metrics\n  oldMetrics.count += metrics.count\n\n  // iterate through each new metric and merge\n  mapOwn(metrics, function (key, value) {\n    // count is a special case handled above\n    if (key === 'count') return\n\n    var oldMetric = oldMetrics[key]\n    var newMetric = metrics[key]\n\n    // handling the case where newMetric is a single-value first\n    if (newMetric && !newMetric.c) {\n      oldMetrics[key] = updateMetric(newMetric.t, oldMetric)\n    } else { // newMetric is a metric object\n      oldMetrics[key] = mergeMetric(newMetric, oldMetrics[key])\n    }\n  })\n}\n\nfunction mergeMetric(newMetric, oldMetric) {\n  if (!oldMetric) return newMetric\n\n  if (!oldMetric.c) {\n    // oldMetric is a single-value\n    oldMetric = createMetricObject(oldMetric.t)\n  }\n\n  oldMetric.min = Math.min(newMetric.min, oldMetric.min)\n  oldMetric.max = Math.max(newMetric.max, oldMetric.max)\n  oldMetric.t += newMetric.t\n  oldMetric.sos += newMetric.sos\n  oldMetric.c += newMetric.c\n\n  return oldMetric\n}\n\n// take a value and create a metric object\nfunction createMetricObject (value) {\n  return {\n    t: value,\n    min: value,\n    max: value,\n    sos: value * value,\n    c: 1\n  }\n}\n\nfunction getBucket (type, name, params, customParams) {\n  if (!aggregatedData[type]) aggregatedData[type] = {}\n  var bucket = aggregatedData[type][name]\n  if (!bucket) {\n    bucket = aggregatedData[type][name] = { params: params || {} }\n    if (customParams) {\n      bucket.custom = customParams\n    }\n  }\n  return bucket\n}\n\nfunction get (type, name) {\n  // if name is passed, get a single bucket\n  if (name) return aggregatedData[type] && aggregatedData[type][name]\n  // else, get all buckets of that type\n  return aggregatedData[type]\n}\n\n// Like get, but for many types and it deletes the retrieved content from the aggregatedData\nfunction take (types) {\n  var results = {}\n  var type = ''\n  var hasData = false\n  for (var i = 0; i < types.length; i++) {\n    type = types[i]\n    results[type] = toArray(aggregatedData[type])\n    if (results[type].length) hasData = true\n    delete aggregatedData[type]\n  }\n  return hasData ? results : null\n}\n\nfunction toArray (obj) {\n  if (typeof obj !== 'object') return []\n\n  return mapOwn(obj, getValue)\n}\n\nfunction getValue (key, value) {\n  return value\n}\n\n},{}],3:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar register = require(17)\nvar harvest = require(10)\nvar agg = require(2)\nvar single = require(19)\nvar submitData = require(23)\nvar mapOwn = require(38)\nvar loader = require(\"loader\")\nvar handle = require(\"handle\")\nvar config = require(35)\nvar cycle = 0\n\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\nharvest.on('jserrors', function () {\n  return { qs: agg.take([ 'cm' ]) }\n})\n\nvar api = {\n  finished: single(finished),\n  setPageViewName: setPageViewName,\n  setErrorHandler: setErrorHandler,\n  addToTrace: addToTrace,\n  inlineHit: inlineHit,\n  addRelease: addRelease\n}\n\n// Hook all of the api functions up to the queues/stubs created in loader/api.js\nmapOwn(api, function (fnName, fn) {\n  register('api-' + fnName, fn, 'api')\n})\n\n// All API functions get passed the time they were called as their\n// first parameter. These functions can be called asynchronously.\n\nfunction setPageViewName (t, name, host) {\n  if (typeof name !== 'string') return\n  if (name.charAt(0) !== '/') name = '/' + name\n  loader.customTransaction = (host || 'http://custom.transaction') + name\n}\n\nfunction finished (t, providedTime) {\n  var time = providedTime ? providedTime - loader.offset : t\n  agg.store('cm', 'finished', { name: 'finished' }, { time: time })\n  addToTrace(t, { name: 'finished', start: time + loader.offset, origin: 'nr' })\n  handle('api-addPageAction', [ time, 'finished' ])\n}\n\nfunction addToTrace (t, evt) {\n  if (!(evt && typeof evt === 'object' && evt.name && evt.start)) return\n\n  var report = {\n    n: evt.name,\n    s: evt.start - loader.offset,\n    e: (evt.end || evt.start) - loader.offset,\n    o: evt.origin || '',\n    t: 'api'\n  }\n\n  handle('bstApi', [report])\n}\n\n// NREUM.inlineHit(request_name, queue_time, app_time, total_be_time, dom_time, fe_time)\n//\n// request_name - the 'web page' name or service name\n// queue_time - the amount of time spent in the app tier queue\n// app_time - the amount of time spent in the application code\n// total_be_time - the total roundtrip time of the remote service call\n// dom_time - the time spent processing the result of the service call (or user defined)\n// fe_time - the time spent rendering the result of the service call (or user defined)\nfunction inlineHit (t, request_name, queue_time, app_time, total_be_time, dom_time, fe_time) {\n  request_name = window.encodeURIComponent(request_name)\n  cycle += 1\n\n  if (!loader.info.beacon) return\n\n  var url = scheme + '://' + loader.info.beacon + '/1/' + loader.info.licenseKey\n\n  url += '?a=' + loader.info.applicationID + '&'\n  url += 't=' + request_name + '&'\n  url += 'qt=' + ~~queue_time + '&'\n  url += 'ap=' + ~~app_time + '&'\n  url += 'be=' + ~~total_be_time + '&'\n  url += 'dc=' + ~~dom_time + '&'\n  url += 'fe=' + ~~fe_time + '&'\n  url += 'c=' + cycle\n\n  submitData.img(url)\n}\n\nfunction setErrorHandler (t, handler) {\n  loader.onerror = handler\n}\n\nvar releaseCount = 0\nfunction addRelease (t, name, id) {\n  if (++releaseCount > 10) return\n  loader.releaseIds[name.slice(-200)] = ('' + id).slice(-200)\n}\n\n},{}],4:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\nvar stringify = require(22)\n\nvar hasOwnProp = Object.prototype.hasOwnProperty\nvar MAX_ATTRIBUTES = 64\n\nmodule.exports = {\n  nullable: nullable,\n  numeric: numeric,\n  getAddStringContext: getAddStringContext,\n  addCustomAttributes: addCustomAttributes\n}\n\nfunction nullable (val, fn, comma) {\n  return val || val === 0 || val === ''\n    ? fn(val) + (comma ? ',' : '')\n    : '!'\n}\n\nfunction numeric (n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36)\n  }\n  return (n === undefined || n === 0) ? '' : Math.floor(n).toString(36)\n}\n\nfunction getAddStringContext () {\n  var stringTable = Object.hasOwnProperty('create') ? Object.create(null) : {}\n  var stringTableIdx = 0\n\n  return addString\n\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return ''\n    str = String(str)\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true)\n    } else {\n      stringTable[str] = stringTableIdx++\n      return quoteString(str)\n    }\n  }\n}\n\nfunction addCustomAttributes (attrs, addString) {\n  var attrParts = []\n\n  mapOwn(attrs, function (key, val) {\n    if (attrParts.length >= MAX_ATTRIBUTES) return\n    var type = 5\n    var serializedValue\n    // add key to string table first\n    key = addString(key)\n\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val))\n        } else {\n          // null attribute type\n          type = 9\n        }\n        break\n      case 'number':\n        type = 6\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.'\n        break\n      case 'boolean':\n        type = val ? 7 : 8\n        break\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9\n        break\n      default:\n        serializedValue = addString(val)\n    }\n\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')])\n  })\n\n  return attrParts\n}\n\nvar escapable = /([,\\\\;])/g\n\nfunction quoteString (str) {\n  return \"'\" + str.replace(escapable, '\\\\$1')\n}\n\n},{}],5:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar withHash = /([^?#]*)[^#]*(#[^?]*|$).*/\nvar withoutHash = /([^?#]*)().*/\nmodule.exports = function cleanURL (url, keepHash) {\n  return url.replace(keepHash ? withHash : withoutHash, '$1$2')\n}\n\n},{}],6:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar baseEE = require(\"ee\")\nvar mapOwn = require(38)\nvar handlers = require(17).handlers\n\nmodule.exports = function drain (group) {\n  var bufferedEventsInGroup = baseEE.backlog[group]\n  var groupHandlers = handlers[group]\n  if (groupHandlers) {\n    // don't cache length, buffer can grow while processing\n    for (var i = 0; bufferedEventsInGroup && i < bufferedEventsInGroup.length; ++i) { // eslint-disable-line no-unmodified-loop-condition\n      emitEvent(bufferedEventsInGroup[i], groupHandlers)\n    }\n\n    mapOwn(groupHandlers, function (eventType, handlerRegistrationList) {\n      mapOwn(handlerRegistrationList, function (i, registration) {\n        // registration is an array of: [targetEE, eventHandler]\n        registration[0].on(eventType, registration[1])\n      })\n    })\n  }\n\n  delete handlers[group]\n  // Keep the group as a property so we know it was created and drained\n  baseEE.backlog[group] = null\n}\n\nfunction emitEvent (evt, groupHandlers) {\n  var type = evt[1]\n  mapOwn(groupHandlers[type], function (i, registration) {\n    var sourceEE = evt[0]\n    var ee = registration[0]\n    if (ee === sourceEE) {\n      var handler = registration[1]\n      var ctx = evt[3]\n      var args = evt[2]\n      handler.apply(ctx, args)\n    }\n  })\n}\n\n},{}],7:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\nvar stringify = require(22)\n\n  // Characters that are safe in a qs, but get encoded.\nvar charMap = {\n  '%2C': ',',\n  '%3A': ':',\n  '%2F': '/',\n  '%40': '@',\n  '%24': '$',\n  '%3B': ';'\n}\n\nvar charList = mapOwn(charMap, function (k) { return k })\nvar safeEncoded = new RegExp(charList.join('|'), 'g')\n\nfunction real (c) {\n  return charMap[c]\n}\n\n// Encode as URI Component, then unescape anything that is ok in the\n// query string position.\nfunction qs (value) {\n  if (value === null || value === undefined) return 'null'\n  return encodeURIComponent(value).replace(safeEncoded, real)\n}\n\nmodule.exports = {obj: obj, fromArray: fromArray, qs: qs, param: param}\n\nfunction fromArray (qs, maxBytes) {\n  var bytes = 0\n  for (var i = 0; i < qs.length; i++) {\n    bytes += qs[i].length\n    if (bytes > maxBytes) return qs.slice(0, i).join('')\n  }\n  return qs.join('')\n}\n\nfunction obj (payload, maxBytes) {\n  var total = 0\n  var result = ''\n\n  mapOwn(payload, function (feature, dataArray) {\n    var intermediate = []\n    var next\n    var i\n\n    if (typeof dataArray === 'string') {\n      next = '&' + feature + '=' + qs(dataArray)\n      total += next.length\n      result += next\n    } else if (dataArray.length) {\n      total += 9\n      for (i = 0; i < dataArray.length; i++) {\n        next = qs(stringify(dataArray[i]))\n        total += next.length\n        if (typeof maxBytes !== 'undefined' && total >= maxBytes) break\n        intermediate.push(next)\n      }\n      result += '&' + feature + '=%5B' + intermediate.join(',') + '%5D'\n    }\n  })\n  return result\n}\n\n// Constructs an HTTP parameter to add to the BAM router URL\nfunction param (name, value) {\n  if (value && typeof (value) === 'string') {\n    return '&' + name + '=' + qs(value)\n  }\n  return ''\n}\n\n},{}],8:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\nvar ee = require(\"ee\")\nvar drain = require(6)\n\nmodule.exports = function activateFeatures (flags) {\n  if (!(flags && typeof flags === 'object')) return\n  mapOwn(flags, function (flag, val) {\n    if (!val || activatedFeatures[flag]) return\n    ee.emit('feat-' + flag, [])\n    activatedFeatures[flag] = true\n  })\n\n  drain('feature')\n}\n\nvar activatedFeatures = module.exports.active = {}\n\n},{}],9:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar harvest = require(10)\nvar submitData = require(23)\n\nmodule.exports = HarvestScheduler\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nfunction HarvestScheduler(loader, endpoint, opts) {\n  this.loader = loader\n  this.endpoint = endpoint\n  this.opts = opts || {}\n  this.started = false\n  this.timeoutHandle = null\n}\n\nHarvestScheduler.prototype.startTimer = function startTimer(interval, initialDelay) {\n  this.interval = interval\n  this.started = true\n  this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval)\n}\n\nHarvestScheduler.prototype.stopTimer = function stopTimer() {\n  this.started = false\n  if (this.timeoutHandle) {\n    clearTimeout(this.timeoutHandle)\n  }\n}\n\nHarvestScheduler.prototype.scheduleHarvest = function scheduleHarvest(delay, opts) {\n  if (this.timeoutHandle) return\n  var timer = this\n\n  if (delay == null) {\n    delay = this.interval\n  }\n  this.timeoutHandle = setTimeout(function() {\n    timer.timeoutHandle = null\n    timer.runHarvest(opts)\n  }, delay * 1000)\n}\n\nHarvestScheduler.prototype.runHarvest = function runHarvest(opts) {\n  var scheduler = this\n\n  if (this.opts.getPayload) {\n    var submitMethod = harvest.getSubmitMethod(this.endpoint)\n    if (!submitMethod) return false\n\n    var retry = submitMethod.method === submitData.xhr\n    var payload = this.opts.getPayload({ retry: retry })\n    if (payload) {\n      harvest.send(this.endpoint, this.loader, payload, opts, submitMethod, onHarvestFinished)\n    }\n  } else {\n    harvest.sendX(this.endpoint, this.loader, opts, onHarvestFinished)\n  }\n\n  if (this.started) {\n    this.scheduleHarvest()\n  }\n\n  function onHarvestFinished(result) {\n    scheduler.onHarvestFinished(opts, result)\n  }\n}\n\nHarvestScheduler.prototype.onHarvestFinished = function onHarvestFinished(opts, result) {\n  if (this.opts.onFinished) {\n    this.opts.onFinished(result)\n  }\n\n  if (result.sent && result.retry) {\n    var delay = result.delay || this.opts.retryDelay\n    // reschedule next harvest if should be delayed longer\n    if (this.started && delay) {\n      clearTimeout(this.timeoutHandle)\n      this.timeoutHandle = null\n      this.scheduleHarvest(delay, opts)\n    } else if (!this.started && delay) {\n      // if not running on a timer, schedule a single retry\n      this.scheduleHarvest(delay, opts)\n    }\n  }\n}\n\n},{}],10:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar single = require(19)\nvar mapOwn = require(38)\nvar timing = require(15)\nvar encode = require(7)\nvar stringify = require(22)\nvar submitData = require(23)\nvar reduce = require(41)\nvar aggregator = require(2)\nvar stopwatch = require(21)\nvar locationUtil = require(13)\nvar config = require(35)\n\nvar cleanURL = require(5)\n\nvar version = 'DEVELOPMENT'\nvar jsonp = 'NREUM.setToken'\nvar _events = {}\nvar haveSendBeacon = !!navigator.sendBeacon\nvar tooManyRequestsDelay = config.getConfiguration('harvest.tooManyRequestsDelay') || 60\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\n// requiring ie version updates the IE version on the loader object\nvar ieVersion = require(11)\nvar xhrUsable = ieVersion > 9 || ieVersion === 0\n\nvar addPaintMetric = require(16).addMetric\n\nmodule.exports = {\n  sendRUM: single(sendRUM), // wrapping this in single makes it so that it can only be called once from outside\n  sendFinal: sendAllFromUnload,\n  pingErrors: pingErrors,\n  sendX: sendX,\n  send: send,\n  on: on,\n  xhrUsable: xhrUsable,\n  resetListeners: resetListeners,\n  getSubmitMethod: getSubmitMethod\n}\n\n// nr is injected into all send methods. This allows for easier testing\n// we could require('loader') instead\nfunction sendRUM (nr) {\n  if (!nr.info.beacon) return\n  if (nr.info.queueTime) aggregator.store('measures', 'qt', { value: nr.info.queueTime })\n  if (nr.info.applicationTime) aggregator.store('measures', 'ap', { value: nr.info.applicationTime })\n\n  // some time in the past some code will have called stopwatch.mark('starttime', Date.now())\n  // calling measure like this will create a metric that measures the time differential between\n  // the two marks.\n  stopwatch.measure('be', 'starttime', 'firstbyte')\n  stopwatch.measure('fe', 'firstbyte', 'onload')\n  stopwatch.measure('dc', 'firstbyte', 'domContent')\n\n  var measuresMetrics = aggregator.get('measures')\n\n  var measuresQueryString = mapOwn(measuresMetrics, function (metricName, measure) {\n    return '&' + metricName + '=' + measure.params.value\n  }).join('')\n\n  if (measuresQueryString) {\n    // currently we only have one version of our protocol\n    // in the future we may add more\n    var protocol = '1'\n\n    var chunksForQueryString = [baseQueryString(nr)]\n\n    chunksForQueryString.push(measuresQueryString)\n\n    chunksForQueryString.push(encode.param('tt', nr.info.ttGuid))\n    chunksForQueryString.push(encode.param('us', nr.info.user))\n    chunksForQueryString.push(encode.param('ac', nr.info.account))\n    chunksForQueryString.push(encode.param('pr', nr.info.product))\n    chunksForQueryString.push(encode.param('af', mapOwn(nr.features, function (k) { return k }).join(',')))\n\n    if (window.performance && typeof (window.performance.timing) !== 'undefined') {\n      var navTimingApiData = ({\n        timing: timing.addPT(window.performance.timing, {}),\n        navigation: timing.addPN(window.performance.navigation, {})\n      })\n      chunksForQueryString.push(encode.param('perf', stringify(navTimingApiData)))\n    }\n\n    if (window.performance && window.performance.getEntriesByType) {\n      var entries = window.performance.getEntriesByType('paint')\n      if (entries && entries.length > 0) {\n        entries.forEach(function(entry) {\n          if (!entry.startTime || entry.startTime <= 0) return\n\n          if (entry.name === 'first-paint') {\n            chunksForQueryString.push(encode.param('fp',\n              String(Math.floor(entry.startTime))))\n          } else if (entry.name === 'first-contentful-paint') {\n            chunksForQueryString.push(encode.param('fcp',\n              String(Math.floor(entry.startTime))))\n          }\n          addPaintMetric(entry.name, Math.floor(entry.startTime))\n        })\n      }\n    }\n\n    chunksForQueryString.push(encode.param('xx', nr.info.extra))\n    chunksForQueryString.push(encode.param('ua', nr.info.userAttributes))\n    chunksForQueryString.push(encode.param('at', nr.info.atts))\n\n    var customJsAttributes = stringify(nr.info.jsAttributes)\n    chunksForQueryString.push(encode.param('ja', customJsAttributes === '{}' ? null : customJsAttributes))\n\n    var queryString = encode.fromArray(chunksForQueryString, nr.maxBytes)\n\n    submitData.jsonp(\n      scheme + '://' + nr.info.beacon + '/' + protocol + '/' + nr.info.licenseKey + queryString,\n      jsonp\n    )\n  }\n}\n\nfunction sendAllFromUnload (nr) {\n  var sents = mapOwn(_events, function (endpoint) {\n    return sendX(endpoint, nr, { unload: true })\n  })\n  return reduce(sents, or)\n}\n\nfunction or (a, b) { return a || b }\n\nfunction createPayload (type, options) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  var listeners = (_events[type] && _events[type] || [])\n\n  for (var i = 0; i < listeners.length; i++) {\n    var singlePayload = listeners[i](options)\n    if (!singlePayload) continue\n    if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n    if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n  }\n  return { body: makeBody(), qs: makeQueryString() }\n}\n\n/**\n * Initiate a harvest from multiple sources. An event that corresponds to the endpoint\n * name is emitted, which gives any listeners the opportunity to provide payload data.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction sendX (endpoint, nr, opts, cbFinished) {\n  var submitMethod = getSubmitMethod(endpoint, opts)\n  if (!submitMethod) return false\n  var options = {\n    retry: submitMethod.method === submitData.xhr\n  }\n  return _send(endpoint, nr, createPayload(endpoint, options), opts, submitMethod, cbFinished)\n}\n\n/**\n * Initiate a harvest call.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} singlePayload - Object representing payload.\n * @param {object} singlePayload.qs - Map of values that should be sent as part of the request query string.\n * @param {string} singlePayload.body - String that should be sent as the body of the request.\n * @param {string} singlePayload.body.e - Special case of body used for browser interactions.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction send (endpoint, nr, singlePayload, opts, submitMethod, cbFinished) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n  if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n\n  var payload = { body: makeBody(), qs: makeQueryString() }\n  return _send(endpoint, nr, payload, opts, submitMethod, cbFinished)\n}\n\nfunction _send (endpoint, nr, payload, opts, submitMethod, cbFinished) {\n  if (!nr.info.errorBeacon) return false\n\n  // custom metrics data (cm) is sent as a query parameter to /jserrors\n  if (!payload.body && !(endpoint === 'jserrors' && payload.qs && payload.qs.cm)) {\n    if (cbFinished) {\n      cbFinished({ sent: false })\n    }\n    return false\n  }\n\n  if (!opts) opts = {}\n\n  var url = scheme + '://' + nr.info.errorBeacon + '/' + endpoint + '/1/' + nr.info.licenseKey + baseQueryString(nr)\n  if (payload.qs) url += encode.obj(payload.qs, nr.maxBytes)\n\n  if (!submitMethod) {\n    submitMethod = getSubmitMethod(endpoint, opts)\n  }\n  var method = submitMethod.method\n  var useBody = submitMethod.useBody\n\n  var body\n  var fullUrl = url\n  if (useBody && endpoint === 'events') {\n    body = payload.body.e\n  } else if (useBody) {\n    body = stringify(payload.body)\n  } else {\n    fullUrl = url + encode.obj(payload.body, nr.maxBytes)\n  }\n\n  var result = method(fullUrl, body)\n\n  if (cbFinished && method === submitData.xhr) {\n    var xhr = result\n    xhr.addEventListener('load', function () {\n      var result = { sent: true }\n      if (this.status === 429) {\n        result.retry = true\n        result.delay = tooManyRequestsDelay\n      } else if (this.status === 408 || this.status === 500 || this.status === 503) {\n        result.retry = true\n      }\n\n      if (opts.needResponse) {\n        result.responseText = this.responseText\n      }\n      cbFinished(result)\n    }, false)\n  }\n\n  // if beacon request failed, retry with an alternative method\n  if (!result && method === submitData.beacon) {\n    method = submitData.img\n    result = method(url + encode.obj(payload.body, nr.maxBytes))\n  }\n\n  return result\n}\n\nfunction getSubmitMethod(endpoint, opts) {\n  opts = opts || {}\n  var method\n  var useBody\n\n  if (opts.needResponse) {\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else {\n      return false\n    }\n  } else if (opts.unload) {\n    useBody = haveSendBeacon\n    method = haveSendBeacon ? submitData.beacon : submitData.img\n  } else {\n    // `submitData.beacon` was removed, there is an upper limit to the\n    // number of data allowed before it starts failing, so we save it for\n    // unload data\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else if (endpoint === 'events' || endpoint === 'jserrors') {\n      method = submitData.img\n    } else {\n      return false\n    }\n  }\n\n  return {\n    method: method,\n    useBody: useBody\n  }\n}\n\nfunction pingErrors (nr) {\n  if (scheme === 'http' || !(nr && nr.info && nr.info.errorBeacon && nr.ieVersion)) return\n\n  var url = 'https://' + nr.info.errorBeacon + '/jserrors/ping/' + nr.info.licenseKey + baseQueryString(nr)\n\n  submitData.img(url)\n}\n\n// Constructs the transaction name param for the beacon URL.\n// Prefers the obfuscated transaction name over the plain text.\n// Falls back to making up a name.\nfunction transactionNameParam (nr) {\n  if (nr.info.transactionName) return encode.param('to', nr.info.transactionName)\n  return encode.param('t', nr.info.tNamePlain || 'Unnamed Transaction')\n}\n\nfunction on (type, listener) {\n  var listeners = (_events[type] || (_events[type] = []))\n  listeners.push(listener)\n}\n\nfunction resetListeners() {\n  mapOwn(_events, function(key) {\n    _events[key] = []\n  })\n}\n\n// The stuff that gets sent every time.\nfunction baseQueryString (nr) {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  return ([\n    '?a=' + nr.info.applicationID,\n    encode.param('sa', (nr.info.sa ? '' + nr.info.sa : '')),\n    encode.param('v', version),\n    transactionNameParam(nr),\n    encode.param('ct', nr.customTransaction),\n    '&rst=' + nr.now(),\n    '&ck=' + (areCookiesEnabled ? '1' : '0'),\n    encode.param('ref', cleanURL(locationUtil.getLocation()))\n  ].join(''))\n}\n\n// returns a function that can be called to accumulate values to a single object\n// when the function is called without parameters, then the accumulator is returned\nfunction createAccumulator () {\n  var accumulator = {}\n  var hasData = false\n  return function (key, val) {\n    if (val && val.length) {\n      accumulator[key] = val\n      hasData = true\n    }\n    if (hasData) return accumulator\n  }\n}\n\n},{}],11:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar div = document.createElement('div')\n\ndiv.innerHTML = '<!--[if lte IE 6]><div></div><![endif]-->' +\n  '<!--[if lte IE 7]><div></div><![endif]-->' +\n  '<!--[if lte IE 8]><div></div><![endif]-->' +\n  '<!--[if lte IE 9]><div></div><![endif]-->'\n\nvar len = div.getElementsByTagName('div').length\n\nvar ieVersion\nif (len === 4) ieVersion = 6\nelse if (len === 3) ieVersion = 7\nelse if (len === 2) ieVersion = 8\nelse if (len === 1) ieVersion = 9\nelse ieVersion = 0\n\nmodule.exports = ieVersion\n\n},{}],12:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stopwatch = require(21)\nvar subscribeToUnload = require(25)\nvar harvest = require(10)\nvar registerHandler = require(17)\nvar activateFeatures = require(8)\nvar loader = require(\"loader\")\nvar drain = require(6)\nvar navCookie = require(14)\nvar config = require(35)\n\n// api loads registers several event listeners, but does not have any exports\nrequire(3)\n\n// Register event listeners and schedule harvests for performance timings.\nrequire(24).init(loader, config.getConfiguration('page_view_timing'))\n\nvar autorun = typeof (window.NREUM.autorun) !== 'undefined' ? window.NREUM.autorun : true\n\n// Features are activated using the legacy setToken function name via JSONP\nwindow.NREUM.setToken = activateFeatures\n\nif (require(11) === 6) loader.maxBytes = 2000\nelse loader.maxBytes = 30000\n\nloader.releaseIds = {}\n\nsubscribeToUnload(finalHarvest)\n\nregisterHandler('mark', stopwatch.mark, 'api')\n\nstopwatch.mark('done')\n\ndrain('api')\n\nif (autorun) harvest.sendRUM(loader)\n\n// Set a cookie when the page unloads. Consume this cookie on the next page to get a 'start time'.\n// The navigation start time cookie is removed when the browser supports the web timing API.\n// Doesn't work in some browsers (Opera).\nfunction finalHarvest (e) {\n  harvest.sendFinal(loader, false)\n  // write navigation start time cookie if needed\n  navCookie.conditionallySet()\n}\n\n},{}],13:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getLocation: getLocation\n}\n\nfunction getLocation() {\n  return '' + location\n}\n\n},{}],14:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar sHash = require(18)\nvar startTime = require(20)\n\n// functions are on object, so that they can be mocked\nvar exp = {\n  conditionallySet: conditionallySet,\n  setCookie: setCookie\n}\n\nmodule.exports = exp\n\nfunction conditionallySet() {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  if (startTime.navCookie && areCookiesEnabled) {\n    exp.setCookie()\n  }\n}\n\nfunction setCookie() {\n  document.cookie = 'NREUM=s=' + Number(new Date()) + '&r=' + sHash(document.location.href) + '&p=' + sHash(document.referrer) + '; path=/'\n}\n\n},{}],15:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\n\nvar START = 'Start'\nvar END = 'End'\nvar UNLOAD_EVENT = 'unloadEvent'\nvar REDIRECT = 'redirect'\nvar DOMAIN_LOOKUP = 'domainLookup'\nvar ONNECT = 'onnect'\nvar REQUEST = 'request'\nvar RESPONSE = 'response'\nvar LOAD_EVENT = 'loadEvent'\nvar DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent'\n\nvar navTimingValues = []\nmodule.exports = {\n  addPT: addPT,\n  addPN: addPN,\n  nt: navTimingValues\n}\n\nfunction addPT (pt, v) {\n  var offset = pt['navigation' + START]\n  v.of = offset\n  addRel(offset, offset, v, 'n')\n  addRel(pt[UNLOAD_EVENT + START], offset, v, 'u')\n  addRel(pt[REDIRECT + START], offset, v, 'r')\n  addRel(pt[UNLOAD_EVENT + END], offset, v, 'ue')\n  addRel(pt[REDIRECT + END], offset, v, 're')\n  addRel(pt['fetch' + START], offset, v, 'f')\n  addRel(pt[DOMAIN_LOOKUP + START], offset, v, 'dn')\n  addRel(pt[DOMAIN_LOOKUP + END], offset, v, 'dne')\n  addRel(pt['c' + ONNECT + START], offset, v, 'c')\n  addRel(pt['secureC' + ONNECT + 'ion' + START], offset, v, 's')\n  addRel(pt['c' + ONNECT + END], offset, v, 'ce')\n  addRel(pt[REQUEST + START], offset, v, 'rq')\n  addRel(pt[RESPONSE + START], offset, v, 'rp')\n  addRel(pt[RESPONSE + END], offset, v, 'rpe')\n  addRel(pt.domLoading, offset, v, 'dl')\n  addRel(pt.domInteractive, offset, v, 'di')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + START], offset, v, 'ds')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + END], offset, v, 'de')\n  addRel(pt.domComplete, offset, v, 'dc')\n  addRel(pt[LOAD_EVENT + START], offset, v, 'l')\n  addRel(pt[LOAD_EVENT + END], offset, v, 'le')\n  return v\n}\n\n// Add Performance Navigation values to the given object\nfunction addPN (pn, v) {\n  addRel(pn.type, 0, v, 'ty')\n  addRel(pn.redirectCount, 0, v, 'rc')\n  return v\n}\n\nfunction addRel (value, offset, obj, prop) {\n  var relativeValue\n  if (typeof (value) === 'number' && (value > 0)) {\n    relativeValue = Math.round(value - offset)\n    obj[prop] = relativeValue\n  }\n  navTimingValues.push(relativeValue)\n}\n\n},{}],16:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar paintMetrics = {}\n\nmodule.exports = {\n  addMetric: addMetric,\n  metrics: paintMetrics\n}\n\nfunction addMetric (name, value) {\n  paintMetrics[name] = value\n}\n\n},{}],17:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handleEE = require(\"handle\").ee\n\nmodule.exports = defaultRegister\n\ndefaultRegister.on = registerWithSpecificEmitter\n\nvar handlers = defaultRegister.handlers = {}\n\nfunction defaultRegister (type, handler, group, ee) {\n  registerWithSpecificEmitter(ee || handleEE, type, handler, group)\n}\n\nfunction registerWithSpecificEmitter (ee, type, handler, group) {\n  if (!group) group = 'feature'\n  if (!ee) ee = handleEE\n  var groupHandlers = handlers[group] = handlers[group] || {}\n  var list = groupHandlers[type] = groupHandlers[type] || []\n  list.push([ee, handler])\n}\n\n},{}],18:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = sHash\n\nfunction sHash (s) {\n  var i\n  var h = 0\n\n  for (i = 0; i < s.length; i++) {\n    h += ((i + 1) * s.charCodeAt(i))\n  }\n  return Math.abs(h)\n}\n\n},{}],19:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar slice = require(39)\n\nmodule.exports = single\n\nfunction single (fn) {\n  var called = false\n  var res\n\n  return function () {\n    if (called) return res\n    called = true\n    res = fn.apply(this, slice(arguments))\n    return res\n  }\n}\n\n},{}],20:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Use various techniques to determine the time at which this page started and whether to capture navigation timing information\n\nvar sHash = require(18)\nvar stopwatch = require(21)\nvar loader = require(\"loader\")\nvar ffVersion = require(36)\n\nmodule.exports = { navCookie: true }\n\nfindStartTime()\n\nfunction findStartTime () {\n  var starttime = findStartWebTiming() || findStartCookie()\n\n  if (!starttime) return\n\n  stopwatch.mark('starttime', starttime)\n  // Refine loader.offset\n  loader.offset = starttime\n}\n\n// Find the start time from the Web Timing 'performance' object.\n// http://test.w3.org/webperf/specs/NavigationTiming/\n// http://blog.chromium.org/2010/07/do-you-know-how-slow-your-web-page-is.html\nfunction findStartWebTiming () {\n  // FF 7/8 has a bug with the navigation start time, so use cookie instead of native interface\n  if (ffVersion && ffVersion < 9) return\n\n  var performanceCheck = require(40)\n  if (performanceCheck.exists) {\n    // note that we don't need to use a cookie to record navigation start time\n    module.exports.navCookie = false\n    return window.performance.timing.navigationStart\n  }\n}\n\n// Find the start time based on a cookie set by Episodes in the unload handler.\nfunction findStartCookie () {\n  var aCookies = document.cookie.split(' ')\n\n  for (var i = 0; i < aCookies.length; i++) {\n    if (aCookies[i].indexOf('NREUM=') === 0) {\n      var startPage\n      var referrerPage\n      var aSubCookies = aCookies[i].substring('NREUM='.length).split('&')\n      var startTime\n      var bReferrerMatch\n\n      for (var j = 0; j < aSubCookies.length; j++) {\n        if (aSubCookies[j].indexOf('s=') === 0) {\n          startTime = aSubCookies[j].substring(2)\n        } else if (aSubCookies[j].indexOf('p=') === 0) {\n          referrerPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (referrerPage.charAt(referrerPage.length - 1) === ';') {\n            referrerPage = referrerPage.substr(0, referrerPage.length - 1)\n          }\n        } else if (aSubCookies[j].indexOf('r=') === 0) {\n          startPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (startPage.charAt(startPage.length - 1) === ';') {\n            startPage = startPage.substr(0, startPage.length - 1)\n          }\n        }\n      }\n\n      if (startPage) {\n        var docReferrer = sHash(document.referrer)\n        bReferrerMatch = (docReferrer == startPage) // eslint-disable-line\n        if (!bReferrerMatch) {\n          // Navigation did not start at the page that was just exited, check for re-load\n          // (i.e. the page just exited is the current page and the referring pages match)\n          bReferrerMatch = sHash(document.location.href) == startPage && docReferrer == referrerPage // eslint-disable-line\n        }\n      }\n      if (bReferrerMatch && startTime) {\n        var now = new Date().getTime()\n        if ((now - startTime) > 60000) {\n          return\n        }\n        return startTime\n      }\n    }\n  }\n}\n\n},{}],21:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar aggregator = require(2)\nvar now = require(37)\n\nvar marks = {}\n\nmodule.exports = {\n  mark: mark,\n  measure: measure\n}\n\nfunction mark (markName, markTime) {\n  if (typeof markTime === 'undefined') markTime = (now() + now.offset)\n  marks[markName] = markTime\n}\n\nfunction measure (metricName, startMark, endMark) {\n  var start = marks[startMark]\n  var end = marks[endMark]\n\n  if (typeof start === 'undefined' || typeof end === 'undefined') return\n\n  aggregator.store('measures', metricName, { value: end - start })\n}\n\n},{}],22:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\nvar ee = require(\"ee\")\n\nvar escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g // eslint-disable-line\nvar meta = {\n  '\\b': '\\\\b',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\f': '\\\\f',\n  '\\r': '\\\\r',\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\'\n}\n\nmodule.exports = stringify\n\nfunction stringify (val) {\n  try {\n    return str('', {'': val})\n  } catch (e) {\n    try {\n      ee.emit('internal-error', [e])\n    } catch (err) {\n    }\n  }\n}\n\nfunction quote (string) {\n  escapable.lastIndex = 0\n  return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n    var c = meta[a]\n    return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4)\n  }) + '\"' : '\"' + string + '\"'\n}\n\nfunction str (key, holder) {\n  var value = holder[key]\n\n  switch (typeof value) {\n    case 'string':\n      return quote(value)\n    case 'number':\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return String(value)\n    case 'object':\n      if (!value) { return 'null' }\n      var partial = []\n\n      // The value is an array. Stringify every element. Use null as a placeholder\n      // for non-JSON values.\n      if (value instanceof window.Array || Object.prototype.toString.apply(value) === '[object Array]') {\n        var length = value.length\n        for (var i = 0; i < length; i += 1) {\n          partial[i] = str(i, value) || 'null'\n        }\n\n        return partial.length === 0 ? '[]' : '[' + partial.join(',') + ']'\n      }\n\n      mapOwn(value, function (k) {\n        var v = str(k, value)\n        if (v) partial.push(quote(k) + ':' + v)\n      })\n\n      return partial.length === 0 ? '{}' : '{' + partial.join(',') + '}'\n  }\n}\n\n},{}],23:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar submitData = module.exports = {}\n\nsubmitData.jsonp = function jsonp (url, jsonp) {\n  var element = document.createElement('script')\n  element.type = 'text/javascript'\n  element.src = url + '&jsonp=' + jsonp\n  var firstScript = document.getElementsByTagName('script')[0]\n  firstScript.parentNode.insertBefore(element, firstScript)\n  return element\n}\n\nsubmitData.xhr = function xhr (url, body, sync) {\n  var request = new XMLHttpRequest()\n\n  request.open('POST', url, !sync)\n  try {\n    // Set cookie\n    if ('withCredentials' in request) request.withCredentials = true\n  } catch (e) {}\n\n  request.setRequestHeader('content-type', 'text/plain')\n  request.send(body)\n  return request\n}\n\nsubmitData.xhrSync = function xhrSync (url, body) {\n  return submitData.xhr(url, body, true)\n}\n\nsubmitData.img = function img (url) {\n  var element = new Image()\n  element.src = url\n  return element\n}\n\nsubmitData.beacon = function (url, body) {\n  return navigator.sendBeacon(url, body)\n}\n\n},{}],24:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar nullable = require(4).nullable\nvar numeric = require(4).numeric\nvar getAddStringContext = require(4).getAddStringContext\nvar addCustomAttributes = require(4).addCustomAttributes\nvar now = require(37)\nvar mapOwn = require(38)\n\nvar loader = null\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar register = require(17)\nvar subscribeToUnload = require(25)\n\nvar timings = []\nvar timingsSent = []\nvar lcpRecorded = false\nvar lcp = null\nvar cls = null\nvar pageHideRecorded = false\n\nmodule.exports = {\n  getPayload: getPayload,\n  timings: timings,\n  init: init,\n  finalHarvest: finalHarvest\n}\n\nvar harvestTimeSeconds = 30\n\nfunction init(nr, options) {\n  if (!isEnabled(options)) return\n\n  loader = nr\n\n  if (!options) options = {}\n  var maxLCPTimeSeconds = options.maxLCPTimeSeconds || 60\n  var initialHarvestSeconds = options.initialHarvestSeconds || 10\n  harvestTimeSeconds = options.harvestTimeSeconds || 30\n\n  var scheduler = new HarvestScheduler(loader, 'events', { onFinished: onHarvestFinished, getPayload: prepareHarvest })\n\n  register('timing', processTiming)\n  register('lcp', updateLatestLcp)\n  register('cls', updateClsScore)\n  register('pageHide', updatePageHide)\n\n  // final harvest is initiated from the main agent module, but since harvesting\n  // here is not initiated by the harvester, we need to subscribe to the unload event\n  // separately\n  subscribeToUnload(finalHarvest)\n\n  // After 1 minute has passed, record LCP value if no user interaction has occurred first\n  setTimeout(function() {\n    recordLcp()\n    lcpRecorded = true\n  }, maxLCPTimeSeconds * 1000)\n\n  // send initial data sooner, then start regular\n  scheduler.startTimer(harvestTimeSeconds, initialHarvestSeconds)\n}\n\nfunction recordLcp() {\n  if (!lcpRecorded && lcp !== null) {\n    var lcpEntry = lcp[0]\n    var cls = lcp[1]\n\n    var attrs = {\n      'size': lcpEntry.size,\n      'eid': lcpEntry.id\n    }\n\n    if (cls) {\n      attrs['cls'] = cls\n    }\n\n    addTiming('lcp', Math.floor(lcpEntry.startTime), attrs, false)\n    lcpRecorded = true\n  }\n}\n\nfunction updateLatestLcp(lcpEntry) {\n  if (lcp) {\n    var previous = lcp[0]\n    if (previous.size >= lcpEntry.size) {\n      return\n    }\n  }\n  lcp = [lcpEntry, cls]\n}\n\nfunction updateClsScore(clsEntry) {\n  if (cls === null) {\n    cls = 0\n  }\n  cls += clsEntry.value\n}\n\nfunction updatePageHide(timestamp, state) {\n  if (!pageHideRecorded && state === 'hidden') {\n    addTiming('pageHide', timestamp, null, true)\n    pageHideRecorded = true\n  }\n}\n\nfunction recordUnload() {\n  addTiming('unload', now(), null, true)\n}\n\nfunction addTiming(name, value, attrs, addCls) {\n  attrs = attrs || {}\n\n  if (addCls && cls !== null) {\n    attrs['cls'] = cls\n  }\n\n  timings.push({\n    name: name,\n    value: value,\n    attrs: attrs\n  })\n}\n\nfunction processTiming(name, value, attrs) {\n  // Upon user interaction, the Browser stops executing LCP logic, so we can send here\n  // We're using setTimeout to give the Browser time to finish collecting LCP value\n  if (name === 'fi') {\n    setTimeout(recordLcp, 0)\n  }\n\n  addTiming(name, value, attrs, true)\n}\n\nfunction onHarvestFinished(result) {\n  if (result.retry && timingsSent.length > 0) {\n    for (var i = 0; i < timingsSent.length; i++) {\n      timings.push(timingsSent[i])\n    }\n    timingsSent = []\n  }\n}\n\nfunction finalHarvest() {\n  recordLcp()\n  recordUnload()\n  var payload = prepareHarvest({ retry: false })\n  harvest.send('events', loader, payload, { unload: true })\n}\n\nfunction appendGlobalCustomAttributes(timing) {\n  var timingAttributes = timing.attrs || {}\n  var customAttributes = loader.info.jsAttributes || {}\n\n  mapOwn(customAttributes, function (key, val) {\n    if (key !== 'size' && key !== 'eid' && key !== 'cls' && key !== 'type' && key !== 'fid') {\n      timingAttributes[key] = val\n    }\n  })\n}\n\n// serialize and return current timing data, clear and save current data for retry\nfunction prepareHarvest(options) {\n  if (timings.length === 0) return\n\n  var payload = getPayload(timings)\n  if (options.retry) {\n    for (var i = 0; i < timings.length; i++) {\n      timingsSent.push(timings[i])\n    }\n  }\n  timings = []\n  return { body: { e: payload } }\n}\n\n// serialize array of timing data\nfunction getPayload(data) {\n  var addString = getAddStringContext()\n\n  var payload = 'bel.6;'\n\n  for (var i = 0; i < data.length; i++) {\n    var timing = data[i]\n\n    payload += 'e,'\n    payload += addString(timing.name) + ','\n    payload += nullable(timing.value, numeric, false) + ','\n\n    appendGlobalCustomAttributes(timing)\n\n    var attrParts = addCustomAttributes(timing.attrs, addString)\n    if (attrParts && attrParts.length > 0) {\n      payload += numeric(attrParts.length) + ';' + attrParts.join(';')\n    }\n\n    if ((i + 1) < data.length) payload += ';'\n  }\n\n  return payload\n}\n\nfunction isEnabled(config) {\n  // collect page view timings unless the feature is explicitly disabled\n  if (config && config.enabled === false) {\n    return false\n  }\n  return true\n}\n\n},{}],25:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = require(36)\nvar single = require(19)\nvar addE = require(1)\n\nmodule.exports = subscribeToUnload\n\n// Used to subscribe a callback to when a page is being unloaded. This is used,\n// for example, to submit a final harvest.\nfunction subscribeToUnload (cb) {\n  var oneCall = single(cb)\n\n  // Firefox has a bug wherein a slow-loading resource loaded from the 'pagehide'\n  // or 'unload' event will delay the 'load' event firing on the next page load.\n  // In Firefox versions that support sendBeacon, this doesn't matter, because\n  // we'll use it instead of an image load for our final harvest.\n  //\n  // Some Safari versions never fire the 'unload' event for pages that are being\n  // put into the WebKit page cache, so we *need* to use the pagehide event for\n  // the final submission from Safari.\n  //\n  // Generally speaking, we will try to submit our final harvest from either\n  // pagehide or unload, whichever comes first, but in Firefox, we need to avoid\n  // attempting to submit from pagehide to ensure that we don't slow down loading\n  // of the next page.\n  if (!ffVersion || navigator.sendBeacon) {\n    addE('pagehide', oneCall)\n  } else {\n    addE('beforeunload', oneCall)\n  }\n  addE('unload', oneCall)\n}\n\n},{}],26:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar canonicalFunctionNameRe = /([a-z0-9]+)$/i\nfunction canonicalFunctionName (orig) {\n  if (!orig) return\n\n  var match = orig.match(canonicalFunctionNameRe)\n  if (match) return match[1]\n\n  return\n}\n\nmodule.exports = canonicalFunctionName\n\n},{}],27:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// computeStackTrace: cross-browser stack traces in JavaScript\n//\n// Syntax:\n//   s = computeStackTrace(exception) // consider using TraceKit.report instead\n// Returns:\n//   s.name              - exception name\n//   s.message           - exception message\n//   s.stack[i].url      - JavaScript or HTML file URL\n//   s.stack[i].func     - function name, or empty for anonymous functions\n//   s.stack[i].line     - line number, if known\n//   s.stack[i].column   - column number, if known\n//   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n//   s.mode              - 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace\n//\n// Supports:\n//   - Firefox:  full stack trace with line numbers and unreliable column\n//               number on top frame\n//   - Opera 10: full stack trace with line and column numbers\n//   - Opera 9-: full stack trace with line numbers\n//   - Chrome:   full stack trace with line and column numbers\n//   - Safari:   line and column number for the topmost stacktrace element\n//               only\n//   - IE:       no line numbers whatsoever\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n//\n// OPERA:\n// ex.message = ...message... (see the example below)\n// ex.name = ReferenceError\n// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\nvar reduce = require(41)\nvar formatStackTrace = require(28)\n\nvar has = Object.prototype.hasOwnProperty\nvar debug = false\n\nvar classNameRegex = /function (.+?)\\s*\\(/\nvar chrome = /^\\s*at (?:((?:\\[object object\\])?(?:[^(]*\\([^)]*\\))*[^()]*(?: \\[as \\S+\\])?) )?\\(?((?:file|http|https|chrome-extension):.*?)?:(\\d+)(?::(\\d+))?\\)?\\s*$/i\nvar gecko = /^\\s*(?:(\\S*|global code)(?:\\(.*?\\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\\d+)(?::(\\d+))?\\s*$/i\nvar chrome_eval = /^\\s*at .+ \\(eval at \\S+ \\((?:(?:file|http|https):[^)]+)?\\)(?:, [^:]*:\\d+:\\d+)?\\)$/i\nvar ie_eval = /^\\s*at Function code \\(Function code:\\d+:\\d+\\)\\s*/i\n\nmodule.exports = computeStackTrace\n\nfunction computeStackTrace (ex) {\n  var stack = null\n\n  try {\n    // This must be tried first because Opera 10 *destroys*\n    // its stacktrace property if you try to access the stack\n    // property first!!\n    stack = computeStackTraceFromStacktraceProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromStackProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromOperaMultiLineMessage(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceBySourceAndLine(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceWithMessageOnly(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  return {\n    'mode': 'failed',\n    'stackString': '',\n    'frames': []\n  }\n}\n\n/**\n * Computes stack trace information from the stack property.\n * Chrome and Gecko use this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStackProp (ex) {\n  if (!ex.stack) {\n    return null\n  }\n\n  var errorInfo = reduce(\n    ex.stack.split('\\n'),\n    parseStackProp,\n    {frames: [], stackLines: [], wrapperSeen: false}\n  )\n\n  if (!errorInfo.frames.length) return null\n\n  return {\n    'mode': 'stack',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(errorInfo.stackLines),\n    'frames': errorInfo.frames\n  }\n}\n\nfunction parseStackProp (info, line) {\n  var element = getElement(line)\n\n  if (!element) {\n    info.stackLines.push(line)\n    return info\n  }\n\n  if (isWrapper(element.func)) info.wrapperSeen = true\n  else info.stackLines.push(line)\n\n  if (!info.wrapperSeen) info.frames.push(element)\n  return info\n}\n\nfunction getElement (line) {\n  var parts = line.match(gecko)\n  if (!parts) parts = line.match(chrome)\n\n  if (parts) {\n    return ({\n      'url': parts[2],\n      'func': (parts[1] !== 'Anonymous function' && parts[1] !== 'global code' && parts[1]) || null,\n      'line': +parts[3],\n      'column': parts[4] ? +parts[4] : null\n    })\n  }\n\n  if (line.match(chrome_eval) || line.match(ie_eval) || line === 'anonymous') {\n    return { 'func': 'evaluated code' }\n  }\n}\n\nfunction computeStackTraceBySourceAndLine (ex) {\n  if (!('line' in ex)) return null\n\n  var className = ex.name || getClassName(ex)\n\n  // Safari does not provide a URL for errors in eval'd code\n  if (!ex.sourceURL) {\n    return ({\n      'mode': 'sourceline',\n      'name': className,\n      'message': ex.message,\n      'stackString': getClassName(ex) + ': ' + ex.message + '\\n    in evaluated code',\n      'frames': [{\n        'func': 'evaluated code'\n      }]\n    })\n  }\n\n  var stackString = className + ': ' + ex.message + '\\n    at ' + ex.sourceURL\n  if (ex.line) {\n    stackString += ':' + ex.line\n    if (ex.column) {\n      stackString += ':' + ex.column\n    }\n  }\n\n  return ({\n    'mode': 'sourceline',\n    'name': className,\n    'message': ex.message,\n    'stackString': stackString,\n    'frames': [{ 'url': ex.sourceURL,\n      'line': ex.line,\n      'column': ex.column\n    }]\n  })\n}\n\nfunction computeStackTraceWithMessageOnly (ex) {\n  var className = ex.name || getClassName(ex)\n  if (!className) return null\n\n  return ({\n    'mode': 'nameonly',\n    'name': className,\n    'message': ex.message,\n    'stackString': className + ': ' + ex.message,\n    'frames': []\n  })\n}\n\nfunction getClassName (obj) {\n  var results = classNameRegex.exec(String(obj.constructor))\n  return (results && results.length > 1) ? results[1] : 'unknown'\n}\n\nfunction isWrapper (functionName) {\n  return (functionName && functionName.indexOf('nrWrapper') >= 0)\n}\n\n/**\n * Computes stack trace information from the stacktrace property.\n * Opera 10 uses this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStacktraceProp (ex) {\n  if (!ex.stacktrace) {\n    return null\n  }\n\n  // Access and store the stacktrace property before doing anything\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = ex.stacktrace\n\n  var testRE = / line (\\d+), column (\\d+) in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\(.*\\) in (.*):\\s*$/i\n  var lines = stacktrace.split('\\n')\n  var frames = []\n  var stackLines = []\n  var parts\n  var wrapperSeen = false\n\n  for (var i = 0, j = lines.length; i < j; i += 2) {\n    if ((parts = testRE.exec(lines[i]))) {\n      var element = {\n        'line': +parts[1],\n        'column': +parts[2],\n        'func': parts[3] || parts[4],\n        'url': parts[5]\n      }\n\n      if (isWrapper(element.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(element)\n    } else {\n      stackLines.push(lines[i])\n    }\n  }\n\n  if (!frames.length) {\n    return null\n  }\n\n  return {\n    'mode': 'stacktrace',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n/**\n * Computes stack trace information from an error message that includes\n * the stack trace.\n * Opera 9 and earlier use this method if the option to show stack\n * traces is turned on in opera:config.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack information.\n */\nfunction computeStackTraceFromOperaMultiLineMessage (ex) {\n  // Opera includes a stack trace into the exception message. An example is:\n  //\n  // Statement on line 3: Undefined variable: undefinedFunc\n  // Backtrace:\n  //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz\n  //         undefinedFunc(a)\n  //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy\n  //           zzz(x, y, z)\n  //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx\n  //           yyy(a, a, a)\n  //   Line 1 of function script\n  //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }\n  //   ...\n\n  var lines = ex.message.split('\\n')\n  if (lines.length < 4) {\n    return null\n  }\n\n  var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i\n  var frames = []\n  var stackLines = []\n  var scripts = document.getElementsByTagName('script')\n  var inlineScriptBlocks = []\n  var parts\n  var i\n  var len\n  var wrapperSeen = false\n\n  for (i in scripts) {\n    if (has.call(scripts, i) && !scripts[i].src) {\n      inlineScriptBlocks.push(scripts[i])\n    }\n  }\n\n  for (i = 2, len = lines.length; i < len; i += 2) {\n    var item = null\n    if ((parts = lineRE1.exec(lines[i]))) {\n      item = {\n        'url': parts[2],\n        'func': parts[3],\n        'line': +parts[1]\n      }\n    } else if ((parts = lineRE2.exec(lines[i]))) {\n      item = {\n        'url': parts[3],\n        'func': parts[4]\n      }\n    } else if ((parts = lineRE3.exec(lines[i]))) {\n      var url = window.location.href.replace(/#.*$/, '')\n      var line = parts[1]\n\n      item = {\n        'url': url,\n        'line': line,\n        'func': ''\n      }\n    }\n\n    if (item) {\n      if (isWrapper(item.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(item)\n    }\n  }\n  if (!frames.length) {\n    return null // could not parse multiline exception message as Opera stack trace\n  }\n\n  return {\n    'mode': 'multiline',\n    'name': ex.name || getClassName(ex),\n    'message': lines[0],\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n\n},{}],28:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stripNewlinesRegex = /^\\n+|\\n+$/g\nvar MAX_STACK_TRACE_LENGTH = 65530\n\nmodule.exports = function (stackLines) {\n  return truncateStackLines(stackLines).replace(stripNewlinesRegex, '')\n}\n\nmodule.exports.truncateSize = truncateSize\n\n// takes array of stack lines and returns string with top 50 and buttom 50 lines\nfunction truncateStackLines(stackLines) {\n  var stackString\n  if (stackLines.length > 100) {\n    var truncatedLines = stackLines.length - 100\n    stackString = stackLines.slice(0, 50).join('\\n')\n    stackString += '\\n< ...truncated ' + truncatedLines + ' lines... >\\n'\n    stackString += stackLines.slice(-50).join('\\n')\n  } else {\n    stackString = stackLines.join('\\n')\n  }\n  return stackString\n}\n\n// truncates stack string to limit what is sent to backend\nfunction truncateSize(stackString) {\n  return (stackString.length > MAX_STACK_TRACE_LENGTH) ? stackString.substr(0, MAX_STACK_TRACE_LENGTH) : stackString\n}\n\n},{}],29:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar canonicalFunctionName = require(26)\nvar cleanURL = require(5)\nvar computeStackTrace = require(27)\nvar stringHashCode = require(30)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar stackReported = {}\nvar pageviewReported = {}\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar stringify = require(22)\nvar handle = require(\"handle\")\nvar baseEE = require(\"ee\")\nvar mapOwn = require(38)\nvar config = require(35)\nvar truncateSize = require(28).truncateSize\nvar errorCache = {}\nvar currentBody\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.err) return\nvar errorOnPage = false\n\nvar harvestTimeSeconds = config.getConfiguration('jserrors.harvestTimeSeconds') || 60\n\nee.on('feat-err', function () {\n  register('err', storeError)\n  register('ierr', storeError)\n\n  harvest.on('jserrors', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'jserrors', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds)\n})\n\nfunction onHarvestStarted(options) {\n  var body = agg.take([ 'err', 'ierr' ])\n\n  if (options.retry) {\n    currentBody = body\n  }\n\n  var payload = { body: body, qs: {} }\n  var releaseIds = stringify(loader.releaseIds)\n\n  if (releaseIds !== '{}') {\n    payload.qs.ri = releaseIds\n  }\n\n  if (body && body.err && body.err.length && !errorOnPage) {\n    payload.qs.pve = '1'\n    errorOnPage = true\n  }\n  return payload\n}\n\nfunction onHarvestFinished(result) {\n  if (!result.sent) {\n    // keep connection open\n    harvest.pingErrors(loader)\n  }\n\n  if (result.retry && currentBody) {\n    mapOwn(currentBody, function(key, value) {\n      for (var i = 0; i < value.length; i++) {\n        var bucket = value[i]\n        var name = getBucketName(bucket.params, bucket.custom)\n        agg.merge(key, name, bucket.metrics, bucket.params, bucket.custom)\n      }\n    })\n    currentBody = null\n  }\n}\n\n// open HTTPS connection, which is needed for sending data during page unload on older browsers\nharvest.pingErrors(loader)\n\nfunction nameHash (params) {\n  return stringHashCode(params.exceptionClass) ^ params.stackHash\n}\n\nfunction getBucketName(params, customParams) {\n  return nameHash(params) + ':' + stringHashCode(stringify(customParams))\n}\n\nfunction canonicalizeURL (url, cleanedOrigin) {\n  if (typeof url !== 'string') return ''\n\n  var cleanedURL = cleanURL(url)\n  if (cleanedURL === cleanedOrigin) {\n    return '<inline>'\n  } else {\n    return cleanedURL\n  }\n}\n\nfunction buildCanonicalStackString (stackInfo, cleanedOrigin) {\n  var canonicalStack = ''\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var func = canonicalFunctionName(frame.func)\n\n    if (canonicalStack) canonicalStack += '\\n'\n    if (func) canonicalStack += func + '@'\n    if (typeof frame.url === 'string') canonicalStack += frame.url\n    if (frame.line) canonicalStack += ':' + frame.line\n  }\n\n  return canonicalStack\n}\n\n// Strip query parameters and fragments from the stackString property of the\n// given stackInfo, along with the 'url' properties of each frame in\n// stackInfo.frames.\n//\n// Any URLs that are equivalent to the cleaned version of the origin will also\n// be replaced with the string '<inline>'.\n//\nfunction canonicalizeStackURLs (stackInfo) {\n  // Currently, loader.origin might contain a fragment, but we don't want to use it\n  // for comparing with frame URLs.\n  var cleanedOrigin = cleanURL(loader.origin)\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var originalURL = frame.url\n    var cleanedURL = canonicalizeURL(originalURL, cleanedOrigin)\n    if (cleanedURL && cleanedURL !== frame.url) {\n      frame.url = cleanedURL\n      stackInfo.stackString = stackInfo.stackString.split(originalURL).join(cleanedURL)\n    }\n  }\n\n  return stackInfo\n}\n\nfunction storeError (err, time, internal, customAttributes) {\n  // are we in an interaction\n  time = time || loader.now()\n  if (!internal && loader.onerror && loader.onerror(err)) return\n\n  var stackInfo = canonicalizeStackURLs(computeStackTrace(err))\n  var canonicalStack = buildCanonicalStackString(stackInfo)\n\n  var params = {\n    stackHash: stringHashCode(canonicalStack),\n    exceptionClass: stackInfo.name,\n    request_uri: window.location.pathname\n  }\n  if (stackInfo.message) {\n    params.message = '' + stackInfo.message\n  }\n\n  if (!stackReported[params.stackHash]) {\n    stackReported[params.stackHash] = true\n    params.stack_trace = truncateSize(stackInfo.stackString)\n  } else {\n    params.browser_stack_hash = stringHashCode(stackInfo.stackString)\n  }\n  params.releaseIds = stringify(loader.releaseIds)\n\n  // When debugging stack canonicalization/hashing, uncomment these lines for\n  // more output in the test logs\n  // params.origStack = err.stack\n  // params.canonicalStack = canonicalStack\n\n  var hash = nameHash(params)\n\n  if (!pageviewReported[hash]) {\n    params.pageview = 1\n    pageviewReported[hash] = true\n  }\n\n  var type = internal ? 'ierr' : 'err'\n  var newMetrics = { time: time }\n\n  // stn and spa aggregators listen to this event - stn sends the error in its payload,\n  // and spa annotates the error with interaction info\n  handle('errorAgg', [type, hash, params, newMetrics])\n\n  if (params._interactionId != null) {\n    // hold on to the error until the interaction finishes\n    errorCache[params._interactionId] = errorCache[params._interactionId] || []\n    errorCache[params._interactionId].push([type, hash, params, newMetrics, att, customAttributes])\n  } else {\n    // store custom attributes\n    var customParams = {}\n    var att = loader.info.jsAttributes\n    mapOwn(att, setCustom)\n    if (customAttributes) {\n      mapOwn(customAttributes, setCustom)\n    }\n\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n    agg.store(type, aggregateHash, params, newMetrics, customParams)\n  }\n\n  function setCustom (key, val) {\n    customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nbaseEE.on('interactionSaved', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    params.browserInteractionId = interaction.root.attrs.id\n    delete params._interactionId\n\n    if (params._interactionNodeId) {\n      params.parentNodeId = params._interactionNodeId.toString()\n      delete params._interactionNodeId\n    }\n\n    var hash = item[1] + interaction.root.attrs.id\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, params, item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n\nbaseEE.on('interactionDiscarded', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    delete params._interactionId\n    delete params._interactionNodeId\n\n    var hash = item[1]\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, item[2], item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n\n},{}],30:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nfunction stringHashCode (string) {\n  var hash = 0\n  var charVal\n\n  if (!string || !string.length) return hash\n  for (var i = 0; i < string.length; i++) {\n    charVal = string.charCodeAt(i)\n    hash = ((hash << 5) - hash) + charVal\n    hash = hash | 0 // Convert to 32bit integer\n  }\n  return hash\n}\n\nmodule.exports = stringHashCode\n\n},{}],31:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar loader = require(\"loader\")\nvar mapOwn = require(38)\nvar stringify = require(22)\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar cleanURL = require(5)\nvar config = require(35)\n\nvar eventsPerMinute = 120\nvar harvestTimeSeconds = config.getConfiguration('ins.harvestTimeSeconds') || 30\nvar eventsPerHarvest = eventsPerMinute * harvestTimeSeconds / 60\nvar referrerUrl\nvar currentEvents\n\nvar events = []\nvar att = loader.info.jsAttributes = {}\n\nif (document.referrer) referrerUrl = cleanURL(document.referrer)\n\nregister('api-setCustomAttribute', setCustomAttribute, 'api')\n\nee.on('feat-ins', function () {\n  register('api-addPageAction', addPageAction)\n\n  harvest.on('ins', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'ins', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds, 0)\n})\n\nfunction onHarvestStarted (options) {\n  var payload = ({\n    qs: {\n      ua: loader.info.userAttributes,\n      at: loader.info.atts\n    },\n    body: {\n      ins: events\n    }\n  })\n\n  if (options.retry) {\n    currentEvents = events\n  }\n\n  events = []\n  return payload\n}\n\nfunction onHarvestFinished (result) {\n  if (result && result.sent && result.retry && currentEvents) {\n    events = events.concat(currentEvents)\n    currentEvents = null\n  }\n}\n\n// WARNING: Insights times are in seconds. EXCEPT timestamp, which is in ms.\nfunction addPageAction (t, name, attributes) {\n  if (events.length >= eventsPerHarvest) return\n  var width\n  var height\n  var eventAttributes = {}\n\n  if (typeof window !== 'undefined' && window.document && window.document.documentElement) {\n    // Doesn't include the nav bar when it disappears in mobile safari\n    // https://github.com/jquery/jquery/blob/10399ddcf8a239acc27bdec9231b996b178224d3/src/dimensions.js#L23\n    width = window.document.documentElement.clientWidth\n    height = window.document.documentElement.clientHeight\n  }\n\n  var defaults = {\n    timestamp: t + loader.offset,\n    timeSinceLoad: t / 1000,\n    browserWidth: width,\n    browserHeight: height,\n    referrerUrl: referrerUrl,\n    currentUrl: cleanURL('' + location),\n    pageUrl: cleanURL(loader.origin),\n    eventType: 'PageAction'\n  }\n\n  mapOwn(defaults, set)\n  mapOwn(att, set)\n  if (attributes && typeof attributes === 'object') {\n    mapOwn(attributes, set)\n  }\n  eventAttributes.actionName = name || ''\n\n  events.push(eventAttributes)\n\n  function set (key, val) {\n    eventAttributes[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nfunction setCustomAttribute (t, key, value) {\n  att[key] = value\n}\n\n},{}],32:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar loader = require(\"loader\")\nvar registerHandler = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar mapOwn = require(38)\nvar reduce = require(41)\nvar stringify = require(22)\nvar slice = require(39)\nvar parseUrl = require(34)\nvar config = require(35)\n\nif (!harvest.xhrUsable || !loader.xhrWrappable) return\n\nvar ptid = ''\nvar ignoredEvents = {mouseup: true, mousedown: true}\nvar toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n}\n\nvar rename = {\n  typing: {\n    keydown: true,\n    keyup: true,\n    keypress: true\n  },\n  mousing: {\n    mousemove: true,\n    mouseenter: true,\n    mouseleave: true,\n    mouseover: true,\n    mouseout: true\n  },\n  scrolling: {\n    scroll: true\n  },\n  touching: {\n    touchstart: true,\n    touchmove: true,\n    touchend: true,\n    touchcancel: true,\n    touchenter: true,\n    touchleave: true\n  }\n}\n\nvar trace = {}\nvar nodeCount = 0\nvar sentTrace = null\nvar harvestTimeSeconds = config.getConfiguration('stn.harvestTimeSeconds') || 10\nvar maxNodesPerHarvest = config.getConfiguration('stn.maxNodesPerHarvest') || 1000\n\nvar ee = require(\"ee\")\n\n// exports only used for testing\nmodule.exports = {\n  _takeSTNs: takeSTNs\n}\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.stn) return\n\nee.on('feat-stn', function () {\n  storeTiming(window.performance.timing)\n\n  harvest.on('resources', prepareHarvest)\n\n  var scheduler = new HarvestScheduler(loader, 'resources', { onFinished: onHarvestFinished, retryDelay: harvestTimeSeconds })\n  scheduler.runHarvest({ needResponse: true })\n\n  function onHarvestFinished(result) {\n    // start timer only if ptid was returned by server\n    if (result.sent && result.responseText && !ptid) {\n      ptid = result.responseText\n      scheduler.startTimer(harvestTimeSeconds)\n    }\n\n    if (result.sent && result.retry && sentTrace) {\n      mapOwn(sentTrace, function (name, nodes) {\n        mergeSTNs(name, nodes)\n      })\n      sentTrace = null\n    }\n  }\n\n  function prepareHarvest(options) {\n    if ((loader.now()) > (15 * 60 * 1000)) {\n      // been collecting for over 15 min, empty trace object and bail\n      scheduler.stopTimer()\n      trace = {}\n      return\n    }\n\n    // only send when there are more than 30 nodes to send\n    if (ptid && nodeCount <= 30) return\n\n    return takeSTNs(options.retry)\n  }\n\n  registerHandler('bst', storeEvent)\n  registerHandler('bstTimer', storeTimer)\n  registerHandler('bstResource', storeResources)\n  registerHandler('bstHist', storeHist)\n  registerHandler('bstXhrAgg', storeXhrAgg)\n  registerHandler('bstApi', storeSTN)\n  registerHandler('errorAgg', storeErrorAgg)\n})\n\nfunction storeTiming (_t) {\n  var key\n  var val\n  var timeOffset\n  var now = Date.now()\n\n  // loop iterates through prototype also (for FF)\n  for (key in _t) {\n    val = _t[key]\n\n    // ignore inherited methods, meaningless 0 values, and bogus timestamps\n    // that are in the future (Microsoft Edge seems to sometimes produce these)\n    if (!(typeof (val) === 'number' && val > 0 && val < now)) continue\n\n    timeOffset = _t[key] - loader.offset\n\n    storeSTN({\n      n: key,\n      s: timeOffset,\n      e: timeOffset,\n      o: 'document',\n      t: 'timing'\n    })\n  }\n}\n\nfunction storeTimer (target, start, end, type) {\n  var category = 'timer'\n  if (type === 'requestAnimationFrame') category = type\n\n  var evt = {\n    n: type,\n    s: start,\n    e: end,\n    o: 'window',\n    t: category\n  }\n\n  storeSTN(evt)\n}\n\nfunction storeEvent (currentEvent, target, start, end) {\n  // we find that certain events make the data too noisy to be useful\n  if (currentEvent.type in ignoredEvents) { return false }\n\n  var evt = {\n    n: evtName(currentEvent.type),\n    s: start,\n    e: end,\n    t: 'event'\n  }\n\n  try {\n    // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n    // it does not check currentEvent.currentTarget before calling getRootNode() on it\n    evt.o = evtOrigin(currentEvent.target, target)\n  } catch (e) {\n    evt.o = evtOrigin(null, target)\n  }\n\n  storeSTN(evt)\n}\n\nfunction evtName (type) {\n  var name = type\n\n  mapOwn(rename, function (key, val) {\n    if (type in val) name = key\n  })\n\n  return name\n}\n\nfunction evtOrigin (t, target) {\n  var origin = 'unknown'\n\n  if (t && t instanceof XMLHttpRequest) {\n    var params = ee.context(t).params\n    origin = params.status + ' ' + params.method + ': ' + params.host + params.pathname\n  } else if (t && typeof (t.tagName) === 'string') {\n    origin = t.tagName.toLowerCase()\n    if (t.id) origin += '#' + t.id\n    if (t.className) origin += '.' + slice(t.classList).join('.')\n  }\n\n  if (origin === 'unknown') {\n    if (target === document) origin = 'document'\n    else if (target === window) origin = 'window'\n    else if (target instanceof FileReader) origin = 'FileReader'\n  }\n\n  return origin\n}\n\nfunction storeHist (path, old, time) {\n  var node = {\n    n: 'history.pushState',\n    s: time,\n    e: time,\n    o: path,\n    t: old\n  }\n\n  storeSTN(node)\n}\n\nvar laststart = 0\n\nfunction storeResources (resources) {\n  resources.forEach(function (currentResource) {\n    var parsed = parseUrl(currentResource.name)\n    var res = {\n      n: currentResource.initiatorType,\n      s: currentResource.fetchStart | 0,\n      e: currentResource.responseEnd | 0,\n      o: parsed.protocol + '://' + parsed.hostname + ':' + parsed.port + parsed.pathname, // resource.name is actually a URL so it's the source\n      t: currentResource.entryType\n    }\n\n    // don't recollect old resources\n    if (res.s < laststart) return\n\n    laststart = res.s\n\n    storeSTN(res)\n  })\n}\n\nfunction storeErrorAgg (type, name, params, metrics) {\n  if (type !== 'err') return\n  var node = {\n    n: 'error',\n    s: metrics.time,\n    e: metrics.time,\n    o: params.message,\n    t: params.stackHash\n  }\n  storeSTN(node)\n}\n\nfunction storeXhrAgg (type, name, params, metrics) {\n  if (type !== 'xhr') return\n  var node = {\n    n: 'Ajax',\n    s: metrics.time,\n    e: metrics.time + metrics.duration,\n    o: params.status + ' ' + params.method + ': ' + params.host + params.pathname,\n    t: 'ajax'\n  }\n  storeSTN(node)\n}\n\nfunction storeSTN (stn) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[stn.n]\n  if (!traceArr) traceArr = trace[stn.n] = []\n\n  traceArr.push(stn)\n  nodeCount++\n}\n\nfunction mergeSTNs(key, nodes) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[key]\n  if (!traceArr) traceArr = trace[key] = []\n\n  trace[key] = nodes.concat(traceArr)\n  nodeCount += nodes.length\n}\n\nfunction takeSTNs (retry) {\n  storeResources(window.performance.getEntriesByType('resource'))\n  var stns = reduce(mapOwn(trace, function (name, nodes) {\n    if (!(name in toAggregate)) return nodes\n\n    return reduce(mapOwn(reduce(nodes.sort(byStart), smearEvtsByOrigin(name), {}), val), flatten, [])\n  }), flatten, [])\n\n  if (stns.length === 0) return {}\n\n  if (retry) {\n    sentTrace = trace\n  }\n  trace = {}\n  nodeCount = 0\n\n  var stnInfo = {\n    qs: {st: '' + loader.offset, ptid: ptid},\n    body: {res: stns}\n  }\n\n  if (!ptid) {\n    stnInfo.qs.ua = loader.info.userAttributes\n    stnInfo.qs.at = loader.info.atts\n    var ja = stringify(loader.info.jsAttributes)\n    stnInfo.qs.ja = ja === '{}' ? null : ja\n  }\n  return stnInfo\n}\n\nfunction byStart (a, b) {\n  return a.s - b.s\n}\n\nfunction smearEvtsByOrigin (name) {\n  var maxGap = toAggregate[name][0]\n  var maxLen = toAggregate[name][1]\n  var lastO = {}\n\n  return function (byOrigin, evt) {\n    var lastArr = byOrigin[evt.o]\n\n    lastArr || (lastArr = byOrigin[evt.o] = [])\n\n    var last = lastO[evt.o]\n\n    if (name === 'scrolling' && !trivial(evt)) {\n      lastO[evt.o] = null\n      evt.n = 'scroll'\n      lastArr.push(evt)\n    } else if (last && (evt.s - last.s) < maxLen && last.e > (evt.s - maxGap)) {\n      last.e = evt.e\n    } else {\n      lastO[evt.o] = evt\n      lastArr.push(evt)\n    }\n\n    return byOrigin\n  }\n}\n\nfunction val (key, value) {\n  return value\n}\n\nfunction flatten (a, b) {\n  return a.concat(b)\n}\n\nfunction trivial (node) {\n  var limit = 4\n  if (node && typeof node.e === 'number' && typeof node.s === 'number' && (node.e - node.s) < limit) return true\n  else return false\n}\n\n},{}],33:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar register = require(17)\nvar harvest = require(10)\nvar stringify = require(22)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar handle = require(\"handle\")\n\n// bail if not instrumented\nif (!loader.features.xhr) return\n\nharvest.on('jserrors', function () {\n  return { body: agg.take([ 'xhr' ]) }\n})\n\nee.on('feat-err', function () { register('xhr', storeXhr) })\n\nmodule.exports = storeXhr\n\nfunction storeXhr (params, metrics, start) {\n  metrics.time = start\n\n  var type = 'xhr'\n  var hash\n  if (params.cat) {\n    hash = stringify([params.status, params.cat])\n  } else {\n    hash = stringify([params.status, params.host, params.pathname])\n  }\n\n  handle('bstXhrAgg', [type, hash, params, metrics])\n  agg.store(type, hash, params, metrics)\n}\n\n},{}],34:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stringsToParsedUrls = {}\n\nmodule.exports = function parseUrl (url) {\n  if (url in stringsToParsedUrls) {\n    return stringsToParsedUrls[url]\n  }\n\n  var urlEl = document.createElement('a')\n  var location = window.location\n  var ret = {}\n\n  // Use an anchor dom element to resolve the url natively.\n  urlEl.href = url\n\n  ret.port = urlEl.port\n\n  var firstSplit = urlEl.href.split('://')\n\n  if (!ret.port && firstSplit[1]) {\n    ret.port = firstSplit[1].split('/')[0].split('@').pop().split(':')[1]\n  }\n  if (!ret.port || ret.port === '0') ret.port = (firstSplit[0] === 'https' ? '443' : '80')\n\n  // Host not provided in IE for relative urls\n  ret.hostname = (urlEl.hostname || location.hostname)\n\n  ret.pathname = urlEl.pathname\n\n  ret.protocol = firstSplit[0]\n\n  // Pathname sometimes doesn't have leading slash (IE 8 and 9)\n  if (ret.pathname.charAt(0) !== '/') ret.pathname = '/' + ret.pathname\n\n  // urlEl.protocol is ':' in old ie when protocol is not specified\n  var sameProtocol = !urlEl.protocol || urlEl.protocol === ':' || urlEl.protocol === location.protocol\n  var sameDomain = urlEl.hostname === document.domain && urlEl.port === location.port\n\n  // urlEl.hostname is not provided by IE for relative urls, but relative urls are also same-origin\n  ret.sameOrigin = sameProtocol && (!urlEl.hostname || sameDomain)\n\n  // Only cache if url doesn't have a path\n  if (ret.pathname === '/') {\n    stringsToParsedUrls[url] = ret\n  }\n\n  return ret\n}\n\n},{}],35:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getConfiguration: getConfiguration\n}\n\nfunction getConfiguration(path) {\n  if (!NREUM.init) return\n  var val = NREUM.init\n  var parts = path.split('.')\n  for (var i = 0; i < parts.length - 1; i++) {\n    val = val[parts[i]]\n    if (typeof val !== 'object') return\n  }\n  val = val[parts[parts.length - 1]]\n  return val\n}\n\n},{}],36:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = 0\nvar match = navigator.userAgent.match(/Firefox[\\/\\s](\\d+\\.\\d+)/)\nif (match) ffVersion = +match[1]\n\nmodule.exports = ffVersion\n\n},{}],37:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar lastTimestamp = new Date().getTime()\nvar offset = lastTimestamp\n\nvar performanceCheck = require(40)\n\nmodule.exports = now\nmodule.exports.offset = offset\nmodule.exports.getLastTimestamp = getLastTimestamp\n\nfunction now () {\n  if (performanceCheck.exists && performance.now) {\n    return Math.round(performance.now())\n  }\n  // ensure a new timestamp is never smaller than a previous timestamp\n  return (lastTimestamp = Math.max(new Date().getTime(), lastTimestamp)) - offset\n}\n\nfunction getLastTimestamp() {\n  return lastTimestamp\n}\n\n},{}],38:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = mapOwn\n\nfunction mapOwn (obj, fn) {\n  var results = []\n  var key = ''\n  var i = 0\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      results[i] = fn(key, obj[key])\n      i += 1\n    }\n  }\n\n  return results\n}\n\n},{}],39:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n\n},{}],40:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  exists: typeof (window.performance) !== 'undefined' && window.performance.timing && typeof (window.performance.timing.navigationStart) !== 'undefined'\n}\n\n},{}],41:[function(require,module,exports){\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = reduce\n\nfunction reduce (arr, fn, next) {\n  var i = 0\n  if (typeof next === 'undefined') {\n    next = arr[0]\n    i = 1\n  }\n\n  for (i; i < arr.length; i++) {\n    next = fn(next, arr[i])\n  }\n\n  return next\n}\n\n},{}]},{},[29,33,32,31,12])\n\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\n\nvar aggregatedData = {}\n\nmodule.exports = {\n  store: store,\n  take: take,\n  get: get,\n  merge: mergeMetrics\n}\n\n// Items with the same type and name get aggregated together\n// params are example data from the aggregated items\n// metrics are the numeric values to be aggregated\nfunction store (type, name, params, newMetrics, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  bucket.metrics = aggregateMetrics(newMetrics, bucket.metrics)\n  return bucket\n}\n\nfunction aggregateMetrics (newMetrics, oldMetrics) {\n  if (!oldMetrics) oldMetrics = {count: 0}\n  oldMetrics.count += 1\n  mapOwn(newMetrics, function (key, value) {\n    oldMetrics[key] = updateMetric(value, oldMetrics[key])\n  })\n  return oldMetrics\n}\n\nfunction updateMetric (value, metric) {\n  // When there is only one data point, the c (count), min, max, and sos (sum of squares) params are superfluous.\n  if (!metric) return {t: value}\n\n  // but on the second data point, we need to calculate the other values before aggregating in new values\n  if (!metric.c) {\n    metric = createMetricObject(metric.t)\n  }\n\n  // at this point, metric is always uncondensed\n  metric.c += 1\n  metric.t += value\n  metric.sos += value * value\n  if (value > metric.max) metric.max = value\n  if (value < metric.min) metric.min = value\n\n  return metric\n}\n\n/**\n * Merge metrics object into existing metrics.\n *\n * @param {string} type\n * @param {string} name\n * @param {object} metrics - Metrics to merge.\n */\nfunction mergeMetrics (type, name, metrics, params, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  if (!bucket.metrics) {\n    bucket.metrics = metrics\n    return\n  }\n\n  var oldMetrics = bucket.metrics\n  oldMetrics.count += metrics.count\n\n  // iterate through each new metric and merge\n  mapOwn(metrics, function (key, value) {\n    // count is a special case handled above\n    if (key === 'count') return\n\n    var oldMetric = oldMetrics[key]\n    var newMetric = metrics[key]\n\n    // handling the case where newMetric is a single-value first\n    if (newMetric && !newMetric.c) {\n      oldMetrics[key] = updateMetric(newMetric.t, oldMetric)\n    } else { // newMetric is a metric object\n      oldMetrics[key] = mergeMetric(newMetric, oldMetrics[key])\n    }\n  })\n}\n\nfunction mergeMetric(newMetric, oldMetric) {\n  if (!oldMetric) return newMetric\n\n  if (!oldMetric.c) {\n    // oldMetric is a single-value\n    oldMetric = createMetricObject(oldMetric.t)\n  }\n\n  oldMetric.min = Math.min(newMetric.min, oldMetric.min)\n  oldMetric.max = Math.max(newMetric.max, oldMetric.max)\n  oldMetric.t += newMetric.t\n  oldMetric.sos += newMetric.sos\n  oldMetric.c += newMetric.c\n\n  return oldMetric\n}\n\n// take a value and create a metric object\nfunction createMetricObject (value) {\n  return {\n    t: value,\n    min: value,\n    max: value,\n    sos: value * value,\n    c: 1\n  }\n}\n\nfunction getBucket (type, name, params, customParams) {\n  if (!aggregatedData[type]) aggregatedData[type] = {}\n  var bucket = aggregatedData[type][name]\n  if (!bucket) {\n    bucket = aggregatedData[type][name] = { params: params || {} }\n    if (customParams) {\n      bucket.custom = customParams\n    }\n  }\n  return bucket\n}\n\nfunction get (type, name) {\n  // if name is passed, get a single bucket\n  if (name) return aggregatedData[type] && aggregatedData[type][name]\n  // else, get all buckets of that type\n  return aggregatedData[type]\n}\n\n// Like get, but for many types and it deletes the retrieved content from the aggregatedData\nfunction take (types) {\n  var results = {}\n  var type = ''\n  var hasData = false\n  for (var i = 0; i < types.length; i++) {\n    type = types[i]\n    results[type] = toArray(aggregatedData[type])\n    if (results[type].length) hasData = true\n    delete aggregatedData[type]\n  }\n  return hasData ? results : null\n}\n\nfunction toArray (obj) {\n  if (typeof obj !== 'object') return []\n\n  return mapOwn(obj, getValue)\n}\n\nfunction getValue (key, value) {\n  return value\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar register = require(17)\nvar harvest = require(10)\nvar agg = require(2)\nvar single = require(19)\nvar submitData = require(23)\nvar mapOwn = require(38)\nvar loader = require(\"loader\")\nvar handle = require(\"handle\")\nvar config = require(35)\nvar cycle = 0\n\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\nharvest.on('jserrors', function () {\n  return { qs: agg.take([ 'cm' ]) }\n})\n\nvar api = {\n  finished: single(finished),\n  setPageViewName: setPageViewName,\n  setErrorHandler: setErrorHandler,\n  addToTrace: addToTrace,\n  inlineHit: inlineHit,\n  addRelease: addRelease\n}\n\n// Hook all of the api functions up to the queues/stubs created in loader/api.js\nmapOwn(api, function (fnName, fn) {\n  register('api-' + fnName, fn, 'api')\n})\n\n// All API functions get passed the time they were called as their\n// first parameter. These functions can be called asynchronously.\n\nfunction setPageViewName (t, name, host) {\n  if (typeof name !== 'string') return\n  if (name.charAt(0) !== '/') name = '/' + name\n  loader.customTransaction = (host || 'http://custom.transaction') + name\n}\n\nfunction finished (t, providedTime) {\n  var time = providedTime ? providedTime - loader.offset : t\n  agg.store('cm', 'finished', { name: 'finished' }, { time: time })\n  addToTrace(t, { name: 'finished', start: time + loader.offset, origin: 'nr' })\n  handle('api-addPageAction', [ time, 'finished' ])\n}\n\nfunction addToTrace (t, evt) {\n  if (!(evt && typeof evt === 'object' && evt.name && evt.start)) return\n\n  var report = {\n    n: evt.name,\n    s: evt.start - loader.offset,\n    e: (evt.end || evt.start) - loader.offset,\n    o: evt.origin || '',\n    t: 'api'\n  }\n\n  handle('bstApi', [report])\n}\n\n// NREUM.inlineHit(request_name, queue_time, app_time, total_be_time, dom_time, fe_time)\n//\n// request_name - the 'web page' name or service name\n// queue_time - the amount of time spent in the app tier queue\n// app_time - the amount of time spent in the application code\n// total_be_time - the total roundtrip time of the remote service call\n// dom_time - the time spent processing the result of the service call (or user defined)\n// fe_time - the time spent rendering the result of the service call (or user defined)\nfunction inlineHit (t, request_name, queue_time, app_time, total_be_time, dom_time, fe_time) {\n  request_name = window.encodeURIComponent(request_name)\n  cycle += 1\n\n  if (!loader.info.beacon) return\n\n  var url = scheme + '://' + loader.info.beacon + '/1/' + loader.info.licenseKey\n\n  url += '?a=' + loader.info.applicationID + '&'\n  url += 't=' + request_name + '&'\n  url += 'qt=' + ~~queue_time + '&'\n  url += 'ap=' + ~~app_time + '&'\n  url += 'be=' + ~~total_be_time + '&'\n  url += 'dc=' + ~~dom_time + '&'\n  url += 'fe=' + ~~fe_time + '&'\n  url += 'c=' + cycle\n\n  submitData.img(url)\n}\n\nfunction setErrorHandler (t, handler) {\n  loader.onerror = handler\n}\n\nvar releaseCount = 0\nfunction addRelease (t, name, id) {\n  if (++releaseCount > 10) return\n  loader.releaseIds[name.slice(-200)] = ('' + id).slice(-200)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\nvar stringify = require(22)\n\nvar hasOwnProp = Object.prototype.hasOwnProperty\nvar MAX_ATTRIBUTES = 64\n\nmodule.exports = {\n  nullable: nullable,\n  numeric: numeric,\n  getAddStringContext: getAddStringContext,\n  addCustomAttributes: addCustomAttributes\n}\n\nfunction nullable (val, fn, comma) {\n  return val || val === 0 || val === ''\n    ? fn(val) + (comma ? ',' : '')\n    : '!'\n}\n\nfunction numeric (n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36)\n  }\n  return (n === undefined || n === 0) ? '' : Math.floor(n).toString(36)\n}\n\nfunction getAddStringContext () {\n  var stringTable = Object.hasOwnProperty('create') ? Object.create(null) : {}\n  var stringTableIdx = 0\n\n  return addString\n\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return ''\n    str = String(str)\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true)\n    } else {\n      stringTable[str] = stringTableIdx++\n      return quoteString(str)\n    }\n  }\n}\n\nfunction addCustomAttributes (attrs, addString) {\n  var attrParts = []\n\n  mapOwn(attrs, function (key, val) {\n    if (attrParts.length >= MAX_ATTRIBUTES) return\n    var type = 5\n    var serializedValue\n    // add key to string table first\n    key = addString(key)\n\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val))\n        } else {\n          // null attribute type\n          type = 9\n        }\n        break\n      case 'number':\n        type = 6\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.'\n        break\n      case 'boolean':\n        type = val ? 7 : 8\n        break\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9\n        break\n      default:\n        serializedValue = addString(val)\n    }\n\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')])\n  })\n\n  return attrParts\n}\n\nvar escapable = /([,\\\\;])/g\n\nfunction quoteString (str) {\n  return \"'\" + str.replace(escapable, '\\\\$1')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar withHash = /([^?#]*)[^#]*(#[^?]*|$).*/\nvar withoutHash = /([^?#]*)().*/\nmodule.exports = function cleanURL (url, keepHash) {\n  return url.replace(keepHash ? withHash : withoutHash, '$1$2')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar baseEE = require(\"ee\")\nvar mapOwn = require(38)\nvar handlers = require(17).handlers\n\nmodule.exports = function drain (group) {\n  var bufferedEventsInGroup = baseEE.backlog[group]\n  var groupHandlers = handlers[group]\n  if (groupHandlers) {\n    // don't cache length, buffer can grow while processing\n    for (var i = 0; bufferedEventsInGroup && i < bufferedEventsInGroup.length; ++i) { // eslint-disable-line no-unmodified-loop-condition\n      emitEvent(bufferedEventsInGroup[i], groupHandlers)\n    }\n\n    mapOwn(groupHandlers, function (eventType, handlerRegistrationList) {\n      mapOwn(handlerRegistrationList, function (i, registration) {\n        // registration is an array of: [targetEE, eventHandler]\n        registration[0].on(eventType, registration[1])\n      })\n    })\n  }\n\n  delete handlers[group]\n  // Keep the group as a property so we know it was created and drained\n  baseEE.backlog[group] = null\n}\n\nfunction emitEvent (evt, groupHandlers) {\n  var type = evt[1]\n  mapOwn(groupHandlers[type], function (i, registration) {\n    var sourceEE = evt[0]\n    var ee = registration[0]\n    if (ee === sourceEE) {\n      var handler = registration[1]\n      var ctx = evt[3]\n      var args = evt[2]\n      handler.apply(ctx, args)\n    }\n  })\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\nvar stringify = require(22)\n\n  // Characters that are safe in a qs, but get encoded.\nvar charMap = {\n  '%2C': ',',\n  '%3A': ':',\n  '%2F': '/',\n  '%40': '@',\n  '%24': '$',\n  '%3B': ';'\n}\n\nvar charList = mapOwn(charMap, function (k) { return k })\nvar safeEncoded = new RegExp(charList.join('|'), 'g')\n\nfunction real (c) {\n  return charMap[c]\n}\n\n// Encode as URI Component, then unescape anything that is ok in the\n// query string position.\nfunction qs (value) {\n  if (value === null || value === undefined) return 'null'\n  return encodeURIComponent(value).replace(safeEncoded, real)\n}\n\nmodule.exports = {obj: obj, fromArray: fromArray, qs: qs, param: param}\n\nfunction fromArray (qs, maxBytes) {\n  var bytes = 0\n  for (var i = 0; i < qs.length; i++) {\n    bytes += qs[i].length\n    if (bytes > maxBytes) return qs.slice(0, i).join('')\n  }\n  return qs.join('')\n}\n\nfunction obj (payload, maxBytes) {\n  var total = 0\n  var result = ''\n\n  mapOwn(payload, function (feature, dataArray) {\n    var intermediate = []\n    var next\n    var i\n\n    if (typeof dataArray === 'string') {\n      next = '&' + feature + '=' + qs(dataArray)\n      total += next.length\n      result += next\n    } else if (dataArray.length) {\n      total += 9\n      for (i = 0; i < dataArray.length; i++) {\n        next = qs(stringify(dataArray[i]))\n        total += next.length\n        if (typeof maxBytes !== 'undefined' && total >= maxBytes) break\n        intermediate.push(next)\n      }\n      result += '&' + feature + '=%5B' + intermediate.join(',') + '%5D'\n    }\n  })\n  return result\n}\n\n// Constructs an HTTP parameter to add to the BAM router URL\nfunction param (name, value) {\n  if (value && typeof (value) === 'string') {\n    return '&' + name + '=' + qs(value)\n  }\n  return ''\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\nvar ee = require(\"ee\")\nvar drain = require(6)\n\nmodule.exports = function activateFeatures (flags) {\n  if (!(flags && typeof flags === 'object')) return\n  mapOwn(flags, function (flag, val) {\n    if (!val || activatedFeatures[flag]) return\n    ee.emit('feat-' + flag, [])\n    activatedFeatures[flag] = true\n  })\n\n  drain('feature')\n}\n\nvar activatedFeatures = module.exports.active = {}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar harvest = require(10)\nvar submitData = require(23)\n\nmodule.exports = HarvestScheduler\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nfunction HarvestScheduler(loader, endpoint, opts) {\n  this.loader = loader\n  this.endpoint = endpoint\n  this.opts = opts || {}\n  this.started = false\n  this.timeoutHandle = null\n}\n\nHarvestScheduler.prototype.startTimer = function startTimer(interval, initialDelay) {\n  this.interval = interval\n  this.started = true\n  this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval)\n}\n\nHarvestScheduler.prototype.stopTimer = function stopTimer() {\n  this.started = false\n  if (this.timeoutHandle) {\n    clearTimeout(this.timeoutHandle)\n  }\n}\n\nHarvestScheduler.prototype.scheduleHarvest = function scheduleHarvest(delay, opts) {\n  if (this.timeoutHandle) return\n  var timer = this\n\n  if (delay == null) {\n    delay = this.interval\n  }\n  this.timeoutHandle = setTimeout(function() {\n    timer.timeoutHandle = null\n    timer.runHarvest(opts)\n  }, delay * 1000)\n}\n\nHarvestScheduler.prototype.runHarvest = function runHarvest(opts) {\n  var scheduler = this\n\n  if (this.opts.getPayload) {\n    var submitMethod = harvest.getSubmitMethod(this.endpoint)\n    if (!submitMethod) return false\n\n    var retry = submitMethod.method === submitData.xhr\n    var payload = this.opts.getPayload({ retry: retry })\n    if (payload) {\n      harvest.send(this.endpoint, this.loader, payload, opts, submitMethod, onHarvestFinished)\n    }\n  } else {\n    harvest.sendX(this.endpoint, this.loader, opts, onHarvestFinished)\n  }\n\n  if (this.started) {\n    this.scheduleHarvest()\n  }\n\n  function onHarvestFinished(result) {\n    scheduler.onHarvestFinished(opts, result)\n  }\n}\n\nHarvestScheduler.prototype.onHarvestFinished = function onHarvestFinished(opts, result) {\n  if (this.opts.onFinished) {\n    this.opts.onFinished(result)\n  }\n\n  if (result.sent && result.retry) {\n    var delay = result.delay || this.opts.retryDelay\n    // reschedule next harvest if should be delayed longer\n    if (this.started && delay) {\n      clearTimeout(this.timeoutHandle)\n      this.timeoutHandle = null\n      this.scheduleHarvest(delay, opts)\n    } else if (!this.started && delay) {\n      // if not running on a timer, schedule a single retry\n      this.scheduleHarvest(delay, opts)\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar single = require(19)\nvar mapOwn = require(38)\nvar timing = require(15)\nvar encode = require(7)\nvar stringify = require(22)\nvar submitData = require(23)\nvar reduce = require(41)\nvar aggregator = require(2)\nvar stopwatch = require(21)\nvar locationUtil = require(13)\nvar config = require(35)\n\nvar cleanURL = require(5)\n\nvar version = 'DEVELOPMENT'\nvar jsonp = 'NREUM.setToken'\nvar _events = {}\nvar haveSendBeacon = !!navigator.sendBeacon\nvar tooManyRequestsDelay = config.getConfiguration('harvest.tooManyRequestsDelay') || 60\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\n// requiring ie version updates the IE version on the loader object\nvar ieVersion = require(11)\nvar xhrUsable = ieVersion > 9 || ieVersion === 0\n\nvar addPaintMetric = require(16).addMetric\n\nmodule.exports = {\n  sendRUM: single(sendRUM), // wrapping this in single makes it so that it can only be called once from outside\n  sendFinal: sendAllFromUnload,\n  pingErrors: pingErrors,\n  sendX: sendX,\n  send: send,\n  on: on,\n  xhrUsable: xhrUsable,\n  resetListeners: resetListeners,\n  getSubmitMethod: getSubmitMethod\n}\n\n// nr is injected into all send methods. This allows for easier testing\n// we could require('loader') instead\nfunction sendRUM (nr) {\n  if (!nr.info.beacon) return\n  if (nr.info.queueTime) aggregator.store('measures', 'qt', { value: nr.info.queueTime })\n  if (nr.info.applicationTime) aggregator.store('measures', 'ap', { value: nr.info.applicationTime })\n\n  // some time in the past some code will have called stopwatch.mark('starttime', Date.now())\n  // calling measure like this will create a metric that measures the time differential between\n  // the two marks.\n  stopwatch.measure('be', 'starttime', 'firstbyte')\n  stopwatch.measure('fe', 'firstbyte', 'onload')\n  stopwatch.measure('dc', 'firstbyte', 'domContent')\n\n  var measuresMetrics = aggregator.get('measures')\n\n  var measuresQueryString = mapOwn(measuresMetrics, function (metricName, measure) {\n    return '&' + metricName + '=' + measure.params.value\n  }).join('')\n\n  if (measuresQueryString) {\n    // currently we only have one version of our protocol\n    // in the future we may add more\n    var protocol = '1'\n\n    var chunksForQueryString = [baseQueryString(nr)]\n\n    chunksForQueryString.push(measuresQueryString)\n\n    chunksForQueryString.push(encode.param('tt', nr.info.ttGuid))\n    chunksForQueryString.push(encode.param('us', nr.info.user))\n    chunksForQueryString.push(encode.param('ac', nr.info.account))\n    chunksForQueryString.push(encode.param('pr', nr.info.product))\n    chunksForQueryString.push(encode.param('af', mapOwn(nr.features, function (k) { return k }).join(',')))\n\n    if (window.performance && typeof (window.performance.timing) !== 'undefined') {\n      var navTimingApiData = ({\n        timing: timing.addPT(window.performance.timing, {}),\n        navigation: timing.addPN(window.performance.navigation, {})\n      })\n      chunksForQueryString.push(encode.param('perf', stringify(navTimingApiData)))\n    }\n\n    if (window.performance && window.performance.getEntriesByType) {\n      var entries = window.performance.getEntriesByType('paint')\n      if (entries && entries.length > 0) {\n        entries.forEach(function(entry) {\n          if (!entry.startTime || entry.startTime <= 0) return\n\n          if (entry.name === 'first-paint') {\n            chunksForQueryString.push(encode.param('fp',\n              String(Math.floor(entry.startTime))))\n          } else if (entry.name === 'first-contentful-paint') {\n            chunksForQueryString.push(encode.param('fcp',\n              String(Math.floor(entry.startTime))))\n          }\n          addPaintMetric(entry.name, Math.floor(entry.startTime))\n        })\n      }\n    }\n\n    chunksForQueryString.push(encode.param('xx', nr.info.extra))\n    chunksForQueryString.push(encode.param('ua', nr.info.userAttributes))\n    chunksForQueryString.push(encode.param('at', nr.info.atts))\n\n    var customJsAttributes = stringify(nr.info.jsAttributes)\n    chunksForQueryString.push(encode.param('ja', customJsAttributes === '{}' ? null : customJsAttributes))\n\n    var queryString = encode.fromArray(chunksForQueryString, nr.maxBytes)\n\n    submitData.jsonp(\n      scheme + '://' + nr.info.beacon + '/' + protocol + '/' + nr.info.licenseKey + queryString,\n      jsonp\n    )\n  }\n}\n\nfunction sendAllFromUnload (nr) {\n  var sents = mapOwn(_events, function (endpoint) {\n    return sendX(endpoint, nr, { unload: true })\n  })\n  return reduce(sents, or)\n}\n\nfunction or (a, b) { return a || b }\n\nfunction createPayload (type, options) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  var listeners = (_events[type] && _events[type] || [])\n\n  for (var i = 0; i < listeners.length; i++) {\n    var singlePayload = listeners[i](options)\n    if (!singlePayload) continue\n    if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n    if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n  }\n  return { body: makeBody(), qs: makeQueryString() }\n}\n\n/**\n * Initiate a harvest from multiple sources. An event that corresponds to the endpoint\n * name is emitted, which gives any listeners the opportunity to provide payload data.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction sendX (endpoint, nr, opts, cbFinished) {\n  var submitMethod = getSubmitMethod(endpoint, opts)\n  if (!submitMethod) return false\n  var options = {\n    retry: submitMethod.method === submitData.xhr\n  }\n  return _send(endpoint, nr, createPayload(endpoint, options), opts, submitMethod, cbFinished)\n}\n\n/**\n * Initiate a harvest call.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} singlePayload - Object representing payload.\n * @param {object} singlePayload.qs - Map of values that should be sent as part of the request query string.\n * @param {string} singlePayload.body - String that should be sent as the body of the request.\n * @param {string} singlePayload.body.e - Special case of body used for browser interactions.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction send (endpoint, nr, singlePayload, opts, submitMethod, cbFinished) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n  if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n\n  var payload = { body: makeBody(), qs: makeQueryString() }\n  return _send(endpoint, nr, payload, opts, submitMethod, cbFinished)\n}\n\nfunction _send (endpoint, nr, payload, opts, submitMethod, cbFinished) {\n  if (!nr.info.errorBeacon) return false\n\n  // custom metrics data (cm) is sent as a query parameter to /jserrors\n  if (!payload.body && !(endpoint === 'jserrors' && payload.qs && payload.qs.cm)) {\n    if (cbFinished) {\n      cbFinished({ sent: false })\n    }\n    return false\n  }\n\n  if (!opts) opts = {}\n\n  var url = scheme + '://' + nr.info.errorBeacon + '/' + endpoint + '/1/' + nr.info.licenseKey + baseQueryString(nr)\n  if (payload.qs) url += encode.obj(payload.qs, nr.maxBytes)\n\n  if (!submitMethod) {\n    submitMethod = getSubmitMethod(endpoint, opts)\n  }\n  var method = submitMethod.method\n  var useBody = submitMethod.useBody\n\n  var body\n  var fullUrl = url\n  if (useBody && endpoint === 'events') {\n    body = payload.body.e\n  } else if (useBody) {\n    body = stringify(payload.body)\n  } else {\n    fullUrl = url + encode.obj(payload.body, nr.maxBytes)\n  }\n\n  var result = method(fullUrl, body)\n\n  if (cbFinished && method === submitData.xhr) {\n    var xhr = result\n    xhr.addEventListener('load', function () {\n      var result = { sent: true }\n      if (this.status === 429) {\n        result.retry = true\n        result.delay = tooManyRequestsDelay\n      } else if (this.status === 408 || this.status === 500 || this.status === 503) {\n        result.retry = true\n      }\n\n      if (opts.needResponse) {\n        result.responseText = this.responseText\n      }\n      cbFinished(result)\n    }, false)\n  }\n\n  // if beacon request failed, retry with an alternative method\n  if (!result && method === submitData.beacon) {\n    method = submitData.img\n    result = method(url + encode.obj(payload.body, nr.maxBytes))\n  }\n\n  return result\n}\n\nfunction getSubmitMethod(endpoint, opts) {\n  opts = opts || {}\n  var method\n  var useBody\n\n  if (opts.needResponse) {\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else {\n      return false\n    }\n  } else if (opts.unload) {\n    useBody = haveSendBeacon\n    method = haveSendBeacon ? submitData.beacon : submitData.img\n  } else {\n    // `submitData.beacon` was removed, there is an upper limit to the\n    // number of data allowed before it starts failing, so we save it for\n    // unload data\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else if (endpoint === 'events' || endpoint === 'jserrors') {\n      method = submitData.img\n    } else {\n      return false\n    }\n  }\n\n  return {\n    method: method,\n    useBody: useBody\n  }\n}\n\nfunction pingErrors (nr) {\n  if (scheme === 'http' || !(nr && nr.info && nr.info.errorBeacon && nr.ieVersion)) return\n\n  var url = 'https://' + nr.info.errorBeacon + '/jserrors/ping/' + nr.info.licenseKey + baseQueryString(nr)\n\n  submitData.img(url)\n}\n\n// Constructs the transaction name param for the beacon URL.\n// Prefers the obfuscated transaction name over the plain text.\n// Falls back to making up a name.\nfunction transactionNameParam (nr) {\n  if (nr.info.transactionName) return encode.param('to', nr.info.transactionName)\n  return encode.param('t', nr.info.tNamePlain || 'Unnamed Transaction')\n}\n\nfunction on (type, listener) {\n  var listeners = (_events[type] || (_events[type] = []))\n  listeners.push(listener)\n}\n\nfunction resetListeners() {\n  mapOwn(_events, function(key) {\n    _events[key] = []\n  })\n}\n\n// The stuff that gets sent every time.\nfunction baseQueryString (nr) {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  return ([\n    '?a=' + nr.info.applicationID,\n    encode.param('sa', (nr.info.sa ? '' + nr.info.sa : '')),\n    encode.param('v', version),\n    transactionNameParam(nr),\n    encode.param('ct', nr.customTransaction),\n    '&rst=' + nr.now(),\n    '&ck=' + (areCookiesEnabled ? '1' : '0'),\n    encode.param('ref', cleanURL(locationUtil.getLocation()))\n  ].join(''))\n}\n\n// returns a function that can be called to accumulate values to a single object\n// when the function is called without parameters, then the accumulator is returned\nfunction createAccumulator () {\n  var accumulator = {}\n  var hasData = false\n  return function (key, val) {\n    if (val && val.length) {\n      accumulator[key] = val\n      hasData = true\n    }\n    if (hasData) return accumulator\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar div = document.createElement('div')\n\ndiv.innerHTML = '<!--[if lte IE 6]><div></div><![endif]-->' +\n  '<!--[if lte IE 7]><div></div><![endif]-->' +\n  '<!--[if lte IE 8]><div></div><![endif]-->' +\n  '<!--[if lte IE 9]><div></div><![endif]-->'\n\nvar len = div.getElementsByTagName('div').length\n\nvar ieVersion\nif (len === 4) ieVersion = 6\nelse if (len === 3) ieVersion = 7\nelse if (len === 2) ieVersion = 8\nelse if (len === 1) ieVersion = 9\nelse ieVersion = 0\n\nmodule.exports = ieVersion\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stopwatch = require(21)\nvar subscribeToUnload = require(25)\nvar harvest = require(10)\nvar registerHandler = require(17)\nvar activateFeatures = require(8)\nvar loader = require(\"loader\")\nvar drain = require(6)\nvar navCookie = require(14)\nvar config = require(35)\n\n// api loads registers several event listeners, but does not have any exports\nrequire(3)\n\n// Register event listeners and schedule harvests for performance timings.\nrequire(24).init(loader, config.getConfiguration('page_view_timing'))\n\nvar autorun = typeof (window.NREUM.autorun) !== 'undefined' ? window.NREUM.autorun : true\n\n// Features are activated using the legacy setToken function name via JSONP\nwindow.NREUM.setToken = activateFeatures\n\nif (require(11) === 6) loader.maxBytes = 2000\nelse loader.maxBytes = 30000\n\nloader.releaseIds = {}\n\nsubscribeToUnload(finalHarvest)\n\nregisterHandler('mark', stopwatch.mark, 'api')\n\nstopwatch.mark('done')\n\ndrain('api')\n\nif (autorun) harvest.sendRUM(loader)\n\n// Set a cookie when the page unloads. Consume this cookie on the next page to get a 'start time'.\n// The navigation start time cookie is removed when the browser supports the web timing API.\n// Doesn't work in some browsers (Opera).\nfunction finalHarvest (e) {\n  harvest.sendFinal(loader, false)\n  // write navigation start time cookie if needed\n  navCookie.conditionallySet()\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getLocation: getLocation\n}\n\nfunction getLocation() {\n  return '' + location\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar sHash = require(18)\nvar startTime = require(20)\n\n// functions are on object, so that they can be mocked\nvar exp = {\n  conditionallySet: conditionallySet,\n  setCookie: setCookie\n}\n\nmodule.exports = exp\n\nfunction conditionallySet() {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  if (startTime.navCookie && areCookiesEnabled) {\n    exp.setCookie()\n  }\n}\n\nfunction setCookie() {\n  document.cookie = 'NREUM=s=' + Number(new Date()) + '&r=' + sHash(document.location.href) + '&p=' + sHash(document.referrer) + '; path=/'\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\n\nvar START = 'Start'\nvar END = 'End'\nvar UNLOAD_EVENT = 'unloadEvent'\nvar REDIRECT = 'redirect'\nvar DOMAIN_LOOKUP = 'domainLookup'\nvar ONNECT = 'onnect'\nvar REQUEST = 'request'\nvar RESPONSE = 'response'\nvar LOAD_EVENT = 'loadEvent'\nvar DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent'\n\nvar navTimingValues = []\nmodule.exports = {\n  addPT: addPT,\n  addPN: addPN,\n  nt: navTimingValues\n}\n\nfunction addPT (pt, v) {\n  var offset = pt['navigation' + START]\n  v.of = offset\n  addRel(offset, offset, v, 'n')\n  addRel(pt[UNLOAD_EVENT + START], offset, v, 'u')\n  addRel(pt[REDIRECT + START], offset, v, 'r')\n  addRel(pt[UNLOAD_EVENT + END], offset, v, 'ue')\n  addRel(pt[REDIRECT + END], offset, v, 're')\n  addRel(pt['fetch' + START], offset, v, 'f')\n  addRel(pt[DOMAIN_LOOKUP + START], offset, v, 'dn')\n  addRel(pt[DOMAIN_LOOKUP + END], offset, v, 'dne')\n  addRel(pt['c' + ONNECT + START], offset, v, 'c')\n  addRel(pt['secureC' + ONNECT + 'ion' + START], offset, v, 's')\n  addRel(pt['c' + ONNECT + END], offset, v, 'ce')\n  addRel(pt[REQUEST + START], offset, v, 'rq')\n  addRel(pt[RESPONSE + START], offset, v, 'rp')\n  addRel(pt[RESPONSE + END], offset, v, 'rpe')\n  addRel(pt.domLoading, offset, v, 'dl')\n  addRel(pt.domInteractive, offset, v, 'di')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + START], offset, v, 'ds')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + END], offset, v, 'de')\n  addRel(pt.domComplete, offset, v, 'dc')\n  addRel(pt[LOAD_EVENT + START], offset, v, 'l')\n  addRel(pt[LOAD_EVENT + END], offset, v, 'le')\n  return v\n}\n\n// Add Performance Navigation values to the given object\nfunction addPN (pn, v) {\n  addRel(pn.type, 0, v, 'ty')\n  addRel(pn.redirectCount, 0, v, 'rc')\n  return v\n}\n\nfunction addRel (value, offset, obj, prop) {\n  var relativeValue\n  if (typeof (value) === 'number' && (value > 0)) {\n    relativeValue = Math.round(value - offset)\n    obj[prop] = relativeValue\n  }\n  navTimingValues.push(relativeValue)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar paintMetrics = {}\n\nmodule.exports = {\n  addMetric: addMetric,\n  metrics: paintMetrics\n}\n\nfunction addMetric (name, value) {\n  paintMetrics[name] = value\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handleEE = require(\"handle\").ee\n\nmodule.exports = defaultRegister\n\ndefaultRegister.on = registerWithSpecificEmitter\n\nvar handlers = defaultRegister.handlers = {}\n\nfunction defaultRegister (type, handler, group, ee) {\n  registerWithSpecificEmitter(ee || handleEE, type, handler, group)\n}\n\nfunction registerWithSpecificEmitter (ee, type, handler, group) {\n  if (!group) group = 'feature'\n  if (!ee) ee = handleEE\n  var groupHandlers = handlers[group] = handlers[group] || {}\n  var list = groupHandlers[type] = groupHandlers[type] || []\n  list.push([ee, handler])\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = sHash\n\nfunction sHash (s) {\n  var i\n  var h = 0\n\n  for (i = 0; i < s.length; i++) {\n    h += ((i + 1) * s.charCodeAt(i))\n  }\n  return Math.abs(h)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar slice = require(39)\n\nmodule.exports = single\n\nfunction single (fn) {\n  var called = false\n  var res\n\n  return function () {\n    if (called) return res\n    called = true\n    res = fn.apply(this, slice(arguments))\n    return res\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Use various techniques to determine the time at which this page started and whether to capture navigation timing information\n\nvar sHash = require(18)\nvar stopwatch = require(21)\nvar loader = require(\"loader\")\nvar ffVersion = require(36)\n\nmodule.exports = { navCookie: true }\n\nfindStartTime()\n\nfunction findStartTime () {\n  var starttime = findStartWebTiming() || findStartCookie()\n\n  if (!starttime) return\n\n  stopwatch.mark('starttime', starttime)\n  // Refine loader.offset\n  loader.offset = starttime\n}\n\n// Find the start time from the Web Timing 'performance' object.\n// http://test.w3.org/webperf/specs/NavigationTiming/\n// http://blog.chromium.org/2010/07/do-you-know-how-slow-your-web-page-is.html\nfunction findStartWebTiming () {\n  // FF 7/8 has a bug with the navigation start time, so use cookie instead of native interface\n  if (ffVersion && ffVersion < 9) return\n\n  var performanceCheck = require(40)\n  if (performanceCheck.exists) {\n    // note that we don't need to use a cookie to record navigation start time\n    module.exports.navCookie = false\n    return window.performance.timing.navigationStart\n  }\n}\n\n// Find the start time based on a cookie set by Episodes in the unload handler.\nfunction findStartCookie () {\n  var aCookies = document.cookie.split(' ')\n\n  for (var i = 0; i < aCookies.length; i++) {\n    if (aCookies[i].indexOf('NREUM=') === 0) {\n      var startPage\n      var referrerPage\n      var aSubCookies = aCookies[i].substring('NREUM='.length).split('&')\n      var startTime\n      var bReferrerMatch\n\n      for (var j = 0; j < aSubCookies.length; j++) {\n        if (aSubCookies[j].indexOf('s=') === 0) {\n          startTime = aSubCookies[j].substring(2)\n        } else if (aSubCookies[j].indexOf('p=') === 0) {\n          referrerPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (referrerPage.charAt(referrerPage.length - 1) === ';') {\n            referrerPage = referrerPage.substr(0, referrerPage.length - 1)\n          }\n        } else if (aSubCookies[j].indexOf('r=') === 0) {\n          startPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (startPage.charAt(startPage.length - 1) === ';') {\n            startPage = startPage.substr(0, startPage.length - 1)\n          }\n        }\n      }\n\n      if (startPage) {\n        var docReferrer = sHash(document.referrer)\n        bReferrerMatch = (docReferrer == startPage) // eslint-disable-line\n        if (!bReferrerMatch) {\n          // Navigation did not start at the page that was just exited, check for re-load\n          // (i.e. the page just exited is the current page and the referring pages match)\n          bReferrerMatch = sHash(document.location.href) == startPage && docReferrer == referrerPage // eslint-disable-line\n        }\n      }\n      if (bReferrerMatch && startTime) {\n        var now = new Date().getTime()\n        if ((now - startTime) > 60000) {\n          return\n        }\n        return startTime\n      }\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar aggregator = require(2)\nvar now = require(37)\n\nvar marks = {}\n\nmodule.exports = {\n  mark: mark,\n  measure: measure\n}\n\nfunction mark (markName, markTime) {\n  if (typeof markTime === 'undefined') markTime = (now() + now.offset)\n  marks[markName] = markTime\n}\n\nfunction measure (metricName, startMark, endMark) {\n  var start = marks[startMark]\n  var end = marks[endMark]\n\n  if (typeof start === 'undefined' || typeof end === 'undefined') return\n\n  aggregator.store('measures', metricName, { value: end - start })\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(38)\nvar ee = require(\"ee\")\n\nvar escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g // eslint-disable-line\nvar meta = {\n  '\\b': '\\\\b',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\f': '\\\\f',\n  '\\r': '\\\\r',\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\'\n}\n\nmodule.exports = stringify\n\nfunction stringify (val) {\n  try {\n    return str('', {'': val})\n  } catch (e) {\n    try {\n      ee.emit('internal-error', [e])\n    } catch (err) {\n    }\n  }\n}\n\nfunction quote (string) {\n  escapable.lastIndex = 0\n  return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n    var c = meta[a]\n    return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4)\n  }) + '\"' : '\"' + string + '\"'\n}\n\nfunction str (key, holder) {\n  var value = holder[key]\n\n  switch (typeof value) {\n    case 'string':\n      return quote(value)\n    case 'number':\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return String(value)\n    case 'object':\n      if (!value) { return 'null' }\n      var partial = []\n\n      // The value is an array. Stringify every element. Use null as a placeholder\n      // for non-JSON values.\n      if (value instanceof window.Array || Object.prototype.toString.apply(value) === '[object Array]') {\n        var length = value.length\n        for (var i = 0; i < length; i += 1) {\n          partial[i] = str(i, value) || 'null'\n        }\n\n        return partial.length === 0 ? '[]' : '[' + partial.join(',') + ']'\n      }\n\n      mapOwn(value, function (k) {\n        var v = str(k, value)\n        if (v) partial.push(quote(k) + ':' + v)\n      })\n\n      return partial.length === 0 ? '{}' : '{' + partial.join(',') + '}'\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar submitData = module.exports = {}\n\nsubmitData.jsonp = function jsonp (url, jsonp) {\n  var element = document.createElement('script')\n  element.type = 'text/javascript'\n  element.src = url + '&jsonp=' + jsonp\n  var firstScript = document.getElementsByTagName('script')[0]\n  firstScript.parentNode.insertBefore(element, firstScript)\n  return element\n}\n\nsubmitData.xhr = function xhr (url, body, sync) {\n  var request = new XMLHttpRequest()\n\n  request.open('POST', url, !sync)\n  try {\n    // Set cookie\n    if ('withCredentials' in request) request.withCredentials = true\n  } catch (e) {}\n\n  request.setRequestHeader('content-type', 'text/plain')\n  request.send(body)\n  return request\n}\n\nsubmitData.xhrSync = function xhrSync (url, body) {\n  return submitData.xhr(url, body, true)\n}\n\nsubmitData.img = function img (url) {\n  var element = new Image()\n  element.src = url\n  return element\n}\n\nsubmitData.beacon = function (url, body) {\n  return navigator.sendBeacon(url, body)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar nullable = require(4).nullable\nvar numeric = require(4).numeric\nvar getAddStringContext = require(4).getAddStringContext\nvar addCustomAttributes = require(4).addCustomAttributes\nvar now = require(37)\nvar mapOwn = require(38)\n\nvar loader = null\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar register = require(17)\nvar subscribeToUnload = require(25)\n\nvar timings = []\nvar timingsSent = []\nvar lcpRecorded = false\nvar lcp = null\nvar cls = null\nvar pageHideRecorded = false\n\nmodule.exports = {\n  getPayload: getPayload,\n  timings: timings,\n  init: init,\n  finalHarvest: finalHarvest\n}\n\nvar harvestTimeSeconds = 30\n\nfunction init(nr, options) {\n  if (!isEnabled(options)) return\n\n  loader = nr\n\n  if (!options) options = {}\n  var maxLCPTimeSeconds = options.maxLCPTimeSeconds || 60\n  var initialHarvestSeconds = options.initialHarvestSeconds || 10\n  harvestTimeSeconds = options.harvestTimeSeconds || 30\n\n  var scheduler = new HarvestScheduler(loader, 'events', { onFinished: onHarvestFinished, getPayload: prepareHarvest })\n\n  register('timing', processTiming)\n  register('lcp', updateLatestLcp)\n  register('cls', updateClsScore)\n  register('pageHide', updatePageHide)\n\n  // final harvest is initiated from the main agent module, but since harvesting\n  // here is not initiated by the harvester, we need to subscribe to the unload event\n  // separately\n  subscribeToUnload(finalHarvest)\n\n  // After 1 minute has passed, record LCP value if no user interaction has occurred first\n  setTimeout(function() {\n    recordLcp()\n    lcpRecorded = true\n  }, maxLCPTimeSeconds * 1000)\n\n  // send initial data sooner, then start regular\n  scheduler.startTimer(harvestTimeSeconds, initialHarvestSeconds)\n}\n\nfunction recordLcp() {\n  if (!lcpRecorded && lcp !== null) {\n    var lcpEntry = lcp[0]\n    var cls = lcp[1]\n\n    var attrs = {\n      'size': lcpEntry.size,\n      'eid': lcpEntry.id\n    }\n\n    if (cls) {\n      attrs['cls'] = cls\n    }\n\n    addTiming('lcp', Math.floor(lcpEntry.startTime), attrs, false)\n    lcpRecorded = true\n  }\n}\n\nfunction updateLatestLcp(lcpEntry) {\n  if (lcp) {\n    var previous = lcp[0]\n    if (previous.size >= lcpEntry.size) {\n      return\n    }\n  }\n  lcp = [lcpEntry, cls]\n}\n\nfunction updateClsScore(clsEntry) {\n  if (cls === null) {\n    cls = 0\n  }\n  cls += clsEntry.value\n}\n\nfunction updatePageHide(timestamp, state) {\n  if (!pageHideRecorded && state === 'hidden') {\n    addTiming('pageHide', timestamp, null, true)\n    pageHideRecorded = true\n  }\n}\n\nfunction recordUnload() {\n  addTiming('unload', now(), null, true)\n}\n\nfunction addTiming(name, value, attrs, addCls) {\n  attrs = attrs || {}\n\n  if (addCls && cls !== null) {\n    attrs['cls'] = cls\n  }\n\n  timings.push({\n    name: name,\n    value: value,\n    attrs: attrs\n  })\n}\n\nfunction processTiming(name, value, attrs) {\n  // Upon user interaction, the Browser stops executing LCP logic, so we can send here\n  // We're using setTimeout to give the Browser time to finish collecting LCP value\n  if (name === 'fi') {\n    setTimeout(recordLcp, 0)\n  }\n\n  addTiming(name, value, attrs, true)\n}\n\nfunction onHarvestFinished(result) {\n  if (result.retry && timingsSent.length > 0) {\n    for (var i = 0; i < timingsSent.length; i++) {\n      timings.push(timingsSent[i])\n    }\n    timingsSent = []\n  }\n}\n\nfunction finalHarvest() {\n  recordLcp()\n  recordUnload()\n  var payload = prepareHarvest({ retry: false })\n  harvest.send('events', loader, payload, { unload: true })\n}\n\nfunction appendGlobalCustomAttributes(timing) {\n  var timingAttributes = timing.attrs || {}\n  var customAttributes = loader.info.jsAttributes || {}\n\n  mapOwn(customAttributes, function (key, val) {\n    if (key !== 'size' && key !== 'eid' && key !== 'cls' && key !== 'type' && key !== 'fid') {\n      timingAttributes[key] = val\n    }\n  })\n}\n\n// serialize and return current timing data, clear and save current data for retry\nfunction prepareHarvest(options) {\n  if (timings.length === 0) return\n\n  var payload = getPayload(timings)\n  if (options.retry) {\n    for (var i = 0; i < timings.length; i++) {\n      timingsSent.push(timings[i])\n    }\n  }\n  timings = []\n  return { body: { e: payload } }\n}\n\n// serialize array of timing data\nfunction getPayload(data) {\n  var addString = getAddStringContext()\n\n  var payload = 'bel.6;'\n\n  for (var i = 0; i < data.length; i++) {\n    var timing = data[i]\n\n    payload += 'e,'\n    payload += addString(timing.name) + ','\n    payload += nullable(timing.value, numeric, false) + ','\n\n    appendGlobalCustomAttributes(timing)\n\n    var attrParts = addCustomAttributes(timing.attrs, addString)\n    if (attrParts && attrParts.length > 0) {\n      payload += numeric(attrParts.length) + ';' + attrParts.join(';')\n    }\n\n    if ((i + 1) < data.length) payload += ';'\n  }\n\n  return payload\n}\n\nfunction isEnabled(config) {\n  // collect page view timings unless the feature is explicitly disabled\n  if (config && config.enabled === false) {\n    return false\n  }\n  return true\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = require(36)\nvar single = require(19)\nvar addE = require(1)\n\nmodule.exports = subscribeToUnload\n\n// Used to subscribe a callback to when a page is being unloaded. This is used,\n// for example, to submit a final harvest.\nfunction subscribeToUnload (cb) {\n  var oneCall = single(cb)\n\n  // Firefox has a bug wherein a slow-loading resource loaded from the 'pagehide'\n  // or 'unload' event will delay the 'load' event firing on the next page load.\n  // In Firefox versions that support sendBeacon, this doesn't matter, because\n  // we'll use it instead of an image load for our final harvest.\n  //\n  // Some Safari versions never fire the 'unload' event for pages that are being\n  // put into the WebKit page cache, so we *need* to use the pagehide event for\n  // the final submission from Safari.\n  //\n  // Generally speaking, we will try to submit our final harvest from either\n  // pagehide or unload, whichever comes first, but in Firefox, we need to avoid\n  // attempting to submit from pagehide to ensure that we don't slow down loading\n  // of the next page.\n  if (!ffVersion || navigator.sendBeacon) {\n    addE('pagehide', oneCall)\n  } else {\n    addE('beforeunload', oneCall)\n  }\n  addE('unload', oneCall)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar canonicalFunctionNameRe = /([a-z0-9]+)$/i\nfunction canonicalFunctionName (orig) {\n  if (!orig) return\n\n  var match = orig.match(canonicalFunctionNameRe)\n  if (match) return match[1]\n\n  return\n}\n\nmodule.exports = canonicalFunctionName\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// computeStackTrace: cross-browser stack traces in JavaScript\n//\n// Syntax:\n//   s = computeStackTrace(exception) // consider using TraceKit.report instead\n// Returns:\n//   s.name              - exception name\n//   s.message           - exception message\n//   s.stack[i].url      - JavaScript or HTML file URL\n//   s.stack[i].func     - function name, or empty for anonymous functions\n//   s.stack[i].line     - line number, if known\n//   s.stack[i].column   - column number, if known\n//   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n//   s.mode              - 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace\n//\n// Supports:\n//   - Firefox:  full stack trace with line numbers and unreliable column\n//               number on top frame\n//   - Opera 10: full stack trace with line and column numbers\n//   - Opera 9-: full stack trace with line numbers\n//   - Chrome:   full stack trace with line and column numbers\n//   - Safari:   line and column number for the topmost stacktrace element\n//               only\n//   - IE:       no line numbers whatsoever\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n//\n// OPERA:\n// ex.message = ...message... (see the example below)\n// ex.name = ReferenceError\n// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\nvar reduce = require(41)\nvar formatStackTrace = require(28)\n\nvar has = Object.prototype.hasOwnProperty\nvar debug = false\n\nvar classNameRegex = /function (.+?)\\s*\\(/\nvar chrome = /^\\s*at (?:((?:\\[object object\\])?(?:[^(]*\\([^)]*\\))*[^()]*(?: \\[as \\S+\\])?) )?\\(?((?:file|http|https|chrome-extension):.*?)?:(\\d+)(?::(\\d+))?\\)?\\s*$/i\nvar gecko = /^\\s*(?:(\\S*|global code)(?:\\(.*?\\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\\d+)(?::(\\d+))?\\s*$/i\nvar chrome_eval = /^\\s*at .+ \\(eval at \\S+ \\((?:(?:file|http|https):[^)]+)?\\)(?:, [^:]*:\\d+:\\d+)?\\)$/i\nvar ie_eval = /^\\s*at Function code \\(Function code:\\d+:\\d+\\)\\s*/i\n\nmodule.exports = computeStackTrace\n\nfunction computeStackTrace (ex) {\n  var stack = null\n\n  try {\n    // This must be tried first because Opera 10 *destroys*\n    // its stacktrace property if you try to access the stack\n    // property first!!\n    stack = computeStackTraceFromStacktraceProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromStackProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromOperaMultiLineMessage(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceBySourceAndLine(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceWithMessageOnly(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  return {\n    'mode': 'failed',\n    'stackString': '',\n    'frames': []\n  }\n}\n\n/**\n * Computes stack trace information from the stack property.\n * Chrome and Gecko use this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStackProp (ex) {\n  if (!ex.stack) {\n    return null\n  }\n\n  var errorInfo = reduce(\n    ex.stack.split('\\n'),\n    parseStackProp,\n    {frames: [], stackLines: [], wrapperSeen: false}\n  )\n\n  if (!errorInfo.frames.length) return null\n\n  return {\n    'mode': 'stack',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(errorInfo.stackLines),\n    'frames': errorInfo.frames\n  }\n}\n\nfunction parseStackProp (info, line) {\n  var element = getElement(line)\n\n  if (!element) {\n    info.stackLines.push(line)\n    return info\n  }\n\n  if (isWrapper(element.func)) info.wrapperSeen = true\n  else info.stackLines.push(line)\n\n  if (!info.wrapperSeen) info.frames.push(element)\n  return info\n}\n\nfunction getElement (line) {\n  var parts = line.match(gecko)\n  if (!parts) parts = line.match(chrome)\n\n  if (parts) {\n    return ({\n      'url': parts[2],\n      'func': (parts[1] !== 'Anonymous function' && parts[1] !== 'global code' && parts[1]) || null,\n      'line': +parts[3],\n      'column': parts[4] ? +parts[4] : null\n    })\n  }\n\n  if (line.match(chrome_eval) || line.match(ie_eval) || line === 'anonymous') {\n    return { 'func': 'evaluated code' }\n  }\n}\n\nfunction computeStackTraceBySourceAndLine (ex) {\n  if (!('line' in ex)) return null\n\n  var className = ex.name || getClassName(ex)\n\n  // Safari does not provide a URL for errors in eval'd code\n  if (!ex.sourceURL) {\n    return ({\n      'mode': 'sourceline',\n      'name': className,\n      'message': ex.message,\n      'stackString': getClassName(ex) + ': ' + ex.message + '\\n    in evaluated code',\n      'frames': [{\n        'func': 'evaluated code'\n      }]\n    })\n  }\n\n  var stackString = className + ': ' + ex.message + '\\n    at ' + ex.sourceURL\n  if (ex.line) {\n    stackString += ':' + ex.line\n    if (ex.column) {\n      stackString += ':' + ex.column\n    }\n  }\n\n  return ({\n    'mode': 'sourceline',\n    'name': className,\n    'message': ex.message,\n    'stackString': stackString,\n    'frames': [{ 'url': ex.sourceURL,\n      'line': ex.line,\n      'column': ex.column\n    }]\n  })\n}\n\nfunction computeStackTraceWithMessageOnly (ex) {\n  var className = ex.name || getClassName(ex)\n  if (!className) return null\n\n  return ({\n    'mode': 'nameonly',\n    'name': className,\n    'message': ex.message,\n    'stackString': className + ': ' + ex.message,\n    'frames': []\n  })\n}\n\nfunction getClassName (obj) {\n  var results = classNameRegex.exec(String(obj.constructor))\n  return (results && results.length > 1) ? results[1] : 'unknown'\n}\n\nfunction isWrapper (functionName) {\n  return (functionName && functionName.indexOf('nrWrapper') >= 0)\n}\n\n/**\n * Computes stack trace information from the stacktrace property.\n * Opera 10 uses this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStacktraceProp (ex) {\n  if (!ex.stacktrace) {\n    return null\n  }\n\n  // Access and store the stacktrace property before doing anything\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = ex.stacktrace\n\n  var testRE = / line (\\d+), column (\\d+) in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\(.*\\) in (.*):\\s*$/i\n  var lines = stacktrace.split('\\n')\n  var frames = []\n  var stackLines = []\n  var parts\n  var wrapperSeen = false\n\n  for (var i = 0, j = lines.length; i < j; i += 2) {\n    if ((parts = testRE.exec(lines[i]))) {\n      var element = {\n        'line': +parts[1],\n        'column': +parts[2],\n        'func': parts[3] || parts[4],\n        'url': parts[5]\n      }\n\n      if (isWrapper(element.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(element)\n    } else {\n      stackLines.push(lines[i])\n    }\n  }\n\n  if (!frames.length) {\n    return null\n  }\n\n  return {\n    'mode': 'stacktrace',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n/**\n * Computes stack trace information from an error message that includes\n * the stack trace.\n * Opera 9 and earlier use this method if the option to show stack\n * traces is turned on in opera:config.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack information.\n */\nfunction computeStackTraceFromOperaMultiLineMessage (ex) {\n  // Opera includes a stack trace into the exception message. An example is:\n  //\n  // Statement on line 3: Undefined variable: undefinedFunc\n  // Backtrace:\n  //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz\n  //         undefinedFunc(a)\n  //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy\n  //           zzz(x, y, z)\n  //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx\n  //           yyy(a, a, a)\n  //   Line 1 of function script\n  //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }\n  //   ...\n\n  var lines = ex.message.split('\\n')\n  if (lines.length < 4) {\n    return null\n  }\n\n  var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i\n  var frames = []\n  var stackLines = []\n  var scripts = document.getElementsByTagName('script')\n  var inlineScriptBlocks = []\n  var parts\n  var i\n  var len\n  var wrapperSeen = false\n\n  for (i in scripts) {\n    if (has.call(scripts, i) && !scripts[i].src) {\n      inlineScriptBlocks.push(scripts[i])\n    }\n  }\n\n  for (i = 2, len = lines.length; i < len; i += 2) {\n    var item = null\n    if ((parts = lineRE1.exec(lines[i]))) {\n      item = {\n        'url': parts[2],\n        'func': parts[3],\n        'line': +parts[1]\n      }\n    } else if ((parts = lineRE2.exec(lines[i]))) {\n      item = {\n        'url': parts[3],\n        'func': parts[4]\n      }\n    } else if ((parts = lineRE3.exec(lines[i]))) {\n      var url = window.location.href.replace(/#.*$/, '')\n      var line = parts[1]\n\n      item = {\n        'url': url,\n        'line': line,\n        'func': ''\n      }\n    }\n\n    if (item) {\n      if (isWrapper(item.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(item)\n    }\n  }\n  if (!frames.length) {\n    return null // could not parse multiline exception message as Opera stack trace\n  }\n\n  return {\n    'mode': 'multiline',\n    'name': ex.name || getClassName(ex),\n    'message': lines[0],\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stripNewlinesRegex = /^\\n+|\\n+$/g\nvar MAX_STACK_TRACE_LENGTH = 65530\n\nmodule.exports = function (stackLines) {\n  return truncateStackLines(stackLines).replace(stripNewlinesRegex, '')\n}\n\nmodule.exports.truncateSize = truncateSize\n\n// takes array of stack lines and returns string with top 50 and buttom 50 lines\nfunction truncateStackLines(stackLines) {\n  var stackString\n  if (stackLines.length > 100) {\n    var truncatedLines = stackLines.length - 100\n    stackString = stackLines.slice(0, 50).join('\\n')\n    stackString += '\\n< ...truncated ' + truncatedLines + ' lines... >\\n'\n    stackString += stackLines.slice(-50).join('\\n')\n  } else {\n    stackString = stackLines.join('\\n')\n  }\n  return stackString\n}\n\n// truncates stack string to limit what is sent to backend\nfunction truncateSize(stackString) {\n  return (stackString.length > MAX_STACK_TRACE_LENGTH) ? stackString.substr(0, MAX_STACK_TRACE_LENGTH) : stackString\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar canonicalFunctionName = require(26)\nvar cleanURL = require(5)\nvar computeStackTrace = require(27)\nvar stringHashCode = require(30)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar stackReported = {}\nvar pageviewReported = {}\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar stringify = require(22)\nvar handle = require(\"handle\")\nvar baseEE = require(\"ee\")\nvar mapOwn = require(38)\nvar config = require(35)\nvar truncateSize = require(28).truncateSize\nvar errorCache = {}\nvar currentBody\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.err) return\nvar errorOnPage = false\n\nvar harvestTimeSeconds = config.getConfiguration('jserrors.harvestTimeSeconds') || 60\n\nee.on('feat-err', function () {\n  register('err', storeError)\n  register('ierr', storeError)\n\n  harvest.on('jserrors', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'jserrors', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds)\n})\n\nfunction onHarvestStarted(options) {\n  var body = agg.take([ 'err', 'ierr' ])\n\n  if (options.retry) {\n    currentBody = body\n  }\n\n  var payload = { body: body, qs: {} }\n  var releaseIds = stringify(loader.releaseIds)\n\n  if (releaseIds !== '{}') {\n    payload.qs.ri = releaseIds\n  }\n\n  if (body && body.err && body.err.length && !errorOnPage) {\n    payload.qs.pve = '1'\n    errorOnPage = true\n  }\n  return payload\n}\n\nfunction onHarvestFinished(result) {\n  if (!result.sent) {\n    // keep connection open\n    harvest.pingErrors(loader)\n  }\n\n  if (result.retry && currentBody) {\n    mapOwn(currentBody, function(key, value) {\n      for (var i = 0; i < value.length; i++) {\n        var bucket = value[i]\n        var name = getBucketName(bucket.params, bucket.custom)\n        agg.merge(key, name, bucket.metrics, bucket.params, bucket.custom)\n      }\n    })\n    currentBody = null\n  }\n}\n\n// open HTTPS connection, which is needed for sending data during page unload on older browsers\nharvest.pingErrors(loader)\n\nfunction nameHash (params) {\n  return stringHashCode(params.exceptionClass) ^ params.stackHash\n}\n\nfunction getBucketName(params, customParams) {\n  return nameHash(params) + ':' + stringHashCode(stringify(customParams))\n}\n\nfunction canonicalizeURL (url, cleanedOrigin) {\n  if (typeof url !== 'string') return ''\n\n  var cleanedURL = cleanURL(url)\n  if (cleanedURL === cleanedOrigin) {\n    return '<inline>'\n  } else {\n    return cleanedURL\n  }\n}\n\nfunction buildCanonicalStackString (stackInfo, cleanedOrigin) {\n  var canonicalStack = ''\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var func = canonicalFunctionName(frame.func)\n\n    if (canonicalStack) canonicalStack += '\\n'\n    if (func) canonicalStack += func + '@'\n    if (typeof frame.url === 'string') canonicalStack += frame.url\n    if (frame.line) canonicalStack += ':' + frame.line\n  }\n\n  return canonicalStack\n}\n\n// Strip query parameters and fragments from the stackString property of the\n// given stackInfo, along with the 'url' properties of each frame in\n// stackInfo.frames.\n//\n// Any URLs that are equivalent to the cleaned version of the origin will also\n// be replaced with the string '<inline>'.\n//\nfunction canonicalizeStackURLs (stackInfo) {\n  // Currently, loader.origin might contain a fragment, but we don't want to use it\n  // for comparing with frame URLs.\n  var cleanedOrigin = cleanURL(loader.origin)\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var originalURL = frame.url\n    var cleanedURL = canonicalizeURL(originalURL, cleanedOrigin)\n    if (cleanedURL && cleanedURL !== frame.url) {\n      frame.url = cleanedURL\n      stackInfo.stackString = stackInfo.stackString.split(originalURL).join(cleanedURL)\n    }\n  }\n\n  return stackInfo\n}\n\nfunction storeError (err, time, internal, customAttributes) {\n  // are we in an interaction\n  time = time || loader.now()\n  if (!internal && loader.onerror && loader.onerror(err)) return\n\n  var stackInfo = canonicalizeStackURLs(computeStackTrace(err))\n  var canonicalStack = buildCanonicalStackString(stackInfo)\n\n  var params = {\n    stackHash: stringHashCode(canonicalStack),\n    exceptionClass: stackInfo.name,\n    request_uri: window.location.pathname\n  }\n  if (stackInfo.message) {\n    params.message = '' + stackInfo.message\n  }\n\n  if (!stackReported[params.stackHash]) {\n    stackReported[params.stackHash] = true\n    params.stack_trace = truncateSize(stackInfo.stackString)\n  } else {\n    params.browser_stack_hash = stringHashCode(stackInfo.stackString)\n  }\n  params.releaseIds = stringify(loader.releaseIds)\n\n  // When debugging stack canonicalization/hashing, uncomment these lines for\n  // more output in the test logs\n  // params.origStack = err.stack\n  // params.canonicalStack = canonicalStack\n\n  var hash = nameHash(params)\n\n  if (!pageviewReported[hash]) {\n    params.pageview = 1\n    pageviewReported[hash] = true\n  }\n\n  var type = internal ? 'ierr' : 'err'\n  var newMetrics = { time: time }\n\n  // stn and spa aggregators listen to this event - stn sends the error in its payload,\n  // and spa annotates the error with interaction info\n  handle('errorAgg', [type, hash, params, newMetrics])\n\n  if (params._interactionId != null) {\n    // hold on to the error until the interaction finishes\n    errorCache[params._interactionId] = errorCache[params._interactionId] || []\n    errorCache[params._interactionId].push([type, hash, params, newMetrics, att, customAttributes])\n  } else {\n    // store custom attributes\n    var customParams = {}\n    var att = loader.info.jsAttributes\n    mapOwn(att, setCustom)\n    if (customAttributes) {\n      mapOwn(customAttributes, setCustom)\n    }\n\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n    agg.store(type, aggregateHash, params, newMetrics, customParams)\n  }\n\n  function setCustom (key, val) {\n    customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nbaseEE.on('interactionSaved', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    params.browserInteractionId = interaction.root.attrs.id\n    delete params._interactionId\n\n    if (params._interactionNodeId) {\n      params.parentNodeId = params._interactionNodeId.toString()\n      delete params._interactionNodeId\n    }\n\n    var hash = item[1] + interaction.root.attrs.id\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, params, item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n\nbaseEE.on('interactionDiscarded', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    delete params._interactionId\n    delete params._interactionNodeId\n\n    var hash = item[1]\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, item[2], item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nfunction stringHashCode (string) {\n  var hash = 0\n  var charVal\n\n  if (!string || !string.length) return hash\n  for (var i = 0; i < string.length; i++) {\n    charVal = string.charCodeAt(i)\n    hash = ((hash << 5) - hash) + charVal\n    hash = hash | 0 // Convert to 32bit integer\n  }\n  return hash\n}\n\nmodule.exports = stringHashCode\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar loader = require(\"loader\")\nvar mapOwn = require(38)\nvar stringify = require(22)\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar cleanURL = require(5)\nvar config = require(35)\n\nvar eventsPerMinute = 120\nvar harvestTimeSeconds = config.getConfiguration('ins.harvestTimeSeconds') || 30\nvar eventsPerHarvest = eventsPerMinute * harvestTimeSeconds / 60\nvar referrerUrl\nvar currentEvents\n\nvar events = []\nvar att = loader.info.jsAttributes = {}\n\nif (document.referrer) referrerUrl = cleanURL(document.referrer)\n\nregister('api-setCustomAttribute', setCustomAttribute, 'api')\n\nee.on('feat-ins', function () {\n  register('api-addPageAction', addPageAction)\n\n  harvest.on('ins', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'ins', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds, 0)\n})\n\nfunction onHarvestStarted (options) {\n  var payload = ({\n    qs: {\n      ua: loader.info.userAttributes,\n      at: loader.info.atts\n    },\n    body: {\n      ins: events\n    }\n  })\n\n  if (options.retry) {\n    currentEvents = events\n  }\n\n  events = []\n  return payload\n}\n\nfunction onHarvestFinished (result) {\n  if (result && result.sent && result.retry && currentEvents) {\n    events = events.concat(currentEvents)\n    currentEvents = null\n  }\n}\n\n// WARNING: Insights times are in seconds. EXCEPT timestamp, which is in ms.\nfunction addPageAction (t, name, attributes) {\n  if (events.length >= eventsPerHarvest) return\n  var width\n  var height\n  var eventAttributes = {}\n\n  if (typeof window !== 'undefined' && window.document && window.document.documentElement) {\n    // Doesn't include the nav bar when it disappears in mobile safari\n    // https://github.com/jquery/jquery/blob/10399ddcf8a239acc27bdec9231b996b178224d3/src/dimensions.js#L23\n    width = window.document.documentElement.clientWidth\n    height = window.document.documentElement.clientHeight\n  }\n\n  var defaults = {\n    timestamp: t + loader.offset,\n    timeSinceLoad: t / 1000,\n    browserWidth: width,\n    browserHeight: height,\n    referrerUrl: referrerUrl,\n    currentUrl: cleanURL('' + location),\n    pageUrl: cleanURL(loader.origin),\n    eventType: 'PageAction'\n  }\n\n  mapOwn(defaults, set)\n  mapOwn(att, set)\n  if (attributes && typeof attributes === 'object') {\n    mapOwn(attributes, set)\n  }\n  eventAttributes.actionName = name || ''\n\n  events.push(eventAttributes)\n\n  function set (key, val) {\n    eventAttributes[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nfunction setCustomAttribute (t, key, value) {\n  att[key] = value\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar loader = require(\"loader\")\nvar registerHandler = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar mapOwn = require(38)\nvar reduce = require(41)\nvar stringify = require(22)\nvar slice = require(39)\nvar parseUrl = require(34)\nvar config = require(35)\n\nif (!harvest.xhrUsable || !loader.xhrWrappable) return\n\nvar ptid = ''\nvar ignoredEvents = {mouseup: true, mousedown: true}\nvar toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n}\n\nvar rename = {\n  typing: {\n    keydown: true,\n    keyup: true,\n    keypress: true\n  },\n  mousing: {\n    mousemove: true,\n    mouseenter: true,\n    mouseleave: true,\n    mouseover: true,\n    mouseout: true\n  },\n  scrolling: {\n    scroll: true\n  },\n  touching: {\n    touchstart: true,\n    touchmove: true,\n    touchend: true,\n    touchcancel: true,\n    touchenter: true,\n    touchleave: true\n  }\n}\n\nvar trace = {}\nvar nodeCount = 0\nvar sentTrace = null\nvar harvestTimeSeconds = config.getConfiguration('stn.harvestTimeSeconds') || 10\nvar maxNodesPerHarvest = config.getConfiguration('stn.maxNodesPerHarvest') || 1000\n\nvar ee = require(\"ee\")\n\n// exports only used for testing\nmodule.exports = {\n  _takeSTNs: takeSTNs\n}\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.stn) return\n\nee.on('feat-stn', function () {\n  storeTiming(window.performance.timing)\n\n  harvest.on('resources', prepareHarvest)\n\n  var scheduler = new HarvestScheduler(loader, 'resources', { onFinished: onHarvestFinished, retryDelay: harvestTimeSeconds })\n  scheduler.runHarvest({ needResponse: true })\n\n  function onHarvestFinished(result) {\n    // start timer only if ptid was returned by server\n    if (result.sent && result.responseText && !ptid) {\n      ptid = result.responseText\n      scheduler.startTimer(harvestTimeSeconds)\n    }\n\n    if (result.sent && result.retry && sentTrace) {\n      mapOwn(sentTrace, function (name, nodes) {\n        mergeSTNs(name, nodes)\n      })\n      sentTrace = null\n    }\n  }\n\n  function prepareHarvest(options) {\n    if ((loader.now()) > (15 * 60 * 1000)) {\n      // been collecting for over 15 min, empty trace object and bail\n      scheduler.stopTimer()\n      trace = {}\n      return\n    }\n\n    // only send when there are more than 30 nodes to send\n    if (ptid && nodeCount <= 30) return\n\n    return takeSTNs(options.retry)\n  }\n\n  registerHandler('bst', storeEvent)\n  registerHandler('bstTimer', storeTimer)\n  registerHandler('bstResource', storeResources)\n  registerHandler('bstHist', storeHist)\n  registerHandler('bstXhrAgg', storeXhrAgg)\n  registerHandler('bstApi', storeSTN)\n  registerHandler('errorAgg', storeErrorAgg)\n})\n\nfunction storeTiming (_t) {\n  var key\n  var val\n  var timeOffset\n  var now = Date.now()\n\n  // loop iterates through prototype also (for FF)\n  for (key in _t) {\n    val = _t[key]\n\n    // ignore inherited methods, meaningless 0 values, and bogus timestamps\n    // that are in the future (Microsoft Edge seems to sometimes produce these)\n    if (!(typeof (val) === 'number' && val > 0 && val < now)) continue\n\n    timeOffset = _t[key] - loader.offset\n\n    storeSTN({\n      n: key,\n      s: timeOffset,\n      e: timeOffset,\n      o: 'document',\n      t: 'timing'\n    })\n  }\n}\n\nfunction storeTimer (target, start, end, type) {\n  var category = 'timer'\n  if (type === 'requestAnimationFrame') category = type\n\n  var evt = {\n    n: type,\n    s: start,\n    e: end,\n    o: 'window',\n    t: category\n  }\n\n  storeSTN(evt)\n}\n\nfunction storeEvent (currentEvent, target, start, end) {\n  // we find that certain events make the data too noisy to be useful\n  if (currentEvent.type in ignoredEvents) { return false }\n\n  var evt = {\n    n: evtName(currentEvent.type),\n    s: start,\n    e: end,\n    t: 'event'\n  }\n\n  try {\n    // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n    // it does not check currentEvent.currentTarget before calling getRootNode() on it\n    evt.o = evtOrigin(currentEvent.target, target)\n  } catch (e) {\n    evt.o = evtOrigin(null, target)\n  }\n\n  storeSTN(evt)\n}\n\nfunction evtName (type) {\n  var name = type\n\n  mapOwn(rename, function (key, val) {\n    if (type in val) name = key\n  })\n\n  return name\n}\n\nfunction evtOrigin (t, target) {\n  var origin = 'unknown'\n\n  if (t && t instanceof XMLHttpRequest) {\n    var params = ee.context(t).params\n    origin = params.status + ' ' + params.method + ': ' + params.host + params.pathname\n  } else if (t && typeof (t.tagName) === 'string') {\n    origin = t.tagName.toLowerCase()\n    if (t.id) origin += '#' + t.id\n    if (t.className) origin += '.' + slice(t.classList).join('.')\n  }\n\n  if (origin === 'unknown') {\n    if (target === document) origin = 'document'\n    else if (target === window) origin = 'window'\n    else if (target instanceof FileReader) origin = 'FileReader'\n  }\n\n  return origin\n}\n\nfunction storeHist (path, old, time) {\n  var node = {\n    n: 'history.pushState',\n    s: time,\n    e: time,\n    o: path,\n    t: old\n  }\n\n  storeSTN(node)\n}\n\nvar laststart = 0\n\nfunction storeResources (resources) {\n  resources.forEach(function (currentResource) {\n    var parsed = parseUrl(currentResource.name)\n    var res = {\n      n: currentResource.initiatorType,\n      s: currentResource.fetchStart | 0,\n      e: currentResource.responseEnd | 0,\n      o: parsed.protocol + '://' + parsed.hostname + ':' + parsed.port + parsed.pathname, // resource.name is actually a URL so it's the source\n      t: currentResource.entryType\n    }\n\n    // don't recollect old resources\n    if (res.s < laststart) return\n\n    laststart = res.s\n\n    storeSTN(res)\n  })\n}\n\nfunction storeErrorAgg (type, name, params, metrics) {\n  if (type !== 'err') return\n  var node = {\n    n: 'error',\n    s: metrics.time,\n    e: metrics.time,\n    o: params.message,\n    t: params.stackHash\n  }\n  storeSTN(node)\n}\n\nfunction storeXhrAgg (type, name, params, metrics) {\n  if (type !== 'xhr') return\n  var node = {\n    n: 'Ajax',\n    s: metrics.time,\n    e: metrics.time + metrics.duration,\n    o: params.status + ' ' + params.method + ': ' + params.host + params.pathname,\n    t: 'ajax'\n  }\n  storeSTN(node)\n}\n\nfunction storeSTN (stn) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[stn.n]\n  if (!traceArr) traceArr = trace[stn.n] = []\n\n  traceArr.push(stn)\n  nodeCount++\n}\n\nfunction mergeSTNs(key, nodes) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[key]\n  if (!traceArr) traceArr = trace[key] = []\n\n  trace[key] = nodes.concat(traceArr)\n  nodeCount += nodes.length\n}\n\nfunction takeSTNs (retry) {\n  storeResources(window.performance.getEntriesByType('resource'))\n  var stns = reduce(mapOwn(trace, function (name, nodes) {\n    if (!(name in toAggregate)) return nodes\n\n    return reduce(mapOwn(reduce(nodes.sort(byStart), smearEvtsByOrigin(name), {}), val), flatten, [])\n  }), flatten, [])\n\n  if (stns.length === 0) return {}\n\n  if (retry) {\n    sentTrace = trace\n  }\n  trace = {}\n  nodeCount = 0\n\n  var stnInfo = {\n    qs: {st: '' + loader.offset, ptid: ptid},\n    body: {res: stns}\n  }\n\n  if (!ptid) {\n    stnInfo.qs.ua = loader.info.userAttributes\n    stnInfo.qs.at = loader.info.atts\n    var ja = stringify(loader.info.jsAttributes)\n    stnInfo.qs.ja = ja === '{}' ? null : ja\n  }\n  return stnInfo\n}\n\nfunction byStart (a, b) {\n  return a.s - b.s\n}\n\nfunction smearEvtsByOrigin (name) {\n  var maxGap = toAggregate[name][0]\n  var maxLen = toAggregate[name][1]\n  var lastO = {}\n\n  return function (byOrigin, evt) {\n    var lastArr = byOrigin[evt.o]\n\n    lastArr || (lastArr = byOrigin[evt.o] = [])\n\n    var last = lastO[evt.o]\n\n    if (name === 'scrolling' && !trivial(evt)) {\n      lastO[evt.o] = null\n      evt.n = 'scroll'\n      lastArr.push(evt)\n    } else if (last && (evt.s - last.s) < maxLen && last.e > (evt.s - maxGap)) {\n      last.e = evt.e\n    } else {\n      lastO[evt.o] = evt\n      lastArr.push(evt)\n    }\n\n    return byOrigin\n  }\n}\n\nfunction val (key, value) {\n  return value\n}\n\nfunction flatten (a, b) {\n  return a.concat(b)\n}\n\nfunction trivial (node) {\n  var limit = 4\n  if (node && typeof node.e === 'number' && typeof node.s === 'number' && (node.e - node.s) < limit) return true\n  else return false\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar register = require(17)\nvar harvest = require(10)\nvar stringify = require(22)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar handle = require(\"handle\")\n\n// bail if not instrumented\nif (!loader.features.xhr) return\n\nharvest.on('jserrors', function () {\n  return { body: agg.take([ 'xhr' ]) }\n})\n\nee.on('feat-err', function () { register('xhr', storeXhr) })\n\nmodule.exports = storeXhr\n\nfunction storeXhr (params, metrics, start) {\n  metrics.time = start\n\n  var type = 'xhr'\n  var hash\n  if (params.cat) {\n    hash = stringify([params.status, params.cat])\n  } else {\n    hash = stringify([params.status, params.host, params.pathname])\n  }\n\n  handle('bstXhrAgg', [type, hash, params, metrics])\n  agg.store(type, hash, params, metrics)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stringsToParsedUrls = {}\n\nmodule.exports = function parseUrl (url) {\n  if (url in stringsToParsedUrls) {\n    return stringsToParsedUrls[url]\n  }\n\n  var urlEl = document.createElement('a')\n  var location = window.location\n  var ret = {}\n\n  // Use an anchor dom element to resolve the url natively.\n  urlEl.href = url\n\n  ret.port = urlEl.port\n\n  var firstSplit = urlEl.href.split('://')\n\n  if (!ret.port && firstSplit[1]) {\n    ret.port = firstSplit[1].split('/')[0].split('@').pop().split(':')[1]\n  }\n  if (!ret.port || ret.port === '0') ret.port = (firstSplit[0] === 'https' ? '443' : '80')\n\n  // Host not provided in IE for relative urls\n  ret.hostname = (urlEl.hostname || location.hostname)\n\n  ret.pathname = urlEl.pathname\n\n  ret.protocol = firstSplit[0]\n\n  // Pathname sometimes doesn't have leading slash (IE 8 and 9)\n  if (ret.pathname.charAt(0) !== '/') ret.pathname = '/' + ret.pathname\n\n  // urlEl.protocol is ':' in old ie when protocol is not specified\n  var sameProtocol = !urlEl.protocol || urlEl.protocol === ':' || urlEl.protocol === location.protocol\n  var sameDomain = urlEl.hostname === document.domain && urlEl.port === location.port\n\n  // urlEl.hostname is not provided by IE for relative urls, but relative urls are also same-origin\n  ret.sameOrigin = sameProtocol && (!urlEl.hostname || sameDomain)\n\n  // Only cache if url doesn't have a path\n  if (ret.pathname === '/') {\n    stringsToParsedUrls[url] = ret\n  }\n\n  return ret\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getConfiguration: getConfiguration\n}\n\nfunction getConfiguration(path) {\n  if (!NREUM.init) return\n  var val = NREUM.init\n  var parts = path.split('.')\n  for (var i = 0; i < parts.length - 1; i++) {\n    val = val[parts[i]]\n    if (typeof val !== 'object') return\n  }\n  val = val[parts[parts.length - 1]]\n  return val\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = 0\nvar match = navigator.userAgent.match(/Firefox[\\/\\s](\\d+\\.\\d+)/)\nif (match) ffVersion = +match[1]\n\nmodule.exports = ffVersion\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar lastTimestamp = new Date().getTime()\nvar offset = lastTimestamp\n\nvar performanceCheck = require(40)\n\nmodule.exports = now\nmodule.exports.offset = offset\nmodule.exports.getLastTimestamp = getLastTimestamp\n\nfunction now () {\n  if (performanceCheck.exists && performance.now) {\n    return Math.round(performance.now())\n  }\n  // ensure a new timestamp is never smaller than a previous timestamp\n  return (lastTimestamp = Math.max(new Date().getTime(), lastTimestamp)) - offset\n}\n\nfunction getLastTimestamp() {\n  return lastTimestamp\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = mapOwn\n\nfunction mapOwn (obj, fn) {\n  var results = []\n  var key = ''\n  var i = 0\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      results[i] = fn(key, obj[key])\n      i += 1\n    }\n  }\n\n  return results\n}\n","/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  exists: typeof (window.performance) !== 'undefined' && window.performance.timing && typeof (window.performance.timing.navigationStart) !== 'undefined'\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = reduce\n\nfunction reduce (arr, fn, next) {\n  var i = 0\n  if (typeof next === 'undefined') {\n    next = arr[0]\n    i = 1\n  }\n\n  for (i; i < arr.length; i++) {\n    next = fn(next, arr[i])\n  }\n\n  return next\n}\n"],"sourceRoot":"/source/"}