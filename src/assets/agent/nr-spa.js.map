{"version":3,"sources":["node_modules/browser-pack/_prelude.js","agent/add-e.js","agent/aggregator.js","agent/api.js","agent/bel-serializer.js","agent/clean-url.js","agent/drain.js","agent/encode.js","agent/feature-flags.js","agent/harvest-scheduler.js","agent/harvest.js","agent/ie-version.js","agent/index.js","agent/location.js","agent/nav-cookie.js","agent/nav-timing.js","agent/paint-metrics.js","agent/register-handler.js","agent/s-hash.js","agent/single.js","agent/start-time.js","agent/stopwatch.js","agent/stringify.js","agent/submit-data.js","agent/timings.js","agent/unload.js","feature/err/aggregate/canonical-function-name.js","feature/err/aggregate/compute-stack-trace.js","feature/err/aggregate/format-stack-trace.js","feature/err/aggregate/index.js","feature/err/aggregate/string-hash-code.js","feature/ins/aggregate/index.js","feature/spa/aggregate/Interaction.js","feature/spa/aggregate/InteractionNode.js","feature/spa/aggregate/index.js","feature/spa/aggregate/serializer.js","feature/stn/aggregate/index.js","feature/xhr/aggregate/index.js","feature/xhr/instrument/parse-url.js","loader/config.js","loader/data-size.js","loader/firefox-version.js","loader/now.js","loader/unique-id.js","map-own/index.js","node_modules/lodash._slice/index.js","performance-check/index.js","reduce/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"nr-spa.js","sourceRoot":"/source/","sourcesContent":["// prelude.js edited from: https://github.com/substack/browser-pack/blob/master/prelude.js\n\n// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requireuires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, cache, entry) { // eslint-disable-line no-extra-parens\n  // Save the require from previous bundle to this closure if any\n  var previousRequire = typeof __nr_require === 'function' && __nr_require\n\n  function newRequire (name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire = typeof __nr_require === 'function' && __nr_require\n        if (!jumped && currentRequire) return currentRequire(name, true)\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) return previousRequire(name, true)\n        throw new Error(\"Cannot find module '\" + name + \"'\")\n      }\n      var m = cache[name] = {exports: {}}\n      modules[name][0].call(m.exports, function (x) {\n        var id = modules[name][1][x]\n        return newRequire(id || x)\n      }, m, m.exports)\n    }\n    return cache[name].exports\n  }\n  for (var i = 0; i < entry.length; i++) newRequire(entry[i])\n\n  // Override the current require with this new one\n  return newRequire\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Safely add an event listener to window in any browser\nmodule.exports = function (sType, callback) {\n  if ('addEventListener' in window) {\n    return window.addEventListener(sType, callback, false)\n  } else if ('attachEvent' in window) {\n    return window.attachEvent('on' + sType, callback)\n  }\n}\n","//                                  Apache License\n//                            Version 2.0, January 2004\n//                         http://www.apache.org/licenses/\n// \n//    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n// \n//    1. Definitions.\n// \n//       \"License\" shall mean the terms and conditions for use, reproduction,\n//       and distribution as defined by Sections 1 through 9 of this document.\n// \n//       \"Licensor\" shall mean the copyright owner or entity authorized by\n//       the copyright owner that is granting the License.\n// \n//       \"Legal Entity\" shall mean the union of the acting entity and all\n//       other entities that control, are controlled by, or are under common\n//       control with that entity. For the purposes of this definition,\n//       \"control\" means (i) the power, direct or indirect, to cause the\n//       direction or management of such entity, whether by contract or\n//       otherwise, or (ii) ownership of fifty percent (50%) or more of the\n//       outstanding shares, or (iii) beneficial ownership of such entity.\n// \n//       \"You\" (or \"Your\") shall mean an individual or Legal Entity\n//       exercising permissions granted by this License.\n// \n//       \"Source\" form shall mean the preferred form for making modifications,\n//       including but not limited to software source code, documentation\n//       source, and configuration files.\n// \n//       \"Object\" form shall mean any form resulting from mechanical\n//       transformation or translation of a Source form, including but\n//       not limited to compiled object code, generated documentation,\n//       and conversions to other media types.\n// \n//       \"Work\" shall mean the work of authorship, whether in Source or\n//       Object form, made available under the License, as indicated by a\n//       copyright notice that is included in or attached to the work\n//       (an example is provided in the Appendix below).\n// \n//       \"Derivative Works\" shall mean any work, whether in Source or Object\n//       form, that is based on (or derived from) the Work and for which the\n//       editorial revisions, annotations, elaborations, or other modifications\n//       represent, as a whole, an original work of authorship. For the purposes\n//       of this License, Derivative Works shall not include works that remain\n//       separable from, or merely link (or bind by name) to the interfaces of,\n//       the Work and Derivative Works thereof.\n// \n//       \"Contribution\" shall mean any work of authorship, including\n//       the original version of the Work and any modifications or additions\n//       to that Work or Derivative Works thereof, that is intentionally\n//       submitted to Licensor for inclusion in the Work by the copyright owner\n//       or by an individual or Legal Entity authorized to submit on behalf of\n//       the copyright owner. For the purposes of this definition, \"submitted\"\n//       means any form of electronic, verbal, or written communication sent\n//       to the Licensor or its representatives, including but not limited to\n//       communication on electronic mailing lists, source code control systems,\n//       and issue tracking systems that are managed by, or on behalf of, the\n//       Licensor for the purpose of discussing and improving the Work, but\n//       excluding communication that is conspicuously marked or otherwise\n//       designated in writing by the copyright owner as \"Not a Contribution.\"\n// \n//       \"Contributor\" shall mean Licensor and any individual or Legal Entity\n//       on behalf of whom a Contribution has been received by Licensor and\n//       subsequently incorporated within the Work.\n// \n//    2. Grant of Copyright License. Subject to the terms and conditions of\n//       this License, each Contributor hereby grants to You a perpetual,\n//       worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n//       copyright license to reproduce, prepare Derivative Works of,\n//       publicly display, publicly perform, sublicense, and distribute the\n//       Work and such Derivative Works in Source or Object form.\n// \n//    3. Grant of Patent License. Subject to the terms and conditions of\n//       this License, each Contributor hereby grants to You a perpetual,\n//       worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n//       (except as stated in this section) patent license to make, have made,\n//       use, offer to sell, sell, import, and otherwise transfer the Work,\n//       where such license applies only to those patent claims licensable\n//       by such Contributor that are necessarily infringed by their\n//       Contribution(s) alone or by combination of their Contribution(s)\n//       with the Work to which such Contribution(s) was submitted. If You\n//       institute patent litigation against any entity (including a\n//       cross-claim or counterclaim in a lawsuit) alleging that the Work\n//       or a Contribution incorporated within the Work constitutes direct\n//       or contributory patent infringement, then any patent licenses\n//       granted to You under this License for that Work shall terminate\n//       as of the date such litigation is filed.\n// \n//    4. Redistribution. You may reproduce and distribute copies of the\n//       Work or Derivative Works thereof in any medium, with or without\n//       modifications, and in Source or Object form, provided that You\n//       meet the following conditions:\n// \n//       (a) You must give any other recipients of the Work or\n//           Derivative Works a copy of this License; and\n// \n//       (b) You must cause any modified files to carry prominent notices\n//           stating that You changed the files; and\n// \n//       (c) You must retain, in the Source form of any Derivative Works\n//           that You distribute, all copyright, patent, trademark, and\n//           attribution notices from the Source form of the Work,\n//           excluding those notices that do not pertain to any part of\n//           the Derivative Works; and\n// \n//       (d) If the Work includes a \"NOTICE\" text file as part of its\n//           distribution, then any Derivative Works that You distribute must\n//           include a readable copy of the attribution notices contained\n//           within such NOTICE file, excluding those notices that do not\n//           pertain to any part of the Derivative Works, in at least one\n//           of the following places: within a NOTICE text file distributed\n//           as part of the Derivative Works; within the Source form or\n//           documentation, if provided along with the Derivative Works; or,\n//           within a display generated by the Derivative Works, if and\n//           wherever such third-party notices normally appear. The contents\n//           of the NOTICE file are for informational purposes only and\n//           do not modify the License. You may add Your own attribution\n//           notices within Derivative Works that You distribute, alongside\n//           or as an addendum to the NOTICE text from the Work, provided\n//           that such additional attribution notices cannot be construed\n//           as modifying the License.\n// \n//       You may add Your own copyright statement to Your modifications and\n//       may provide additional or different license terms and conditions\n//       for use, reproduction, or distribution of Your modifications, or\n//       for any such Derivative Works as a whole, provided Your use,\n//       reproduction, and distribution of the Work otherwise complies with\n//       the conditions stated in this License.\n// \n//    5. Submission of Contributions. Unless You explicitly state otherwise,\n//       any Contribution intentionally submitted for inclusion in the Work\n//       by You to the Licensor shall be under the terms and conditions of\n//       this License, without any additional terms or conditions.\n//       Notwithstanding the above, nothing herein shall supersede or modify\n//       the terms of any separate license agreement you may have executed\n//       with Licensor regarding such Contributions.\n// \n//    6. Trademarks. This License does not grant permission to use the trade\n//       names, trademarks, service marks, or product names of the Licensor,\n//       except as required for reasonable and customary use in describing the\n//       origin of the Work and reproducing the content of the NOTICE file.\n// \n//    7. Disclaimer of Warranty. Unless required by applicable law or\n//       agreed to in writing, Licensor provides the Work (and each\n//       Contributor provides its Contributions) on an \"AS IS\" BASIS,\n//       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n//       implied, including, without limitation, any warranties or conditions\n//       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n//       PARTICULAR PURPOSE. You are solely responsible for determining the\n//       appropriateness of using or redistributing the Work and assume any\n//       risks associated with Your exercise of permissions under this License.\n// \n//    8. Limitation of Liability. In no event and under no legal theory,\n//       whether in tort (including negligence), contract, or otherwise,\n//       unless required by applicable law (such as deliberate and grossly\n//       negligent acts) or agreed to in writing, shall any Contributor be\n//       liable to You for damages, including any direct, indirect, special,\n//       incidental, or consequential damages of any character arising as a\n//       result of this License or out of the use or inability to use the\n//       Work (including but not limited to damages for loss of goodwill,\n//       work stoppage, computer failure or malfunction, or any and all\n//       other commercial damages or losses), even if such Contributor\n//       has been advised of the possibility of such damages.\n// \n//    9. Accepting Warranty or Additional Liability. While redistributing\n//       the Work or Derivative Works thereof, You may choose to offer,\n//       and charge a fee for, acceptance of support, warranty, indemnity,\n//       or other liability obligations and/or rights consistent with this\n//       License. However, in accepting such obligations, You may act only\n//       on Your own behalf and on Your sole responsibility, not on behalf\n//       of any other Contributor, and only if You agree to indemnify,\n//       defend, and hold each Contributor harmless for any liability\n//       incurred by, or claims asserted against, such Contributor by reason\n//       of your accepting any such warranty or additional liability.\n// \n//    END OF TERMS AND CONDITIONS\n// \n//    APPENDIX: How to apply the Apache License to your work.\n// \n//       To apply the Apache License to your work, attach the following\n//       boilerplate notice, with the fields enclosed by brackets \"[]\"\n//       replaced with your own identifying information. (Don't include\n//       the brackets!)  The text should be enclosed in the appropriate\n//       comment syntax for the file format. We also recommend that a\n//       file or class name and description of purpose be included on the\n//       same \"printed page\" as the copyright notice for easier\n//       identification within third-party archives.\n// \n//    Copyright [yyyy] [name of copyright owner]\n// \n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n// \n//        http://www.apache.org/licenses/LICENSE-2.0\n// \n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n\n/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\n\nvar aggregatedData = {}\n\nmodule.exports = {\n  store: store,\n  take: take,\n  get: get,\n  merge: mergeMetrics\n}\n\n// Items with the same type and name get aggregated together\n// params are example data from the aggregated items\n// metrics are the numeric values to be aggregated\nfunction store (type, name, params, newMetrics, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  bucket.metrics = aggregateMetrics(newMetrics, bucket.metrics)\n  return bucket\n}\n\nfunction aggregateMetrics (newMetrics, oldMetrics) {\n  if (!oldMetrics) oldMetrics = {count: 0}\n  oldMetrics.count += 1\n  mapOwn(newMetrics, function (key, value) {\n    oldMetrics[key] = updateMetric(value, oldMetrics[key])\n  })\n  return oldMetrics\n}\n\nfunction updateMetric (value, metric) {\n  // When there is only one data point, the c (count), min, max, and sos (sum of squares) params are superfluous.\n  if (!metric) return {t: value}\n\n  // but on the second data point, we need to calculate the other values before aggregating in new values\n  if (!metric.c) {\n    metric = createMetricObject(metric.t)\n  }\n\n  // at this point, metric is always uncondensed\n  metric.c += 1\n  metric.t += value\n  metric.sos += value * value\n  if (value > metric.max) metric.max = value\n  if (value < metric.min) metric.min = value\n\n  return metric\n}\n\n/**\n * Merge metrics object into existing metrics.\n *\n * @param {string} type\n * @param {string} name\n * @param {object} metrics - Metrics to merge.\n */\nfunction mergeMetrics (type, name, metrics, params, customParams) {\n  var bucket = getBucket(type, name, params, customParams)\n\n  if (!bucket.metrics) {\n    bucket.metrics = metrics\n    return\n  }\n\n  var oldMetrics = bucket.metrics\n  oldMetrics.count += metrics.count\n\n  // iterate through each new metric and merge\n  mapOwn(metrics, function (key, value) {\n    // count is a special case handled above\n    if (key === 'count') return\n\n    var oldMetric = oldMetrics[key]\n    var newMetric = metrics[key]\n\n    // handling the case where newMetric is a single-value first\n    if (newMetric && !newMetric.c) {\n      oldMetrics[key] = updateMetric(newMetric.t, oldMetric)\n    } else { // newMetric is a metric object\n      oldMetrics[key] = mergeMetric(newMetric, oldMetrics[key])\n    }\n  })\n}\n\nfunction mergeMetric(newMetric, oldMetric) {\n  if (!oldMetric) return newMetric\n\n  if (!oldMetric.c) {\n    // oldMetric is a single-value\n    oldMetric = createMetricObject(oldMetric.t)\n  }\n\n  oldMetric.min = Math.min(newMetric.min, oldMetric.min)\n  oldMetric.max = Math.max(newMetric.max, oldMetric.max)\n  oldMetric.t += newMetric.t\n  oldMetric.sos += newMetric.sos\n  oldMetric.c += newMetric.c\n\n  return oldMetric\n}\n\n// take a value and create a metric object\nfunction createMetricObject (value) {\n  return {\n    t: value,\n    min: value,\n    max: value,\n    sos: value * value,\n    c: 1\n  }\n}\n\nfunction getBucket (type, name, params, customParams) {\n  if (!aggregatedData[type]) aggregatedData[type] = {}\n  var bucket = aggregatedData[type][name]\n  if (!bucket) {\n    bucket = aggregatedData[type][name] = { params: params || {} }\n    if (customParams) {\n      bucket.custom = customParams\n    }\n  }\n  return bucket\n}\n\nfunction get (type, name) {\n  // if name is passed, get a single bucket\n  if (name) return aggregatedData[type] && aggregatedData[type][name]\n  // else, get all buckets of that type\n  return aggregatedData[type]\n}\n\n// Like get, but for many types and it deletes the retrieved content from the aggregatedData\nfunction take (types) {\n  var results = {}\n  var type = ''\n  var hasData = false\n  for (var i = 0; i < types.length; i++) {\n    type = types[i]\n    results[type] = toArray(aggregatedData[type])\n    if (results[type].length) hasData = true\n    delete aggregatedData[type]\n  }\n  return hasData ? results : null\n}\n\nfunction toArray (obj) {\n  if (typeof obj !== 'object') return []\n\n  return mapOwn(obj, getValue)\n}\n\nfunction getValue (key, value) {\n  return value\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar register = require(17)\nvar harvest = require(10)\nvar agg = require(2)\nvar single = require(19)\nvar submitData = require(23)\nvar mapOwn = require(44)\nvar loader = require(\"loader\")\nvar handle = require(\"handle\")\nvar config = require(39)\nvar cycle = 0\n\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\nharvest.on('jserrors', function () {\n  return { qs: agg.take([ 'cm' ]) }\n})\n\nvar api = {\n  finished: single(finished),\n  setPageViewName: setPageViewName,\n  setErrorHandler: setErrorHandler,\n  addToTrace: addToTrace,\n  inlineHit: inlineHit,\n  addRelease: addRelease\n}\n\n// Hook all of the api functions up to the queues/stubs created in loader/api.js\nmapOwn(api, function (fnName, fn) {\n  register('api-' + fnName, fn, 'api')\n})\n\n// All API functions get passed the time they were called as their\n// first parameter. These functions can be called asynchronously.\n\nfunction setPageViewName (t, name, host) {\n  if (typeof name !== 'string') return\n  if (name.charAt(0) !== '/') name = '/' + name\n  loader.customTransaction = (host || 'http://custom.transaction') + name\n}\n\nfunction finished (t, providedTime) {\n  var time = providedTime ? providedTime - loader.offset : t\n  agg.store('cm', 'finished', { name: 'finished' }, { time: time })\n  addToTrace(t, { name: 'finished', start: time + loader.offset, origin: 'nr' })\n  handle('api-addPageAction', [ time, 'finished' ])\n}\n\nfunction addToTrace (t, evt) {\n  if (!(evt && typeof evt === 'object' && evt.name && evt.start)) return\n\n  var report = {\n    n: evt.name,\n    s: evt.start - loader.offset,\n    e: (evt.end || evt.start) - loader.offset,\n    o: evt.origin || '',\n    t: 'api'\n  }\n\n  handle('bstApi', [report])\n}\n\n// NREUM.inlineHit(request_name, queue_time, app_time, total_be_time, dom_time, fe_time)\n//\n// request_name - the 'web page' name or service name\n// queue_time - the amount of time spent in the app tier queue\n// app_time - the amount of time spent in the application code\n// total_be_time - the total roundtrip time of the remote service call\n// dom_time - the time spent processing the result of the service call (or user defined)\n// fe_time - the time spent rendering the result of the service call (or user defined)\nfunction inlineHit (t, request_name, queue_time, app_time, total_be_time, dom_time, fe_time) {\n  request_name = window.encodeURIComponent(request_name)\n  cycle += 1\n\n  if (!loader.info.beacon) return\n\n  var url = scheme + '://' + loader.info.beacon + '/1/' + loader.info.licenseKey\n\n  url += '?a=' + loader.info.applicationID + '&'\n  url += 't=' + request_name + '&'\n  url += 'qt=' + ~~queue_time + '&'\n  url += 'ap=' + ~~app_time + '&'\n  url += 'be=' + ~~total_be_time + '&'\n  url += 'dc=' + ~~dom_time + '&'\n  url += 'fe=' + ~~fe_time + '&'\n  url += 'c=' + cycle\n\n  submitData.img(url)\n}\n\nfunction setErrorHandler (t, handler) {\n  loader.onerror = handler\n}\n\nvar releaseCount = 0\nfunction addRelease (t, name, id) {\n  if (++releaseCount > 10) return\n  loader.releaseIds[name.slice(-200)] = ('' + id).slice(-200)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar stringify = require(22)\n\nvar hasOwnProp = Object.prototype.hasOwnProperty\nvar MAX_ATTRIBUTES = 64\n\nmodule.exports = {\n  nullable: nullable,\n  numeric: numeric,\n  getAddStringContext: getAddStringContext,\n  addCustomAttributes: addCustomAttributes\n}\n\nfunction nullable (val, fn, comma) {\n  return val || val === 0 || val === ''\n    ? fn(val) + (comma ? ',' : '')\n    : '!'\n}\n\nfunction numeric (n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36)\n  }\n  return (n === undefined || n === 0) ? '' : Math.floor(n).toString(36)\n}\n\nfunction getAddStringContext () {\n  var stringTable = Object.hasOwnProperty('create') ? Object.create(null) : {}\n  var stringTableIdx = 0\n\n  return addString\n\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return ''\n    str = String(str)\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true)\n    } else {\n      stringTable[str] = stringTableIdx++\n      return quoteString(str)\n    }\n  }\n}\n\nfunction addCustomAttributes (attrs, addString) {\n  var attrParts = []\n\n  mapOwn(attrs, function (key, val) {\n    if (attrParts.length >= MAX_ATTRIBUTES) return\n    var type = 5\n    var serializedValue\n    // add key to string table first\n    key = addString(key)\n\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val))\n        } else {\n          // null attribute type\n          type = 9\n        }\n        break\n      case 'number':\n        type = 6\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.'\n        break\n      case 'boolean':\n        type = val ? 7 : 8\n        break\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9\n        break\n      default:\n        serializedValue = addString(val)\n    }\n\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')])\n  })\n\n  return attrParts\n}\n\nvar escapable = /([,\\\\;])/g\n\nfunction quoteString (str) {\n  return \"'\" + str.replace(escapable, '\\\\$1')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar withHash = /([^?#]*)[^#]*(#[^?]*|$).*/\nvar withoutHash = /([^?#]*)().*/\nmodule.exports = function cleanURL (url, keepHash) {\n  return url.replace(keepHash ? withHash : withoutHash, '$1$2')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar baseEE = require(\"ee\")\nvar mapOwn = require(44)\nvar handlers = require(17).handlers\n\nmodule.exports = function drain (group) {\n  var bufferedEventsInGroup = baseEE.backlog[group]\n  var groupHandlers = handlers[group]\n  if (groupHandlers) {\n    // don't cache length, buffer can grow while processing\n    for (var i = 0; bufferedEventsInGroup && i < bufferedEventsInGroup.length; ++i) { // eslint-disable-line no-unmodified-loop-condition\n      emitEvent(bufferedEventsInGroup[i], groupHandlers)\n    }\n\n    mapOwn(groupHandlers, function (eventType, handlerRegistrationList) {\n      mapOwn(handlerRegistrationList, function (i, registration) {\n        // registration is an array of: [targetEE, eventHandler]\n        registration[0].on(eventType, registration[1])\n      })\n    })\n  }\n\n  delete handlers[group]\n  // Keep the group as a property so we know it was created and drained\n  baseEE.backlog[group] = null\n}\n\nfunction emitEvent (evt, groupHandlers) {\n  var type = evt[1]\n  mapOwn(groupHandlers[type], function (i, registration) {\n    var sourceEE = evt[0]\n    var ee = registration[0]\n    if (ee === sourceEE) {\n      var handler = registration[1]\n      var ctx = evt[3]\n      var args = evt[2]\n      handler.apply(ctx, args)\n    }\n  })\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar stringify = require(22)\n\n  // Characters that are safe in a qs, but get encoded.\nvar charMap = {\n  '%2C': ',',\n  '%3A': ':',\n  '%2F': '/',\n  '%40': '@',\n  '%24': '$',\n  '%3B': ';'\n}\n\nvar charList = mapOwn(charMap, function (k) { return k })\nvar safeEncoded = new RegExp(charList.join('|'), 'g')\n\nfunction real (c) {\n  return charMap[c]\n}\n\n// Encode as URI Component, then unescape anything that is ok in the\n// query string position.\nfunction qs (value) {\n  if (value === null || value === undefined) return 'null'\n  return encodeURIComponent(value).replace(safeEncoded, real)\n}\n\nmodule.exports = {obj: obj, fromArray: fromArray, qs: qs, param: param}\n\nfunction fromArray (qs, maxBytes) {\n  var bytes = 0\n  for (var i = 0; i < qs.length; i++) {\n    bytes += qs[i].length\n    if (bytes > maxBytes) return qs.slice(0, i).join('')\n  }\n  return qs.join('')\n}\n\nfunction obj (payload, maxBytes) {\n  var total = 0\n  var result = ''\n\n  mapOwn(payload, function (feature, dataArray) {\n    var intermediate = []\n    var next\n    var i\n\n    if (typeof dataArray === 'string') {\n      next = '&' + feature + '=' + qs(dataArray)\n      total += next.length\n      result += next\n    } else if (dataArray.length) {\n      total += 9\n      for (i = 0; i < dataArray.length; i++) {\n        next = qs(stringify(dataArray[i]))\n        total += next.length\n        if (typeof maxBytes !== 'undefined' && total >= maxBytes) break\n        intermediate.push(next)\n      }\n      result += '&' + feature + '=%5B' + intermediate.join(',') + '%5D'\n    }\n  })\n  return result\n}\n\n// Constructs an HTTP parameter to add to the BAM router URL\nfunction param (name, value) {\n  if (value && typeof (value) === 'string') {\n    return '&' + name + '=' + qs(value)\n  }\n  return ''\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar ee = require(\"ee\")\nvar drain = require(6)\n\nmodule.exports = function activateFeatures (flags) {\n  if (!(flags && typeof flags === 'object')) return\n  mapOwn(flags, function (flag, val) {\n    if (!val || activatedFeatures[flag]) return\n    ee.emit('feat-' + flag, [])\n    activatedFeatures[flag] = true\n  })\n\n  drain('feature')\n}\n\nvar activatedFeatures = module.exports.active = {}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar harvest = require(10)\nvar submitData = require(23)\n\nmodule.exports = HarvestScheduler\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nfunction HarvestScheduler(loader, endpoint, opts) {\n  this.loader = loader\n  this.endpoint = endpoint\n  this.opts = opts || {}\n  this.started = false\n  this.timeoutHandle = null\n}\n\nHarvestScheduler.prototype.startTimer = function startTimer(interval, initialDelay) {\n  this.interval = interval\n  this.started = true\n  this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval)\n}\n\nHarvestScheduler.prototype.stopTimer = function stopTimer() {\n  this.started = false\n  if (this.timeoutHandle) {\n    clearTimeout(this.timeoutHandle)\n  }\n}\n\nHarvestScheduler.prototype.scheduleHarvest = function scheduleHarvest(delay, opts) {\n  if (this.timeoutHandle) return\n  var timer = this\n\n  if (delay == null) {\n    delay = this.interval\n  }\n  this.timeoutHandle = setTimeout(function() {\n    timer.timeoutHandle = null\n    timer.runHarvest(opts)\n  }, delay * 1000)\n}\n\nHarvestScheduler.prototype.runHarvest = function runHarvest(opts) {\n  var scheduler = this\n\n  if (this.opts.getPayload) {\n    var submitMethod = harvest.getSubmitMethod(this.endpoint)\n    if (!submitMethod) return false\n\n    var retry = submitMethod.method === submitData.xhr\n    var payload = this.opts.getPayload({ retry: retry })\n    if (payload) {\n      harvest.send(this.endpoint, this.loader, payload, opts, submitMethod, onHarvestFinished)\n    }\n  } else {\n    harvest.sendX(this.endpoint, this.loader, opts, onHarvestFinished)\n  }\n\n  if (this.started) {\n    this.scheduleHarvest()\n  }\n\n  function onHarvestFinished(result) {\n    scheduler.onHarvestFinished(opts, result)\n  }\n}\n\nHarvestScheduler.prototype.onHarvestFinished = function onHarvestFinished(opts, result) {\n  if (this.opts.onFinished) {\n    this.opts.onFinished(result)\n  }\n\n  if (result.sent && result.retry) {\n    var delay = result.delay || this.opts.retryDelay\n    // reschedule next harvest if should be delayed longer\n    if (this.started && delay) {\n      clearTimeout(this.timeoutHandle)\n      this.timeoutHandle = null\n      this.scheduleHarvest(delay, opts)\n    } else if (!this.started && delay) {\n      // if not running on a timer, schedule a single retry\n      this.scheduleHarvest(delay, opts)\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar single = require(19)\nvar mapOwn = require(44)\nvar timing = require(15)\nvar encode = require(7)\nvar stringify = require(22)\nvar submitData = require(23)\nvar reduce = require(47)\nvar aggregator = require(2)\nvar stopwatch = require(21)\nvar locationUtil = require(13)\nvar config = require(39)\n\nvar cleanURL = require(5)\n\nvar version = 'DEVELOPMENT'\nvar jsonp = 'NREUM.setToken'\nvar _events = {}\nvar haveSendBeacon = !!navigator.sendBeacon\nvar tooManyRequestsDelay = config.getConfiguration('harvest.tooManyRequestsDelay') || 60\nvar scheme = (config.getConfiguration('ssl') === false) ? 'http' : 'https'\n\n// requiring ie version updates the IE version on the loader object\nvar ieVersion = require(11)\nvar xhrUsable = ieVersion > 9 || ieVersion === 0\n\nvar addPaintMetric = require(16).addMetric\n\nmodule.exports = {\n  sendRUM: single(sendRUM), // wrapping this in single makes it so that it can only be called once from outside\n  sendFinal: sendAllFromUnload,\n  pingErrors: pingErrors,\n  sendX: sendX,\n  send: send,\n  on: on,\n  xhrUsable: xhrUsable,\n  resetListeners: resetListeners,\n  getSubmitMethod: getSubmitMethod\n}\n\n// nr is injected into all send methods. This allows for easier testing\n// we could require('loader') instead\nfunction sendRUM (nr) {\n  if (!nr.info.beacon) return\n  if (nr.info.queueTime) aggregator.store('measures', 'qt', { value: nr.info.queueTime })\n  if (nr.info.applicationTime) aggregator.store('measures', 'ap', { value: nr.info.applicationTime })\n\n  // some time in the past some code will have called stopwatch.mark('starttime', Date.now())\n  // calling measure like this will create a metric that measures the time differential between\n  // the two marks.\n  stopwatch.measure('be', 'starttime', 'firstbyte')\n  stopwatch.measure('fe', 'firstbyte', 'onload')\n  stopwatch.measure('dc', 'firstbyte', 'domContent')\n\n  var measuresMetrics = aggregator.get('measures')\n\n  var measuresQueryString = mapOwn(measuresMetrics, function (metricName, measure) {\n    return '&' + metricName + '=' + measure.params.value\n  }).join('')\n\n  if (measuresQueryString) {\n    // currently we only have one version of our protocol\n    // in the future we may add more\n    var protocol = '1'\n\n    var chunksForQueryString = [baseQueryString(nr)]\n\n    chunksForQueryString.push(measuresQueryString)\n\n    chunksForQueryString.push(encode.param('tt', nr.info.ttGuid))\n    chunksForQueryString.push(encode.param('us', nr.info.user))\n    chunksForQueryString.push(encode.param('ac', nr.info.account))\n    chunksForQueryString.push(encode.param('pr', nr.info.product))\n    chunksForQueryString.push(encode.param('af', mapOwn(nr.features, function (k) { return k }).join(',')))\n\n    if (window.performance && typeof (window.performance.timing) !== 'undefined') {\n      var navTimingApiData = ({\n        timing: timing.addPT(window.performance.timing, {}),\n        navigation: timing.addPN(window.performance.navigation, {})\n      })\n      chunksForQueryString.push(encode.param('perf', stringify(navTimingApiData)))\n    }\n\n    if (window.performance && window.performance.getEntriesByType) {\n      var entries = window.performance.getEntriesByType('paint')\n      if (entries && entries.length > 0) {\n        entries.forEach(function(entry) {\n          if (!entry.startTime || entry.startTime <= 0) return\n\n          if (entry.name === 'first-paint') {\n            chunksForQueryString.push(encode.param('fp',\n              String(Math.floor(entry.startTime))))\n          } else if (entry.name === 'first-contentful-paint') {\n            chunksForQueryString.push(encode.param('fcp',\n              String(Math.floor(entry.startTime))))\n          }\n          addPaintMetric(entry.name, Math.floor(entry.startTime))\n        })\n      }\n    }\n\n    chunksForQueryString.push(encode.param('xx', nr.info.extra))\n    chunksForQueryString.push(encode.param('ua', nr.info.userAttributes))\n    chunksForQueryString.push(encode.param('at', nr.info.atts))\n\n    var customJsAttributes = stringify(nr.info.jsAttributes)\n    chunksForQueryString.push(encode.param('ja', customJsAttributes === '{}' ? null : customJsAttributes))\n\n    var queryString = encode.fromArray(chunksForQueryString, nr.maxBytes)\n\n    submitData.jsonp(\n      scheme + '://' + nr.info.beacon + '/' + protocol + '/' + nr.info.licenseKey + queryString,\n      jsonp\n    )\n  }\n}\n\nfunction sendAllFromUnload (nr) {\n  var sents = mapOwn(_events, function (endpoint) {\n    return sendX(endpoint, nr, { unload: true })\n  })\n  return reduce(sents, or)\n}\n\nfunction or (a, b) { return a || b }\n\nfunction createPayload (type, options) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  var listeners = (_events[type] && _events[type] || [])\n\n  for (var i = 0; i < listeners.length; i++) {\n    var singlePayload = listeners[i](options)\n    if (!singlePayload) continue\n    if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n    if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n  }\n  return { body: makeBody(), qs: makeQueryString() }\n}\n\n/**\n * Initiate a harvest from multiple sources. An event that corresponds to the endpoint\n * name is emitted, which gives any listeners the opportunity to provide payload data.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction sendX (endpoint, nr, opts, cbFinished) {\n  var submitMethod = getSubmitMethod(endpoint, opts)\n  if (!submitMethod) return false\n  var options = {\n    retry: submitMethod.method === submitData.xhr\n  }\n  return _send(endpoint, nr, createPayload(endpoint, options), opts, submitMethod, cbFinished)\n}\n\n/**\n * Initiate a harvest call.\n *\n * @param {string} endpoint - The endpoint of the harvest (jserrors, events, resources etc.)\n * @param {object} nr - The loader singleton.\n *\n * @param {object} singlePayload - Object representing payload.\n * @param {object} singlePayload.qs - Map of values that should be sent as part of the request query string.\n * @param {string} singlePayload.body - String that should be sent as the body of the request.\n * @param {string} singlePayload.body.e - Special case of body used for browser interactions.\n *\n * @param {object} opts\n * @param {bool} opts.needResponse - Specify whether the caller expects a response data.\n * @param {bool} opts.unload - Specify whether the call is a final harvest during page unload.\n */\nfunction send (endpoint, nr, singlePayload, opts, submitMethod, cbFinished) {\n  var makeBody = createAccumulator()\n  var makeQueryString = createAccumulator()\n  if (singlePayload.body) mapOwn(singlePayload.body, makeBody)\n  if (singlePayload.qs) mapOwn(singlePayload.qs, makeQueryString)\n\n  var payload = { body: makeBody(), qs: makeQueryString() }\n  return _send(endpoint, nr, payload, opts, submitMethod, cbFinished)\n}\n\nfunction _send (endpoint, nr, payload, opts, submitMethod, cbFinished) {\n  if (!nr.info.errorBeacon) return false\n\n  // custom metrics data (cm) is sent as a query parameter to /jserrors\n  if (!payload.body && !(endpoint === 'jserrors' && payload.qs && payload.qs.cm)) {\n    if (cbFinished) {\n      cbFinished({ sent: false })\n    }\n    return false\n  }\n\n  if (!opts) opts = {}\n\n  var url = scheme + '://' + nr.info.errorBeacon + '/' + endpoint + '/1/' + nr.info.licenseKey + baseQueryString(nr)\n  if (payload.qs) url += encode.obj(payload.qs, nr.maxBytes)\n\n  if (!submitMethod) {\n    submitMethod = getSubmitMethod(endpoint, opts)\n  }\n  var method = submitMethod.method\n  var useBody = submitMethod.useBody\n\n  var body\n  var fullUrl = url\n  if (useBody && endpoint === 'events') {\n    body = payload.body.e\n  } else if (useBody) {\n    body = stringify(payload.body)\n  } else {\n    fullUrl = url + encode.obj(payload.body, nr.maxBytes)\n  }\n\n  var result = method(fullUrl, body)\n\n  if (cbFinished && method === submitData.xhr) {\n    var xhr = result\n    xhr.addEventListener('load', function () {\n      var result = { sent: true }\n      if (this.status === 429) {\n        result.retry = true\n        result.delay = tooManyRequestsDelay\n      } else if (this.status === 408 || this.status === 500 || this.status === 503) {\n        result.retry = true\n      }\n\n      if (opts.needResponse) {\n        result.responseText = this.responseText\n      }\n      cbFinished(result)\n    }, false)\n  }\n\n  // if beacon request failed, retry with an alternative method\n  if (!result && method === submitData.beacon) {\n    method = submitData.img\n    result = method(url + encode.obj(payload.body, nr.maxBytes))\n  }\n\n  return result\n}\n\nfunction getSubmitMethod(endpoint, opts) {\n  opts = opts || {}\n  var method\n  var useBody\n\n  if (opts.needResponse) {\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else {\n      return false\n    }\n  } else if (opts.unload) {\n    useBody = haveSendBeacon\n    method = haveSendBeacon ? submitData.beacon : submitData.img\n  } else {\n    // `submitData.beacon` was removed, there is an upper limit to the\n    // number of data allowed before it starts failing, so we save it for\n    // unload data\n    if (xhrUsable) {\n      useBody = true\n      method = submitData.xhr\n    } else if (endpoint === 'events' || endpoint === 'jserrors') {\n      method = submitData.img\n    } else {\n      return false\n    }\n  }\n\n  return {\n    method: method,\n    useBody: useBody\n  }\n}\n\nfunction pingErrors (nr) {\n  if (scheme === 'http' || !(nr && nr.info && nr.info.errorBeacon && nr.ieVersion)) return\n\n  var url = 'https://' + nr.info.errorBeacon + '/jserrors/ping/' + nr.info.licenseKey + baseQueryString(nr)\n\n  submitData.img(url)\n}\n\n// Constructs the transaction name param for the beacon URL.\n// Prefers the obfuscated transaction name over the plain text.\n// Falls back to making up a name.\nfunction transactionNameParam (nr) {\n  if (nr.info.transactionName) return encode.param('to', nr.info.transactionName)\n  return encode.param('t', nr.info.tNamePlain || 'Unnamed Transaction')\n}\n\nfunction on (type, listener) {\n  var listeners = (_events[type] || (_events[type] = []))\n  listeners.push(listener)\n}\n\nfunction resetListeners() {\n  mapOwn(_events, function(key) {\n    _events[key] = []\n  })\n}\n\n// The stuff that gets sent every time.\nfunction baseQueryString (nr) {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  return ([\n    '?a=' + nr.info.applicationID,\n    encode.param('sa', (nr.info.sa ? '' + nr.info.sa : '')),\n    encode.param('v', version),\n    transactionNameParam(nr),\n    encode.param('ct', nr.customTransaction),\n    '&rst=' + nr.now(),\n    '&ck=' + (areCookiesEnabled ? '1' : '0'),\n    encode.param('ref', cleanURL(locationUtil.getLocation()))\n  ].join(''))\n}\n\n// returns a function that can be called to accumulate values to a single object\n// when the function is called without parameters, then the accumulator is returned\nfunction createAccumulator () {\n  var accumulator = {}\n  var hasData = false\n  return function (key, val) {\n    if (val && val.length) {\n      accumulator[key] = val\n      hasData = true\n    }\n    if (hasData) return accumulator\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar div = document.createElement('div')\n\ndiv.innerHTML = '<!--[if lte IE 6]><div></div><![endif]-->' +\n  '<!--[if lte IE 7]><div></div><![endif]-->' +\n  '<!--[if lte IE 8]><div></div><![endif]-->' +\n  '<!--[if lte IE 9]><div></div><![endif]-->'\n\nvar len = div.getElementsByTagName('div').length\n\nvar ieVersion\nif (len === 4) ieVersion = 6\nelse if (len === 3) ieVersion = 7\nelse if (len === 2) ieVersion = 8\nelse if (len === 1) ieVersion = 9\nelse ieVersion = 0\n\nmodule.exports = ieVersion\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stopwatch = require(21)\nvar subscribeToUnload = require(25)\nvar harvest = require(10)\nvar registerHandler = require(17)\nvar activateFeatures = require(8)\nvar loader = require(\"loader\")\nvar drain = require(6)\nvar navCookie = require(14)\nvar config = require(39)\n\n// api loads registers several event listeners, but does not have any exports\nrequire(3)\n\n// Register event listeners and schedule harvests for performance timings.\nrequire(24).init(loader, config.getConfiguration('page_view_timing'))\n\nvar autorun = typeof (window.NREUM.autorun) !== 'undefined' ? window.NREUM.autorun : true\n\n// Features are activated using the legacy setToken function name via JSONP\nwindow.NREUM.setToken = activateFeatures\n\nif (require(11) === 6) loader.maxBytes = 2000\nelse loader.maxBytes = 30000\n\nloader.releaseIds = {}\n\nsubscribeToUnload(finalHarvest)\n\nregisterHandler('mark', stopwatch.mark, 'api')\n\nstopwatch.mark('done')\n\ndrain('api')\n\nif (autorun) harvest.sendRUM(loader)\n\n// Set a cookie when the page unloads. Consume this cookie on the next page to get a 'start time'.\n// The navigation start time cookie is removed when the browser supports the web timing API.\n// Doesn't work in some browsers (Opera).\nfunction finalHarvest (e) {\n  harvest.sendFinal(loader, false)\n  // write navigation start time cookie if needed\n  navCookie.conditionallySet()\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getLocation: getLocation\n}\n\nfunction getLocation() {\n  return '' + location\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar sHash = require(18)\nvar startTime = require(20)\n\n// functions are on object, so that they can be mocked\nvar exp = {\n  conditionallySet: conditionallySet,\n  setCookie: setCookie\n}\n\nmodule.exports = exp\n\nfunction conditionallySet() {\n  var areCookiesEnabled = true\n  if ('init' in NREUM && 'privacy' in NREUM.init) {\n    areCookiesEnabled = NREUM.init.privacy.cookies_enabled\n  }\n\n  if (startTime.navCookie && areCookiesEnabled) {\n    exp.setCookie()\n  }\n}\n\nfunction setCookie() {\n  document.cookie = 'NREUM=s=' + Number(new Date()) + '&r=' + sHash(document.location.href) + '&p=' + sHash(document.referrer) + '; path=/'\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\n\nvar START = 'Start'\nvar END = 'End'\nvar UNLOAD_EVENT = 'unloadEvent'\nvar REDIRECT = 'redirect'\nvar DOMAIN_LOOKUP = 'domainLookup'\nvar ONNECT = 'onnect'\nvar REQUEST = 'request'\nvar RESPONSE = 'response'\nvar LOAD_EVENT = 'loadEvent'\nvar DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent'\n\nvar navTimingValues = []\nmodule.exports = {\n  addPT: addPT,\n  addPN: addPN,\n  nt: navTimingValues\n}\n\nfunction addPT (pt, v) {\n  var offset = pt['navigation' + START]\n  v.of = offset\n  addRel(offset, offset, v, 'n')\n  addRel(pt[UNLOAD_EVENT + START], offset, v, 'u')\n  addRel(pt[REDIRECT + START], offset, v, 'r')\n  addRel(pt[UNLOAD_EVENT + END], offset, v, 'ue')\n  addRel(pt[REDIRECT + END], offset, v, 're')\n  addRel(pt['fetch' + START], offset, v, 'f')\n  addRel(pt[DOMAIN_LOOKUP + START], offset, v, 'dn')\n  addRel(pt[DOMAIN_LOOKUP + END], offset, v, 'dne')\n  addRel(pt['c' + ONNECT + START], offset, v, 'c')\n  addRel(pt['secureC' + ONNECT + 'ion' + START], offset, v, 's')\n  addRel(pt['c' + ONNECT + END], offset, v, 'ce')\n  addRel(pt[REQUEST + START], offset, v, 'rq')\n  addRel(pt[RESPONSE + START], offset, v, 'rp')\n  addRel(pt[RESPONSE + END], offset, v, 'rpe')\n  addRel(pt.domLoading, offset, v, 'dl')\n  addRel(pt.domInteractive, offset, v, 'di')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + START], offset, v, 'ds')\n  addRel(pt[DOM_CONTENT_LOAD_EVENT + END], offset, v, 'de')\n  addRel(pt.domComplete, offset, v, 'dc')\n  addRel(pt[LOAD_EVENT + START], offset, v, 'l')\n  addRel(pt[LOAD_EVENT + END], offset, v, 'le')\n  return v\n}\n\n// Add Performance Navigation values to the given object\nfunction addPN (pn, v) {\n  addRel(pn.type, 0, v, 'ty')\n  addRel(pn.redirectCount, 0, v, 'rc')\n  return v\n}\n\nfunction addRel (value, offset, obj, prop) {\n  var relativeValue\n  if (typeof (value) === 'number' && (value > 0)) {\n    relativeValue = Math.round(value - offset)\n    obj[prop] = relativeValue\n  }\n  navTimingValues.push(relativeValue)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar paintMetrics = {}\n\nmodule.exports = {\n  addMetric: addMetric,\n  metrics: paintMetrics\n}\n\nfunction addMetric (name, value) {\n  paintMetrics[name] = value\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar handleEE = require(\"handle\").ee\n\nmodule.exports = defaultRegister\n\ndefaultRegister.on = registerWithSpecificEmitter\n\nvar handlers = defaultRegister.handlers = {}\n\nfunction defaultRegister (type, handler, group, ee) {\n  registerWithSpecificEmitter(ee || handleEE, type, handler, group)\n}\n\nfunction registerWithSpecificEmitter (ee, type, handler, group) {\n  if (!group) group = 'feature'\n  if (!ee) ee = handleEE\n  var groupHandlers = handlers[group] = handlers[group] || {}\n  var list = groupHandlers[type] = groupHandlers[type] || []\n  list.push([ee, handler])\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = sHash\n\nfunction sHash (s) {\n  var i\n  var h = 0\n\n  for (i = 0; i < s.length; i++) {\n    h += ((i + 1) * s.charCodeAt(i))\n  }\n  return Math.abs(h)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar slice = require(45)\n\nmodule.exports = single\n\nfunction single (fn) {\n  var called = false\n  var res\n\n  return function () {\n    if (called) return res\n    called = true\n    res = fn.apply(this, slice(arguments))\n    return res\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Use various techniques to determine the time at which this page started and whether to capture navigation timing information\n\nvar sHash = require(18)\nvar stopwatch = require(21)\nvar loader = require(\"loader\")\nvar ffVersion = require(41)\n\nmodule.exports = { navCookie: true }\n\nfindStartTime()\n\nfunction findStartTime () {\n  var starttime = findStartWebTiming() || findStartCookie()\n\n  if (!starttime) return\n\n  stopwatch.mark('starttime', starttime)\n  // Refine loader.offset\n  loader.offset = starttime\n}\n\n// Find the start time from the Web Timing 'performance' object.\n// http://test.w3.org/webperf/specs/NavigationTiming/\n// http://blog.chromium.org/2010/07/do-you-know-how-slow-your-web-page-is.html\nfunction findStartWebTiming () {\n  // FF 7/8 has a bug with the navigation start time, so use cookie instead of native interface\n  if (ffVersion && ffVersion < 9) return\n\n  var performanceCheck = require(46)\n  if (performanceCheck.exists) {\n    // note that we don't need to use a cookie to record navigation start time\n    module.exports.navCookie = false\n    return window.performance.timing.navigationStart\n  }\n}\n\n// Find the start time based on a cookie set by Episodes in the unload handler.\nfunction findStartCookie () {\n  var aCookies = document.cookie.split(' ')\n\n  for (var i = 0; i < aCookies.length; i++) {\n    if (aCookies[i].indexOf('NREUM=') === 0) {\n      var startPage\n      var referrerPage\n      var aSubCookies = aCookies[i].substring('NREUM='.length).split('&')\n      var startTime\n      var bReferrerMatch\n\n      for (var j = 0; j < aSubCookies.length; j++) {\n        if (aSubCookies[j].indexOf('s=') === 0) {\n          startTime = aSubCookies[j].substring(2)\n        } else if (aSubCookies[j].indexOf('p=') === 0) {\n          referrerPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (referrerPage.charAt(referrerPage.length - 1) === ';') {\n            referrerPage = referrerPage.substr(0, referrerPage.length - 1)\n          }\n        } else if (aSubCookies[j].indexOf('r=') === 0) {\n          startPage = aSubCookies[j].substring(2)\n          // if the sub-cookie is not the last cookie it will have a trailing ';'\n          if (startPage.charAt(startPage.length - 1) === ';') {\n            startPage = startPage.substr(0, startPage.length - 1)\n          }\n        }\n      }\n\n      if (startPage) {\n        var docReferrer = sHash(document.referrer)\n        bReferrerMatch = (docReferrer == startPage) // eslint-disable-line\n        if (!bReferrerMatch) {\n          // Navigation did not start at the page that was just exited, check for re-load\n          // (i.e. the page just exited is the current page and the referring pages match)\n          bReferrerMatch = sHash(document.location.href) == startPage && docReferrer == referrerPage // eslint-disable-line\n        }\n      }\n      if (bReferrerMatch && startTime) {\n        var now = new Date().getTime()\n        if ((now - startTime) > 60000) {\n          return\n        }\n        return startTime\n      }\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar aggregator = require(2)\nvar now = require(42)\n\nvar marks = {}\n\nmodule.exports = {\n  mark: mark,\n  measure: measure\n}\n\nfunction mark (markName, markTime) {\n  if (typeof markTime === 'undefined') markTime = (now() + now.offset)\n  marks[markName] = markTime\n}\n\nfunction measure (metricName, startMark, endMark) {\n  var start = marks[startMark]\n  var end = marks[endMark]\n\n  if (typeof start === 'undefined' || typeof end === 'undefined') return\n\n  aggregator.store('measures', metricName, { value: end - start })\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar mapOwn = require(44)\nvar ee = require(\"ee\")\n\nvar escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g // eslint-disable-line\nvar meta = {\n  '\\b': '\\\\b',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\f': '\\\\f',\n  '\\r': '\\\\r',\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\'\n}\n\nmodule.exports = stringify\n\nfunction stringify (val) {\n  try {\n    return str('', {'': val})\n  } catch (e) {\n    try {\n      ee.emit('internal-error', [e])\n    } catch (err) {\n    }\n  }\n}\n\nfunction quote (string) {\n  escapable.lastIndex = 0\n  return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n    var c = meta[a]\n    return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4)\n  }) + '\"' : '\"' + string + '\"'\n}\n\nfunction str (key, holder) {\n  var value = holder[key]\n\n  switch (typeof value) {\n    case 'string':\n      return quote(value)\n    case 'number':\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return String(value)\n    case 'object':\n      if (!value) { return 'null' }\n      var partial = []\n\n      // The value is an array. Stringify every element. Use null as a placeholder\n      // for non-JSON values.\n      if (value instanceof window.Array || Object.prototype.toString.apply(value) === '[object Array]') {\n        var length = value.length\n        for (var i = 0; i < length; i += 1) {\n          partial[i] = str(i, value) || 'null'\n        }\n\n        return partial.length === 0 ? '[]' : '[' + partial.join(',') + ']'\n      }\n\n      mapOwn(value, function (k) {\n        var v = str(k, value)\n        if (v) partial.push(quote(k) + ':' + v)\n      })\n\n      return partial.length === 0 ? '{}' : '{' + partial.join(',') + '}'\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar submitData = module.exports = {}\n\nsubmitData.jsonp = function jsonp (url, jsonp) {\n  var element = document.createElement('script')\n  element.type = 'text/javascript'\n  element.src = url + '&jsonp=' + jsonp\n  var firstScript = document.getElementsByTagName('script')[0]\n  firstScript.parentNode.insertBefore(element, firstScript)\n  return element\n}\n\nsubmitData.xhr = function xhr (url, body, sync) {\n  var request = new XMLHttpRequest()\n\n  request.open('POST', url, !sync)\n  try {\n    // Set cookie\n    if ('withCredentials' in request) request.withCredentials = true\n  } catch (e) {}\n\n  request.setRequestHeader('content-type', 'text/plain')\n  request.send(body)\n  return request\n}\n\nsubmitData.xhrSync = function xhrSync (url, body) {\n  return submitData.xhr(url, body, true)\n}\n\nsubmitData.img = function img (url) {\n  var element = new Image()\n  element.src = url\n  return element\n}\n\nsubmitData.beacon = function (url, body) {\n  return navigator.sendBeacon(url, body)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar nullable = require(4).nullable\nvar numeric = require(4).numeric\nvar getAddStringContext = require(4).getAddStringContext\nvar addCustomAttributes = require(4).addCustomAttributes\nvar now = require(42)\nvar mapOwn = require(44)\n\nvar loader = null\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar register = require(17)\nvar subscribeToUnload = require(25)\n\nvar timings = []\nvar timingsSent = []\nvar lcpRecorded = false\nvar lcp = null\nvar cls = null\nvar pageHideRecorded = false\n\nmodule.exports = {\n  getPayload: getPayload,\n  timings: timings,\n  init: init,\n  finalHarvest: finalHarvest\n}\n\nvar harvestTimeSeconds = 30\n\nfunction init(nr, options) {\n  if (!isEnabled(options)) return\n\n  loader = nr\n\n  if (!options) options = {}\n  var maxLCPTimeSeconds = options.maxLCPTimeSeconds || 60\n  var initialHarvestSeconds = options.initialHarvestSeconds || 10\n  harvestTimeSeconds = options.harvestTimeSeconds || 30\n\n  var scheduler = new HarvestScheduler(loader, 'events', { onFinished: onHarvestFinished, getPayload: prepareHarvest })\n\n  register('timing', processTiming)\n  register('lcp', updateLatestLcp)\n  register('cls', updateClsScore)\n  register('pageHide', updatePageHide)\n\n  // final harvest is initiated from the main agent module, but since harvesting\n  // here is not initiated by the harvester, we need to subscribe to the unload event\n  // separately\n  subscribeToUnload(finalHarvest)\n\n  // After 1 minute has passed, record LCP value if no user interaction has occurred first\n  setTimeout(function() {\n    recordLcp()\n    lcpRecorded = true\n  }, maxLCPTimeSeconds * 1000)\n\n  // send initial data sooner, then start regular\n  scheduler.startTimer(harvestTimeSeconds, initialHarvestSeconds)\n}\n\nfunction recordLcp() {\n  if (!lcpRecorded && lcp !== null) {\n    var lcpEntry = lcp[0]\n    var cls = lcp[1]\n\n    var attrs = {\n      'size': lcpEntry.size,\n      'eid': lcpEntry.id\n    }\n\n    if (cls) {\n      attrs['cls'] = cls\n    }\n\n    addTiming('lcp', Math.floor(lcpEntry.startTime), attrs, false)\n    lcpRecorded = true\n  }\n}\n\nfunction updateLatestLcp(lcpEntry) {\n  if (lcp) {\n    var previous = lcp[0]\n    if (previous.size >= lcpEntry.size) {\n      return\n    }\n  }\n  lcp = [lcpEntry, cls]\n}\n\nfunction updateClsScore(clsEntry) {\n  if (cls === null) {\n    cls = 0\n  }\n  cls += clsEntry.value\n}\n\nfunction updatePageHide(timestamp, state) {\n  if (!pageHideRecorded && state === 'hidden') {\n    addTiming('pageHide', timestamp, null, true)\n    pageHideRecorded = true\n  }\n}\n\nfunction recordUnload() {\n  addTiming('unload', now(), null, true)\n}\n\nfunction addTiming(name, value, attrs, addCls) {\n  attrs = attrs || {}\n\n  if (addCls && cls !== null) {\n    attrs['cls'] = cls\n  }\n\n  timings.push({\n    name: name,\n    value: value,\n    attrs: attrs\n  })\n}\n\nfunction processTiming(name, value, attrs) {\n  // Upon user interaction, the Browser stops executing LCP logic, so we can send here\n  // We're using setTimeout to give the Browser time to finish collecting LCP value\n  if (name === 'fi') {\n    setTimeout(recordLcp, 0)\n  }\n\n  addTiming(name, value, attrs, true)\n}\n\nfunction onHarvestFinished(result) {\n  if (result.retry && timingsSent.length > 0) {\n    for (var i = 0; i < timingsSent.length; i++) {\n      timings.push(timingsSent[i])\n    }\n    timingsSent = []\n  }\n}\n\nfunction finalHarvest() {\n  recordLcp()\n  recordUnload()\n  var payload = prepareHarvest({ retry: false })\n  harvest.send('events', loader, payload, { unload: true })\n}\n\nfunction appendGlobalCustomAttributes(timing) {\n  var timingAttributes = timing.attrs || {}\n  var customAttributes = loader.info.jsAttributes || {}\n\n  mapOwn(customAttributes, function (key, val) {\n    if (key !== 'size' && key !== 'eid' && key !== 'cls' && key !== 'type' && key !== 'fid') {\n      timingAttributes[key] = val\n    }\n  })\n}\n\n// serialize and return current timing data, clear and save current data for retry\nfunction prepareHarvest(options) {\n  if (timings.length === 0) return\n\n  var payload = getPayload(timings)\n  if (options.retry) {\n    for (var i = 0; i < timings.length; i++) {\n      timingsSent.push(timings[i])\n    }\n  }\n  timings = []\n  return { body: { e: payload } }\n}\n\n// serialize array of timing data\nfunction getPayload(data) {\n  var addString = getAddStringContext()\n\n  var payload = 'bel.6;'\n\n  for (var i = 0; i < data.length; i++) {\n    var timing = data[i]\n\n    payload += 'e,'\n    payload += addString(timing.name) + ','\n    payload += nullable(timing.value, numeric, false) + ','\n\n    appendGlobalCustomAttributes(timing)\n\n    var attrParts = addCustomAttributes(timing.attrs, addString)\n    if (attrParts && attrParts.length > 0) {\n      payload += numeric(attrParts.length) + ';' + attrParts.join(';')\n    }\n\n    if ((i + 1) < data.length) payload += ';'\n  }\n\n  return payload\n}\n\nfunction isEnabled(config) {\n  // collect page view timings unless the feature is explicitly disabled\n  if (config && config.enabled === false) {\n    return false\n  }\n  return true\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = require(41)\nvar single = require(19)\nvar addE = require(1)\n\nmodule.exports = subscribeToUnload\n\n// Used to subscribe a callback to when a page is being unloaded. This is used,\n// for example, to submit a final harvest.\nfunction subscribeToUnload (cb) {\n  var oneCall = single(cb)\n\n  // Firefox has a bug wherein a slow-loading resource loaded from the 'pagehide'\n  // or 'unload' event will delay the 'load' event firing on the next page load.\n  // In Firefox versions that support sendBeacon, this doesn't matter, because\n  // we'll use it instead of an image load for our final harvest.\n  //\n  // Some Safari versions never fire the 'unload' event for pages that are being\n  // put into the WebKit page cache, so we *need* to use the pagehide event for\n  // the final submission from Safari.\n  //\n  // Generally speaking, we will try to submit our final harvest from either\n  // pagehide or unload, whichever comes first, but in Firefox, we need to avoid\n  // attempting to submit from pagehide to ensure that we don't slow down loading\n  // of the next page.\n  if (!ffVersion || navigator.sendBeacon) {\n    addE('pagehide', oneCall)\n  } else {\n    addE('beforeunload', oneCall)\n  }\n  addE('unload', oneCall)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar canonicalFunctionNameRe = /([a-z0-9]+)$/i\nfunction canonicalFunctionName (orig) {\n  if (!orig) return\n\n  var match = orig.match(canonicalFunctionNameRe)\n  if (match) return match[1]\n\n  return\n}\n\nmodule.exports = canonicalFunctionName\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// computeStackTrace: cross-browser stack traces in JavaScript\n//\n// Syntax:\n//   s = computeStackTrace(exception) // consider using TraceKit.report instead\n// Returns:\n//   s.name              - exception name\n//   s.message           - exception message\n//   s.stack[i].url      - JavaScript or HTML file URL\n//   s.stack[i].func     - function name, or empty for anonymous functions\n//   s.stack[i].line     - line number, if known\n//   s.stack[i].column   - column number, if known\n//   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n//   s.mode              - 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace\n//\n// Supports:\n//   - Firefox:  full stack trace with line numbers and unreliable column\n//               number on top frame\n//   - Opera 10: full stack trace with line and column numbers\n//   - Opera 9-: full stack trace with line numbers\n//   - Chrome:   full stack trace with line and column numbers\n//   - Safari:   line and column number for the topmost stacktrace element\n//               only\n//   - IE:       no line numbers whatsoever\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n//\n// OPERA:\n// ex.message = ...message... (see the example below)\n// ex.name = ReferenceError\n// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\nvar reduce = require(47)\nvar formatStackTrace = require(28)\n\nvar has = Object.prototype.hasOwnProperty\nvar debug = false\n\nvar classNameRegex = /function (.+?)\\s*\\(/\nvar chrome = /^\\s*at (?:((?:\\[object object\\])?(?:[^(]*\\([^)]*\\))*[^()]*(?: \\[as \\S+\\])?) )?\\(?((?:file|http|https|chrome-extension):.*?)?:(\\d+)(?::(\\d+))?\\)?\\s*$/i\nvar gecko = /^\\s*(?:(\\S*|global code)(?:\\(.*?\\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\\d+)(?::(\\d+))?\\s*$/i\nvar chrome_eval = /^\\s*at .+ \\(eval at \\S+ \\((?:(?:file|http|https):[^)]+)?\\)(?:, [^:]*:\\d+:\\d+)?\\)$/i\nvar ie_eval = /^\\s*at Function code \\(Function code:\\d+:\\d+\\)\\s*/i\n\nmodule.exports = computeStackTrace\n\nfunction computeStackTrace (ex) {\n  var stack = null\n\n  try {\n    // This must be tried first because Opera 10 *destroys*\n    // its stacktrace property if you try to access the stack\n    // property first!!\n    stack = computeStackTraceFromStacktraceProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromStackProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromOperaMultiLineMessage(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceBySourceAndLine(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceWithMessageOnly(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  return {\n    'mode': 'failed',\n    'stackString': '',\n    'frames': []\n  }\n}\n\n/**\n * Computes stack trace information from the stack property.\n * Chrome and Gecko use this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStackProp (ex) {\n  if (!ex.stack) {\n    return null\n  }\n\n  var errorInfo = reduce(\n    ex.stack.split('\\n'),\n    parseStackProp,\n    {frames: [], stackLines: [], wrapperSeen: false}\n  )\n\n  if (!errorInfo.frames.length) return null\n\n  return {\n    'mode': 'stack',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(errorInfo.stackLines),\n    'frames': errorInfo.frames\n  }\n}\n\nfunction parseStackProp (info, line) {\n  var element = getElement(line)\n\n  if (!element) {\n    info.stackLines.push(line)\n    return info\n  }\n\n  if (isWrapper(element.func)) info.wrapperSeen = true\n  else info.stackLines.push(line)\n\n  if (!info.wrapperSeen) info.frames.push(element)\n  return info\n}\n\nfunction getElement (line) {\n  var parts = line.match(gecko)\n  if (!parts) parts = line.match(chrome)\n\n  if (parts) {\n    return ({\n      'url': parts[2],\n      'func': (parts[1] !== 'Anonymous function' && parts[1] !== 'global code' && parts[1]) || null,\n      'line': +parts[3],\n      'column': parts[4] ? +parts[4] : null\n    })\n  }\n\n  if (line.match(chrome_eval) || line.match(ie_eval) || line === 'anonymous') {\n    return { 'func': 'evaluated code' }\n  }\n}\n\nfunction computeStackTraceBySourceAndLine (ex) {\n  if (!('line' in ex)) return null\n\n  var className = ex.name || getClassName(ex)\n\n  // Safari does not provide a URL for errors in eval'd code\n  if (!ex.sourceURL) {\n    return ({\n      'mode': 'sourceline',\n      'name': className,\n      'message': ex.message,\n      'stackString': getClassName(ex) + ': ' + ex.message + '\\n    in evaluated code',\n      'frames': [{\n        'func': 'evaluated code'\n      }]\n    })\n  }\n\n  var stackString = className + ': ' + ex.message + '\\n    at ' + ex.sourceURL\n  if (ex.line) {\n    stackString += ':' + ex.line\n    if (ex.column) {\n      stackString += ':' + ex.column\n    }\n  }\n\n  return ({\n    'mode': 'sourceline',\n    'name': className,\n    'message': ex.message,\n    'stackString': stackString,\n    'frames': [{ 'url': ex.sourceURL,\n      'line': ex.line,\n      'column': ex.column\n    }]\n  })\n}\n\nfunction computeStackTraceWithMessageOnly (ex) {\n  var className = ex.name || getClassName(ex)\n  if (!className) return null\n\n  return ({\n    'mode': 'nameonly',\n    'name': className,\n    'message': ex.message,\n    'stackString': className + ': ' + ex.message,\n    'frames': []\n  })\n}\n\nfunction getClassName (obj) {\n  var results = classNameRegex.exec(String(obj.constructor))\n  return (results && results.length > 1) ? results[1] : 'unknown'\n}\n\nfunction isWrapper (functionName) {\n  return (functionName && functionName.indexOf('nrWrapper') >= 0)\n}\n\n/**\n * Computes stack trace information from the stacktrace property.\n * Opera 10 uses this property.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStacktraceProp (ex) {\n  if (!ex.stacktrace) {\n    return null\n  }\n\n  // Access and store the stacktrace property before doing anything\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = ex.stacktrace\n\n  var testRE = / line (\\d+), column (\\d+) in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\(.*\\) in (.*):\\s*$/i\n  var lines = stacktrace.split('\\n')\n  var frames = []\n  var stackLines = []\n  var parts\n  var wrapperSeen = false\n\n  for (var i = 0, j = lines.length; i < j; i += 2) {\n    if ((parts = testRE.exec(lines[i]))) {\n      var element = {\n        'line': +parts[1],\n        'column': +parts[2],\n        'func': parts[3] || parts[4],\n        'url': parts[5]\n      }\n\n      if (isWrapper(element.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(element)\n    } else {\n      stackLines.push(lines[i])\n    }\n  }\n\n  if (!frames.length) {\n    return null\n  }\n\n  return {\n    'mode': 'stacktrace',\n    'name': ex.name || getClassName(ex),\n    'message': ex.message,\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n/**\n * Computes stack trace information from an error message that includes\n * the stack trace.\n * Opera 9 and earlier use this method if the option to show stack\n * traces is turned on in opera:config.\n * @param {Error} ex\n * @return {?Object.<string, *>} Stack information.\n */\nfunction computeStackTraceFromOperaMultiLineMessage (ex) {\n  // Opera includes a stack trace into the exception message. An example is:\n  //\n  // Statement on line 3: Undefined variable: undefinedFunc\n  // Backtrace:\n  //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz\n  //         undefinedFunc(a)\n  //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy\n  //           zzz(x, y, z)\n  //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx\n  //           yyy(a, a, a)\n  //   Line 1 of function script\n  //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }\n  //   ...\n\n  var lines = ex.message.split('\\n')\n  if (lines.length < 4) {\n    return null\n  }\n\n  var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|http|https)\\S+)(?:: in function (\\S+))?\\s*$/i\n  var lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i\n  var frames = []\n  var stackLines = []\n  var scripts = document.getElementsByTagName('script')\n  var inlineScriptBlocks = []\n  var parts\n  var i\n  var len\n  var wrapperSeen = false\n\n  for (i in scripts) {\n    if (has.call(scripts, i) && !scripts[i].src) {\n      inlineScriptBlocks.push(scripts[i])\n    }\n  }\n\n  for (i = 2, len = lines.length; i < len; i += 2) {\n    var item = null\n    if ((parts = lineRE1.exec(lines[i]))) {\n      item = {\n        'url': parts[2],\n        'func': parts[3],\n        'line': +parts[1]\n      }\n    } else if ((parts = lineRE2.exec(lines[i]))) {\n      item = {\n        'url': parts[3],\n        'func': parts[4]\n      }\n    } else if ((parts = lineRE3.exec(lines[i]))) {\n      var url = window.location.href.replace(/#.*$/, '')\n      var line = parts[1]\n\n      item = {\n        'url': url,\n        'line': line,\n        'func': ''\n      }\n    }\n\n    if (item) {\n      if (isWrapper(item.func)) wrapperSeen = true\n      else stackLines.push(lines[i])\n\n      if (!wrapperSeen) frames.push(item)\n    }\n  }\n  if (!frames.length) {\n    return null // could not parse multiline exception message as Opera stack trace\n  }\n\n  return {\n    'mode': 'multiline',\n    'name': ex.name || getClassName(ex),\n    'message': lines[0],\n    'stackString': formatStackTrace(stackLines),\n    'frames': frames\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stripNewlinesRegex = /^\\n+|\\n+$/g\nvar MAX_STACK_TRACE_LENGTH = 65530\n\nmodule.exports = function (stackLines) {\n  return truncateStackLines(stackLines).replace(stripNewlinesRegex, '')\n}\n\nmodule.exports.truncateSize = truncateSize\n\n// takes array of stack lines and returns string with top 50 and buttom 50 lines\nfunction truncateStackLines(stackLines) {\n  var stackString\n  if (stackLines.length > 100) {\n    var truncatedLines = stackLines.length - 100\n    stackString = stackLines.slice(0, 50).join('\\n')\n    stackString += '\\n< ...truncated ' + truncatedLines + ' lines... >\\n'\n    stackString += stackLines.slice(-50).join('\\n')\n  } else {\n    stackString = stackLines.join('\\n')\n  }\n  return stackString\n}\n\n// truncates stack string to limit what is sent to backend\nfunction truncateSize(stackString) {\n  return (stackString.length > MAX_STACK_TRACE_LENGTH) ? stackString.substr(0, MAX_STACK_TRACE_LENGTH) : stackString\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar canonicalFunctionName = require(26)\nvar cleanURL = require(5)\nvar computeStackTrace = require(27)\nvar stringHashCode = require(30)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar stackReported = {}\nvar pageviewReported = {}\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar stringify = require(22)\nvar handle = require(\"handle\")\nvar baseEE = require(\"ee\")\nvar mapOwn = require(44)\nvar config = require(39)\nvar truncateSize = require(28).truncateSize\nvar errorCache = {}\nvar currentBody\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.err) return\nvar errorOnPage = false\n\nvar harvestTimeSeconds = config.getConfiguration('jserrors.harvestTimeSeconds') || 60\n\nee.on('feat-err', function () {\n  register('err', storeError)\n  register('ierr', storeError)\n\n  harvest.on('jserrors', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'jserrors', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds)\n})\n\nfunction onHarvestStarted(options) {\n  var body = agg.take([ 'err', 'ierr' ])\n\n  if (options.retry) {\n    currentBody = body\n  }\n\n  var payload = { body: body, qs: {} }\n  var releaseIds = stringify(loader.releaseIds)\n\n  if (releaseIds !== '{}') {\n    payload.qs.ri = releaseIds\n  }\n\n  if (body && body.err && body.err.length && !errorOnPage) {\n    payload.qs.pve = '1'\n    errorOnPage = true\n  }\n  return payload\n}\n\nfunction onHarvestFinished(result) {\n  if (!result.sent) {\n    // keep connection open\n    harvest.pingErrors(loader)\n  }\n\n  if (result.retry && currentBody) {\n    mapOwn(currentBody, function(key, value) {\n      for (var i = 0; i < value.length; i++) {\n        var bucket = value[i]\n        var name = getBucketName(bucket.params, bucket.custom)\n        agg.merge(key, name, bucket.metrics, bucket.params, bucket.custom)\n      }\n    })\n    currentBody = null\n  }\n}\n\n// open HTTPS connection, which is needed for sending data during page unload on older browsers\nharvest.pingErrors(loader)\n\nfunction nameHash (params) {\n  return stringHashCode(params.exceptionClass) ^ params.stackHash\n}\n\nfunction getBucketName(params, customParams) {\n  return nameHash(params) + ':' + stringHashCode(stringify(customParams))\n}\n\nfunction canonicalizeURL (url, cleanedOrigin) {\n  if (typeof url !== 'string') return ''\n\n  var cleanedURL = cleanURL(url)\n  if (cleanedURL === cleanedOrigin) {\n    return '<inline>'\n  } else {\n    return cleanedURL\n  }\n}\n\nfunction buildCanonicalStackString (stackInfo, cleanedOrigin) {\n  var canonicalStack = ''\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var func = canonicalFunctionName(frame.func)\n\n    if (canonicalStack) canonicalStack += '\\n'\n    if (func) canonicalStack += func + '@'\n    if (typeof frame.url === 'string') canonicalStack += frame.url\n    if (frame.line) canonicalStack += ':' + frame.line\n  }\n\n  return canonicalStack\n}\n\n// Strip query parameters and fragments from the stackString property of the\n// given stackInfo, along with the 'url' properties of each frame in\n// stackInfo.frames.\n//\n// Any URLs that are equivalent to the cleaned version of the origin will also\n// be replaced with the string '<inline>'.\n//\nfunction canonicalizeStackURLs (stackInfo) {\n  // Currently, loader.origin might contain a fragment, but we don't want to use it\n  // for comparing with frame URLs.\n  var cleanedOrigin = cleanURL(loader.origin)\n\n  for (var i = 0; i < stackInfo.frames.length; i++) {\n    var frame = stackInfo.frames[i]\n    var originalURL = frame.url\n    var cleanedURL = canonicalizeURL(originalURL, cleanedOrigin)\n    if (cleanedURL && cleanedURL !== frame.url) {\n      frame.url = cleanedURL\n      stackInfo.stackString = stackInfo.stackString.split(originalURL).join(cleanedURL)\n    }\n  }\n\n  return stackInfo\n}\n\nfunction storeError (err, time, internal, customAttributes) {\n  // are we in an interaction\n  time = time || loader.now()\n  if (!internal && loader.onerror && loader.onerror(err)) return\n\n  var stackInfo = canonicalizeStackURLs(computeStackTrace(err))\n  var canonicalStack = buildCanonicalStackString(stackInfo)\n\n  var params = {\n    stackHash: stringHashCode(canonicalStack),\n    exceptionClass: stackInfo.name,\n    request_uri: window.location.pathname\n  }\n  if (stackInfo.message) {\n    params.message = '' + stackInfo.message\n  }\n\n  if (!stackReported[params.stackHash]) {\n    stackReported[params.stackHash] = true\n    params.stack_trace = truncateSize(stackInfo.stackString)\n  } else {\n    params.browser_stack_hash = stringHashCode(stackInfo.stackString)\n  }\n  params.releaseIds = stringify(loader.releaseIds)\n\n  // When debugging stack canonicalization/hashing, uncomment these lines for\n  // more output in the test logs\n  // params.origStack = err.stack\n  // params.canonicalStack = canonicalStack\n\n  var hash = nameHash(params)\n\n  if (!pageviewReported[hash]) {\n    params.pageview = 1\n    pageviewReported[hash] = true\n  }\n\n  var type = internal ? 'ierr' : 'err'\n  var newMetrics = { time: time }\n\n  // stn and spa aggregators listen to this event - stn sends the error in its payload,\n  // and spa annotates the error with interaction info\n  handle('errorAgg', [type, hash, params, newMetrics])\n\n  if (params._interactionId != null) {\n    // hold on to the error until the interaction finishes\n    errorCache[params._interactionId] = errorCache[params._interactionId] || []\n    errorCache[params._interactionId].push([type, hash, params, newMetrics, att, customAttributes])\n  } else {\n    // store custom attributes\n    var customParams = {}\n    var att = loader.info.jsAttributes\n    mapOwn(att, setCustom)\n    if (customAttributes) {\n      mapOwn(customAttributes, setCustom)\n    }\n\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n    agg.store(type, aggregateHash, params, newMetrics, customParams)\n  }\n\n  function setCustom (key, val) {\n    customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nbaseEE.on('interactionSaved', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    params.browserInteractionId = interaction.root.attrs.id\n    delete params._interactionId\n\n    if (params._interactionNodeId) {\n      params.parentNodeId = params._interactionNodeId.toString()\n      delete params._interactionNodeId\n    }\n\n    var hash = item[1] + interaction.root.attrs.id\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, params, item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n\nbaseEE.on('interactionDiscarded', function (interaction) {\n  if (!errorCache[interaction.id]) return\n\n  errorCache[interaction.id].forEach(function (item) {\n    var customParams = {}\n    var globalCustomParams = item[4]\n    var localCustomParams = item[5]\n\n    mapOwn(globalCustomParams, setCustom)\n    mapOwn(interaction.root.attrs.custom, setCustom)\n    mapOwn(localCustomParams, setCustom)\n\n    var params = item[2]\n    delete params._interactionId\n    delete params._interactionNodeId\n\n    var hash = item[1]\n    var jsAttributesHash = stringHashCode(stringify(customParams))\n    var aggregateHash = hash + ':' + jsAttributesHash\n\n    agg.store(item[0], aggregateHash, item[2], item[3], customParams)\n\n    function setCustom (key, val) {\n      customParams[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  })\n  delete errorCache[interaction.id]\n})\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nfunction stringHashCode (string) {\n  var hash = 0\n  var charVal\n\n  if (!string || !string.length) return hash\n  for (var i = 0; i < string.length; i++) {\n    charVal = string.charCodeAt(i)\n    hash = ((hash << 5) - hash) + charVal\n    hash = hash | 0 // Convert to 32bit integer\n  }\n  return hash\n}\n\nmodule.exports = stringHashCode\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ee = require(\"ee\")\nvar loader = require(\"loader\")\nvar mapOwn = require(44)\nvar stringify = require(22)\nvar register = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar cleanURL = require(5)\nvar config = require(39)\n\nvar eventsPerMinute = 120\nvar harvestTimeSeconds = config.getConfiguration('ins.harvestTimeSeconds') || 30\nvar eventsPerHarvest = eventsPerMinute * harvestTimeSeconds / 60\nvar referrerUrl\nvar currentEvents\n\nvar events = []\nvar att = loader.info.jsAttributes = {}\n\nif (document.referrer) referrerUrl = cleanURL(document.referrer)\n\nregister('api-setCustomAttribute', setCustomAttribute, 'api')\n\nee.on('feat-ins', function () {\n  register('api-addPageAction', addPageAction)\n\n  harvest.on('ins', onHarvestStarted)\n  var scheduler = new HarvestScheduler(loader, 'ins', { onFinished: onHarvestFinished })\n  scheduler.startTimer(harvestTimeSeconds, 0)\n})\n\nfunction onHarvestStarted (options) {\n  var payload = ({\n    qs: {\n      ua: loader.info.userAttributes,\n      at: loader.info.atts\n    },\n    body: {\n      ins: events\n    }\n  })\n\n  if (options.retry) {\n    currentEvents = events\n  }\n\n  events = []\n  return payload\n}\n\nfunction onHarvestFinished (result) {\n  if (result && result.sent && result.retry && currentEvents) {\n    events = events.concat(currentEvents)\n    currentEvents = null\n  }\n}\n\n// WARNING: Insights times are in seconds. EXCEPT timestamp, which is in ms.\nfunction addPageAction (t, name, attributes) {\n  if (events.length >= eventsPerHarvest) return\n  var width\n  var height\n  var eventAttributes = {}\n\n  if (typeof window !== 'undefined' && window.document && window.document.documentElement) {\n    // Doesn't include the nav bar when it disappears in mobile safari\n    // https://github.com/jquery/jquery/blob/10399ddcf8a239acc27bdec9231b996b178224d3/src/dimensions.js#L23\n    width = window.document.documentElement.clientWidth\n    height = window.document.documentElement.clientHeight\n  }\n\n  var defaults = {\n    timestamp: t + loader.offset,\n    timeSinceLoad: t / 1000,\n    browserWidth: width,\n    browserHeight: height,\n    referrerUrl: referrerUrl,\n    currentUrl: cleanURL('' + location),\n    pageUrl: cleanURL(loader.origin),\n    eventType: 'PageAction'\n  }\n\n  mapOwn(defaults, set)\n  mapOwn(att, set)\n  if (attributes && typeof attributes === 'object') {\n    mapOwn(attributes, set)\n  }\n  eventAttributes.actionName = name || ''\n\n  events.push(eventAttributes)\n\n  function set (key, val) {\n    eventAttributes[key] = (val && typeof val === 'object' ? stringify(val) : val)\n  }\n}\n\nfunction setCustomAttribute (t, key, value) {\n  att[key] = value\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar baseEE = require(\"ee\")\nvar mapOwn = require(44)\nvar loader = require(\"loader\")\nvar InteractionNode = require(33)\n\nvar originals = NREUM.o\nvar originalSetTimeout = originals.ST\nvar originalClearTimeout = originals.CT\n\nvar REMAINING = 'remaining'\n\nvar lastId = 0\n\nmodule.exports = Interaction\n\nfunction Interaction (eventName, timestamp, url, routeName, onFinished) {\n  this.id = ++lastId\n  this.eventName = eventName\n  this.nodes = 0\n  this[REMAINING] = 0\n  this.finishTimer = null\n  this.checkingFinish = false\n  this.lastCb = this.lastFinish = timestamp\n  this.handlers = []\n  this.onFinished = onFinished\n\n  var root = this.root = new InteractionNode(this, null, 'interaction', timestamp)\n  var attrs = root.attrs\n\n  attrs.trigger = eventName\n  attrs.initialPageURL = loader.origin\n  attrs.oldRoute = routeName\n  attrs.newURL = attrs.oldURL = url\n  attrs.custom = {}\n  attrs.store = {}\n}\n\nvar InteractionPrototype = Interaction.prototype\n\nInteractionPrototype.checkFinish = function checkFinish (url, routeName) {\n  var interaction = this\n\n  if (interaction[REMAINING]) {\n    interaction._resetFinishCheck()\n    return\n  }\n\n  if (interaction.checkingFinish) {\n    return\n  }\n\n  interaction._resetFinishCheck()\n\n  var attrs = this.root.attrs\n  attrs.newURL = url\n  attrs.newRoute = routeName\n\n  interaction.checkingFinish = true\n  interaction.finishTimer = originalSetTimeout(function () {\n    interaction.checkingFinish = false\n    interaction.finishTimer = originalSetTimeout(function () {\n      interaction.finishTimer = null\n      if (!interaction[REMAINING]) interaction.finish()\n    }, 1)\n  }, 0)\n}\n\nInteractionPrototype.onNodeAdded = function onNodeAdded() {\n  this._resetFinishCheck()\n}\n\nInteractionPrototype._resetFinishCheck = function _resetFinishCheck() {\n  if (this.finishTimer) {\n    originalClearTimeout(this.finishTimer)\n    this.finishTimer = null\n    this.checkingFinish = false\n  }\n}\n\n// serialize report and remove nodes from map\nInteractionPrototype.finish = function finishInteraction () {\n  var interaction = this\n  var root = interaction.root\n  if (root.end) return\n  var endTimestamp = Math.max(interaction.lastCb, interaction.lastFinish)\n\n  var attrs = root.attrs\n  var customAttrs = attrs.custom\n\n  if (this.onFinished) {\n    this.onFinished(this)\n  }\n\n  mapOwn(loader.info.jsAttributes, function (attr, value) {\n    if (!(attr in customAttrs)) customAttrs[attr] = value\n  })\n\n  root.end = endTimestamp\n  baseEE.emit('interaction', [this])\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar INTERACTION = 'interaction'\nvar MAX_NODES = 128\nvar REMAINING = 'remaining'\n\nvar lastId = 0\n\nmodule.exports = InteractionNode\n\nfunction InteractionNode (interaction, parent, type, timestamp) {\n  this[INTERACTION] = interaction\n  this.parent = parent\n  this.id = ++lastId\n  this.type = type\n  this.children = []\n  this.end = null\n  this.jsEnd = this.start = timestamp\n  this.jsTime = 0\n  this.attrs = {}\n}\n\nvar InteractionNodePrototype = InteractionNode.prototype\n\n/**\n * @param {string} type\n * @param {number} timestamp\n * @param {string} name\n * @param {bool} dontWait - When true, the interaction will not immediately start waiting\n *                          for this node to complete. This is used when the creation of\n *                          the node and its start happen at different times (e.g. XHR).\n */\nInteractionNodePrototype.child = function child (type, timestamp, name, dontWait) {\n  var interaction = this[INTERACTION]\n  if (interaction.end || interaction.nodes >= MAX_NODES) return null\n\n  interaction.onNodeAdded(this)\n\n  var node = new InteractionNode(interaction, this, type, timestamp)\n  node.attrs.name = name\n  interaction.nodes++\n  if (!dontWait) interaction[REMAINING]++\n  return node\n}\n\nInteractionNodePrototype.callback = function addCallbackTime (exclusiveTime, end) {\n  var node = this\n\n  node.jsTime += exclusiveTime\n  if (end > node.jsEnd) {\n    node.jsEnd = end\n    node[INTERACTION].lastCb = end\n  }\n}\n\nInteractionNodePrototype.finish = function finish (timestamp) {\n  var node = this\n  if (node.end) return\n  node.end = timestamp\n  var parent = node.parent\n  while (parent.cancelled) parent = parent.parent\n  parent.children.push(node)\n  node.parent = null\n\n  var interaction = this[INTERACTION]\n  interaction[REMAINING]--\n  interaction.lastFinish = timestamp\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar register = require(17)\nvar parseUrl = require(38)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar serializer = require(35)\nvar loader = require(\"loader\")\nvar baseEE = require(\"ee\")\nvar mutationEE = baseEE.get('mutation')\nvar promiseEE = baseEE.get('promise')\nvar historyEE = baseEE.get('history')\nvar eventsEE = baseEE.get('events')\nvar timerEE = baseEE.get('timer')\nvar fetchEE = baseEE.get('fetch')\nvar jsonpEE = baseEE.get('jsonp')\nvar xhrEE = baseEE.get('xhr')\nvar tracerEE = baseEE.get('tracer')\nvar mapOwn = require(44)\nvar navTiming = require(15).nt\nvar dataSize = require(40)\nvar uniqueId = require(43)\nvar paintMetrics = require(16).metrics\nvar Interaction = require(32)\nvar config = require(39)\n\nvar INTERACTION_EVENTS = [\n  'click',\n  'submit',\n  'keypress',\n  'keydown',\n  'keyup',\n  'change'\n]\n\nvar MAX_TIMER_BUDGET = 999\nvar FN_START = 'fn-start'\nvar FN_END = 'fn-end'\nvar CB_START = 'cb-start'\nvar INTERACTION_API = 'api-ixn-'\nvar REMAINING = 'remaining'\nvar INTERACTION = 'interaction'\nvar SPA_NODE = 'spaNode'\nvar JSONP_NODE = 'jsonpNode'\nvar FETCH_START = 'fetch-start'\nvar FETCH_DONE = 'fetch-done'\nvar FETCH_BODY = 'fetch-body-'\nvar JSONP_END = 'jsonp-end'\n\nvar originals = NREUM.o\nvar origRequest = originals.REQ\nvar originalSetTimeout = originals.ST\nvar initialPageURL = loader.origin\nvar lastSeenUrl = initialPageURL\nvar lastSeenRouteName = null\n\nvar timerMap = {}\nvar timerBudget = MAX_TIMER_BUDGET\nvar currentNode = null\nvar prevNode = null\nvar nodeOnLastHashUpdate = null\nvar initialPageLoad = null\nvar pageLoaded = false\nvar childTime = 0\nvar depth = 0\n\nmodule.exports = function () {\n  return currentNode && currentNode.id\n}\n\n// childTime is used when calculating exclusive time for a cb duration.\n//\n// Exclusive time will be different than the total time for either callbacks\n// which synchronously invoke a customTracer callback or, trigger a synchronous\n// event (eg. onreadystate=1 or popstate).\n//\n// At fn-end, childTime will contain the total time of all timed callbacks and\n// event handlers which executed as a child of the current callback. At the\n// begining of every callback, childTime is saved to the event context (which at\n// that time contains the sum of its preceeding siblings) and is reset to 0. The\n// callback is then executed, and its children may increase childTime.  At the\n// end of the callback, it reports its exclusive time as its\n// execution time - exlcuded. childTime is then reset to its previous\n// value, and the totalTime of the callback that just finished executing is\n// added to the childTime time.\n//                                    | clock | childTime | ctx.ct | totalTime | exclusive |\n// click fn-start                     |   0   |    0     |    0   |           |           |\n//  | click begining:                 |   5   |    0     |    0   |           |           |\n//  |   | custom-1 fn-start           |   10  |    0     |    0   |           |           |\n//  |   |   |  custom-1 begining      |   15  |    0     |    0   |           |           |\n//  |   |   |    |  custom-2 fn-start |   20  |    0     |    0   |           |           |\n//  |   |   |    |  | custom-2        |   25  |    0     |    0   |           |           |\n//  |   |   |    |  custom-2 fn-end   |   30  |    10    |    0   |     10    |     10    |\n//  |   |   |  custom-1 middle        |   35  |    10    |    0   |           |           |\n//  |   |   |    |  custom-3 fn-start |   40  |    0     |    10  |           |           |\n//  |   |   |    |  | custom-3        |   45  |    0     |    10  |           |           |\n//  |   |   |    |  custom-3 fn-end   |   50  |    20    |    0   |     10    |     10    |\n//  |   |   |  custom-1 ending        |   55  |    20    |    0   |           |           |\n//  |     custom-1 fn-end             |   60  |    50    |    0   |     50    |     30    |\n//  | click ending:                   |   65  |    50    |        |           |           |\n// click fn-end                       |   70  |    0     |    0   |     70    |     20    |\n\nbaseEE.on('feat-spa', function () {\n  if (!isEnabled()) return\n\n  initialPageLoad = new Interaction('initialPageLoad', 0, lastSeenUrl, lastSeenRouteName, onInteractionFinished)\n  initialPageLoad.save = true\n  currentNode = initialPageLoad.root // hint\n  // ensure that checkFinish calls are safe during initialPageLoad\n  initialPageLoad[REMAINING]++\n\n  register.on(baseEE, FN_START, callbackStart)\n  register.on(promiseEE, CB_START, callbackStart)\n\n  // register plugins\n  var pluginApi = {\n    getCurrentNode: getCurrentNode,\n    setCurrentNode: setCurrentNode\n  }\n\n  register('spa-register', function(init) {\n    if (typeof init === 'function') {\n      init(pluginApi)\n    }\n  })\n\n  function callbackStart () {\n    depth++\n    this.prevNode = currentNode\n    this.ct = childTime\n    childTime = 0\n    timerBudget = MAX_TIMER_BUDGET\n  }\n\n  register.on(baseEE, FN_END, callbackEnd)\n  register.on(promiseEE, 'cb-end', callbackEnd)\n\n  function callbackEnd () {\n    depth--\n    var totalTime = this.jsTime || 0\n    var exclusiveTime = totalTime - childTime\n    childTime = this.ct + totalTime\n    if (currentNode) {\n      // transfer accumulated callback time to the active interaction node\n      // run even if jsTime is 0 to update jsEnd\n      currentNode.callback(exclusiveTime, this[FN_END])\n      if (this.isTraced) {\n        currentNode.attrs.tracedTime = exclusiveTime\n      }\n    }\n\n    this.jsTime = currentNode ? 0 : exclusiveTime\n    setCurrentNode(this.prevNode)\n    this.prevNode = null\n    timerBudget = MAX_TIMER_BUDGET\n  }\n\n  register.on(eventsEE, FN_START, function (args, eventSource) {\n    var ev = args[0]\n    var evName = ev.type\n    var eventNode = ev.__nrNode\n\n    if (!pageLoaded && evName === 'load' && eventSource === window) {\n      pageLoaded = true\n      // set to null so prevNode is set correctly\n      this.prevNode = currentNode = null\n      if (initialPageLoad) {\n        eventNode = initialPageLoad.root\n        initialPageLoad[REMAINING]--\n        originalSetTimeout(function () {\n          INTERACTION_EVENTS.push('popstate')\n        })\n      }\n    }\n\n    if (eventNode) {\n      // If we've already seen a previous handler for this specific event object,\n      // just restore that. We want multiple handlers for the same event to share\n      // a node.\n      setCurrentNode(eventNode)\n    } else if (evName === 'hashchange') {\n      setCurrentNode(nodeOnLastHashUpdate)\n      nodeOnLastHashUpdate = null\n    } else if (eventSource instanceof XMLHttpRequest) {\n      // If this event was emitted by an XHR, restore the node ID associated with\n      // that XHR.\n      setCurrentNode(baseEE.context(eventSource).spaNode)\n    } else if (!currentNode) {\n      // Otherwise, if no interaction is currently active, create a new node ID,\n      // and let the aggregator know that we entered a new event handler callback\n      // so that it has a chance to possibly start an interaction.\n      if (INTERACTION_EVENTS.indexOf(evName) !== -1) {\n        var ixn = new Interaction(evName, this[FN_START], lastSeenUrl, lastSeenRouteName, onInteractionFinished)\n        setCurrentNode(ixn.root)\n\n        if (evName === 'click') {\n          var value = getActionText(ev.target)\n          if (value) {\n            currentNode.attrs.custom['actionText'] = value\n          }\n        }\n      }\n    }\n\n    ev.__nrNode = currentNode\n  })\n\n  /**\n   * *** TIMERS ***\n   * setTimeout call needs to keep the interaction active in case a node is started\n   * in its callback.\n   */\n\n  // The context supplied to this callback will be shared with the fn-start/fn-end\n  // callbacks that fire around the callback passed to setTimeout originally.\n  register.on(timerEE, 'setTimeout-end', function saveId (args, obj, timerId) {\n    if (!currentNode || (timerBudget - this.timerDuration) < 0) return\n    currentNode[INTERACTION][REMAINING]++\n    this.timerId = timerId\n    timerMap[timerId] = currentNode\n    this.timerBudget = timerBudget - 50\n  })\n\n  register.on(timerEE, 'clearTimeout-start', function clear (args) {\n    var timerId = args[0]\n    var node = timerMap[timerId]\n    if (node) {\n      var interaction = node[INTERACTION]\n      interaction[REMAINING]--\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n      delete timerMap[timerId]\n    }\n  })\n\n  register.on(timerEE, FN_START, function () {\n    timerBudget = this.timerBudget || MAX_TIMER_BUDGET\n    var id = this.timerId\n    var node = timerMap[id]\n    setCurrentNode(node)\n    delete timerMap[id]\n    if (node) {\n      node[INTERACTION][REMAINING]--\n    }\n  })\n\n  /**\n   * *** XHR ***\n   * - `new-xhr` event is fired when new instance of XHR is created. Here we create\n   *    a new node and store it on the XHR object.\n   * -  When the send method is called (`send-xhr-start` event), we tell the interaction\n   *    to wait for this XHR to complete.\n   * -  When any direct event handlers are invoked (`fn-start` on the `xhr` emitter),\n   *    we restore the node in case other child nodes are started here.\n   * -  Callbacks attached using `addEventListener` are handled using `fn-start` on the\n   *    `events` emitter.\n   * -  When `xhr-resolved` is emitted, we end the node. The node.finish() call also\n   *    instructs the interaction to stop waiting for this node.\n   */\n\n  // context is shared with new-xhr event, and is stored on the xhr iteself.\n  register.on(xhrEE, FN_START, function () {\n    setCurrentNode(this[SPA_NODE])\n  })\n\n  // context is stored on the xhr and is shared with all callbacks associated\n  // with the new xhr\n  register.on(xhrEE, 'new-xhr', function () {\n    if (currentNode) {\n      this[SPA_NODE] = currentNode.child('ajax', null, null, true)\n    }\n  })\n\n  register.on(xhrEE, 'send-xhr-start', function () {\n    var node = this[SPA_NODE]\n    if (node && !this.sent) {\n      this.sent = true\n      node.dt = this.dt\n      node.jsEnd = node.start = this['send-xhr-start']\n      node[INTERACTION][REMAINING]++\n    }\n  })\n\n  register.on(baseEE, 'xhr-resolved', function () {\n    var node = this[SPA_NODE]\n    if (node) {\n      var attrs = node.attrs\n      attrs.params = this.params\n      attrs.metrics = this.metrics\n\n      node.finish(this['xhr-resolved'])\n    }\n  })\n\n  /**\n   * *** JSONP ***\n   *\n   */\n\n  register.on(jsonpEE, 'new-jsonp', function (url) {\n    if (currentNode) {\n      var node = this[JSONP_NODE] = currentNode.child('ajax', this[FETCH_START])\n      node.start = this['new-jsonp']\n      this.url = url\n      this.status = null\n    }\n  })\n\n  register.on(jsonpEE, 'cb-start', function (args) {\n    var node = this[JSONP_NODE]\n    if (node) {\n      setCurrentNode(node)\n      this.status = 200\n    }\n  })\n\n  register.on(jsonpEE, 'jsonp-error', function () {\n    var node = this[JSONP_NODE]\n    if (node) {\n      setCurrentNode(node)\n      this.status = 0\n    }\n  })\n\n  register.on(jsonpEE, JSONP_END, function () {\n    var node = this[JSONP_NODE]\n    if (node) {\n      // if no status is set then cb never fired - so it's not a valid JSONP\n      if (this.status === null) {\n        node[INTERACTION][REMAINING]--\n        node.cancelled = true\n        return\n      }\n      var attrs = node.attrs\n      var params = attrs.params = {}\n\n      var parsed = parseUrl(this.url)\n      params.method = 'GET'\n      params.pathname = parsed.pathname\n      params.host = parsed.hostname + ':' + parsed.port\n      params.status = this.status\n\n      attrs.metrics = {\n        txSize: 0,\n        rxSize: 0\n      }\n\n      attrs.isJSONP = true\n      node.jsEnd = this[JSONP_END]\n      node.jsTime = this[CB_START] ? (this[JSONP_END] - this[CB_START]) : 0\n      node.finish(node.jsEnd)\n    }\n  })\n\n  register.on(fetchEE, FETCH_START, function (fetchArguments, dtPayload) {\n    if (currentNode && fetchArguments) {\n      this[SPA_NODE] = currentNode.child('ajax', this[FETCH_START])\n      if (fetchArguments.length >= 1) this.target = fetchArguments[0]\n      if (fetchArguments.length >= 2) this.opts = fetchArguments[1]\n\n      if (dtPayload && this[SPA_NODE]) this[SPA_NODE].dt = dtPayload\n    }\n  })\n\n  register.on(fetchEE, FETCH_BODY + 'start', function (args) {\n    if (currentNode) {\n      this[SPA_NODE] = currentNode\n      currentNode[INTERACTION][REMAINING]++\n    }\n  })\n\n  register.on(fetchEE, FETCH_BODY + 'end', function (args, ctx, bodyPromise) {\n    var node = this[SPA_NODE]\n    if (node) {\n      node[INTERACTION][REMAINING]--\n    }\n  })\n\n  register.on(fetchEE, FETCH_DONE, function (err, res) {\n    var node = this[SPA_NODE]\n    var target = this.target\n    var opts = this.opts || {}\n    if (node) {\n      if (err) {\n        node.cancelled = true\n        node[INTERACTION][REMAINING]--\n        return\n      }\n\n      var url, method\n      if (typeof target === 'string') {\n        url = target\n      } else if (typeof target === 'object' && target instanceof origRequest) {\n        url = target.url\n      } else if (window.URL && typeof target === 'object' && target instanceof URL) {\n        url = target.href\n      }\n\n      method = ('' + ((target && target instanceof origRequest && target.method) || opts.method || 'GET')).toUpperCase()\n      var attrs = node.attrs\n      var params = attrs.params = {}\n\n      var parsed = parseUrl(url)\n      params.method = method\n      params.pathname = parsed.pathname\n      params.host = parsed.hostname + ':' + parsed.port\n      params.status = res.status\n\n      attrs.metrics = {\n        txSize: dataSize(opts.body) || 0,\n        rxSize: this.rxSize\n      }\n\n      attrs.isFetch = true\n\n      node.finish(this[FETCH_DONE])\n    }\n  })\n\n  register.on(historyEE, 'newURL', function (url, hashChangedDuringCb) {\n    if (currentNode) {\n      if (lastSeenUrl !== url) {\n        currentNode[INTERACTION].routeChange = true\n      }\n      if (hashChangedDuringCb) {\n        nodeOnLastHashUpdate = currentNode\n      }\n    }\n\n    lastSeenUrl = url\n  })\n\n  /**\n   * SCRIPTS\n   *   This is only needed to keep the interaction open while external scripts are being loaded.\n   *   The script that is loaded could continue the interaction by making additional AJAX\n   *   calls or changing the URL. The interaction context (currentNode) needs to be\n   *   restored somehow, but this differs based on the specific customer code. In some cases, we\n   *   could wrap a JSONP callback, in other cases we could wrap a higher-level API, and in\n   *   some cases we may not be able to restore context automatically (customer would need\n   *   to instrument their code manually).\n   *\n   * - We do not restore the original context in the load/error callbacks. This would not\n   *   work for the scripts themselves because by the time the load event fires, the\n   *   script content has already been executed.\n   */\n\n  // dom-start is emitted when appendChild or replaceChild are called. If the element being\n  // inserted is script and we are inside an interaction, we will keep the interaction open\n  // until the script is loaded.\n  jsonpEE.on('dom-start', function (args) {\n    if (!currentNode) return\n\n    var el = args[0]\n    var isScript = (el && el.nodeName === 'SCRIPT' && el.src !== '')\n    var interaction = currentNode.interaction\n\n    if (isScript) {\n      // increase remaining count to keep the interaction open\n      interaction[REMAINING]++\n      el.addEventListener('load', onload, false)\n      el.addEventListener('error', onerror, false)\n    }\n\n    function onload() {\n      // decrease remaining to allow interaction to finish\n      interaction[REMAINING]--\n\n      // checkFinish is what initiates closing interaction, but is only called\n      // when setCurrentNode is called. Since we are not restoring a node here,\n      // we need to initiate the check manually.\n      // The reason we are not restoring the node here is because 1) this is not\n      // where the code of the external script runs (by the time the load event\n      // fires, it has already executed), and 2) it would require storing the context\n      // probably on the DOM node and restoring in all callbacks, which is a different\n      // use case than lazy loading.\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n    }\n\n    function onerror() {\n      interaction[REMAINING]--\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n    }\n  })\n\n  register.on(mutationEE, FN_START, function () {\n    setCurrentNode(prevNode)\n  })\n\n  register.on(promiseEE, 'resolve-start', resolvePromise)\n  register.on(promiseEE, 'executor-err', resolvePromise)\n\n  register.on(promiseEE, 'propagate', saveNode)\n\n  register.on(promiseEE, CB_START, function () {\n    var ctx = this.getCtx ? this.getCtx() : this\n    setCurrentNode(ctx[SPA_NODE])\n  })\n\n  register(INTERACTION_API + 'get', function (t) {\n    var interaction = this.ixn = currentNode ? currentNode[INTERACTION] : new Interaction('api', t, lastSeenUrl, lastSeenRouteName, onInteractionFinished)\n\n    if (!currentNode) {\n      interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n      if (depth) setCurrentNode(interaction.root)\n    }\n  })\n\n  register(INTERACTION_API + 'actionText', function (t, actionText) {\n    var customAttrs = this.ixn.root.attrs.custom\n    if (actionText) customAttrs.actionText = actionText\n  })\n\n  register(INTERACTION_API + 'setName', function (t, name, trigger) {\n    var attrs = this.ixn.root.attrs\n    if (name) attrs.customName = name\n    if (trigger) attrs.trigger = trigger\n  })\n\n  register(INTERACTION_API + 'setAttribute', function (t, name, value) {\n    this.ixn.root.attrs.custom[name] = value\n  })\n\n  register(INTERACTION_API + 'end', function (timestamp) {\n    var interaction = this.ixn\n    var node = activeNodeFor(interaction)\n    setCurrentNode(null)\n    node.child('customEnd', timestamp).finish(timestamp)\n    interaction.finish()\n  })\n\n  register(INTERACTION_API + 'ignore', function () {\n    this.ixn.ignored = true\n  })\n\n  register(INTERACTION_API + 'save', function () {\n    this.ixn.save = true\n  })\n\n  register(INTERACTION_API + 'tracer', function (timestamp, name, store) {\n    var interaction = this.ixn\n    var parent = activeNodeFor(interaction)\n    var ctx = baseEE.context(store)\n    if (!name) {\n      ctx.inc = ++interaction[REMAINING]\n      return (ctx[SPA_NODE] = parent)\n    }\n    ctx[SPA_NODE] = parent.child('customTracer', timestamp, name)\n  })\n\n  register.on(tracerEE, FN_START, tracerDone)\n  register.on(tracerEE, 'no-' + FN_START, tracerDone)\n\n  function tracerDone (timestamp, interactionContext, hasCb) {\n    var node = this[SPA_NODE]\n    if (!node) return\n    var interaction = node[INTERACTION]\n    var inc = this.inc\n    this.isTraced = true\n    if (inc) {\n      interaction[REMAINING]--\n    } else if (node) {\n      node.finish(timestamp)\n    }\n    hasCb ? setCurrentNode(node) : interaction.checkFinish(lastSeenUrl, lastSeenRouteName)\n  }\n\n  register(INTERACTION_API + 'getContext', function (t, cb) {\n    var store = this.ixn.root.attrs.store\n    setTimeout(function () {\n      cb(store)\n    }, 0)\n  })\n\n  register(INTERACTION_API + 'onEnd', function (t, cb) {\n    this.ixn.handlers.push(cb)\n  })\n\n  register('api-routeName', function (t, currentRouteName) {\n    lastSeenRouteName = currentRouteName\n  })\n\n  function activeNodeFor (interaction) {\n    return (currentNode && currentNode[INTERACTION] === interaction) ? currentNode : interaction.root\n  }\n})\n\nfunction saveNode (val, overwrite) {\n  if (overwrite || !this[SPA_NODE]) this[SPA_NODE] = currentNode\n}\n\nfunction resolvePromise () {\n  if (!this.resolved) {\n    this.resolved = true\n    this[SPA_NODE] = currentNode\n  }\n}\n\nfunction getCurrentNode() {\n  return currentNode\n}\n\nfunction setCurrentNode (newNode) {\n  if (!pageLoaded && !newNode && initialPageLoad) newNode = initialPageLoad.root\n  if (currentNode) {\n    currentNode[INTERACTION].checkFinish(lastSeenUrl, lastSeenRouteName)\n  }\n\n  prevNode = currentNode\n  currentNode = (newNode && !newNode[INTERACTION].root.end) ? newNode : null\n}\n\nfunction onInteractionFinished(interaction) {\n  if (interaction === initialPageLoad) initialPageLoad = null\n\n  var root = interaction.root\n  var attrs = root.attrs\n\n  // make sure that newrelic[INTERACTION]() works in end handler\n  currentNode = root\n  mapOwn(interaction.handlers, function (i, cb) {\n    cb(attrs.store)\n  })\n  setCurrentNode(null)\n}\n\nvar harvestTimeSeconds = config.getConfiguration('spa.harvestTimeSeconds') || 10\nvar interactionsToHarvest = []\nvar interactionsSent = []\n\nvar scheduler = new HarvestScheduler(loader, 'events', { onFinished: onHarvestFinished, retryDelay: harvestTimeSeconds })\n\nharvest.on('events', onHarvestStarted)\n\nfunction onHarvestStarted(options) {\n  if (interactionsToHarvest.length === 0) return {}\n  var payload = serializer.serializeMultiple(interactionsToHarvest, 0, navTiming)\n\n  if (options.retry) {\n    interactionsToHarvest.forEach(function(interaction) {\n      interactionsSent.push(interaction)\n    })\n  }\n  interactionsToHarvest = []\n\n  return { body: { e: payload } }\n}\n\nfunction onHarvestFinished(result) {\n  if (result.sent && result.retry && interactionsSent.length > 0) {\n    interactionsSent.forEach(function(interaction) {\n      interactionsToHarvest.push(interaction)\n    })\n    interactionsSent = []\n  }\n}\n\nbaseEE.on('errorAgg', function (type, name, params, metrics) {\n  if (!currentNode) return\n  params._interactionId = currentNode.interaction.id\n  // do not capture parentNodeId when in root node\n  if (currentNode.type && currentNode.type !== 'interaction') {\n    params._interactionNodeId = currentNode.id\n  }\n})\n\nbaseEE.on('interaction', saveInteraction)\n\nfunction getActionText (node) {\n  var nodeType = node.tagName.toLowerCase()\n  var goodNodeTypes = ['a', 'button', 'input']\n  var isGoodNode = goodNodeTypes.indexOf(nodeType) !== -1\n  if (isGoodNode) {\n    return node.title || node.value || node.innerText\n  }\n}\n\nfunction saveInteraction (interaction) {\n  if (interaction.ignored || (!interaction.save && !interaction.routeChange)) {\n    baseEE.emit('interactionDiscarded', [interaction])\n    return\n  }\n\n  // assign unique id, this is serialized and used to link interactions with errors\n  interaction.root.attrs.id = uniqueId.generateUuid()\n\n  if (interaction.root.attrs.trigger === 'initialPageLoad') {\n    interaction.root.attrs.firstPaint = paintMetrics['first-paint']\n    interaction.root.attrs.firstContentfulPaint = paintMetrics['first-contentful-paint']\n  }\n  baseEE.emit('interactionSaved', [interaction])\n  interactionsToHarvest.push(interaction)\n  scheduler.scheduleHarvest(0)\n}\n\nfunction isEnabled() {\n  var configuration = config.getConfiguration('spa')\n  if (configuration && configuration.enabled === false) {\n    return false\n  }\n  return true\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar cleanURL = require(5)\nvar loader = require(\"loader\")\nvar mapOwn = require(44)\nvar nullable = require(4).nullable\nvar numeric = require(4).numeric\nvar getAddStringContext = require(4).getAddStringContext\nvar addCustomAttributes = require(4).addCustomAttributes\n\nmodule.exports = serializeSingle\nmodule.exports.serializeMultiple = serializeMultiple\n\nfunction serializeMultiple(interactions, offset, navTiming) {\n  var addString = getAddStringContext()\n  var serialized = 'bel.7'\n  interactions.forEach(function(interaction) {\n    serialized += ';' + serializeInteraction(interaction.root, offset, navTiming, interaction.routeChange, addString)\n  })\n  return serialized\n}\n\nfunction serializeSingle(root, offset, navTiming, isRouteChange) {\n  var addString = getAddStringContext()\n  return 'bel.7;' + serializeInteraction(root, offset, navTiming, isRouteChange, addString)\n}\n\nfunction serializeInteraction (root, offset, navTiming, isRouteChange, addString) {\n  offset = offset || 0\n  var isInitialPage = root.attrs.trigger === 'initialPageLoad'\n  var firstTimestamp\n  var typeIdsByName = {\n    interaction: 1,\n    ajax: 2,\n    customTracer: 4\n  }\n\n  // Include the hash fragment with all SPA data\n  var includeHashFragment = true\n\n  return addNode(root, []).join(';')\n\n  function addNode (node, nodeList) {\n    if (node.type === 'customEnd') return nodeList.push([3, numeric(node.end - firstTimestamp)])\n    var typeName = node.type\n    var typeId = typeIdsByName[typeName]\n    var startTimestamp = node.start\n    var childCount = node.children.length\n    var attrCount = 0\n    var apmAttributes = loader.info.atts\n    var hasNavTiming = isInitialPage && navTiming.length && typeId === 1\n    var children = []\n    var attrs = node.attrs\n    var metrics = attrs.metrics\n    var params = attrs.params\n    var queueTime = loader.info.queueTime\n    var appTime = loader.info.applicationTime\n\n    if (typeof firstTimestamp === 'undefined') {\n      startTimestamp += offset\n      firstTimestamp = startTimestamp\n    } else {\n      startTimestamp -= firstTimestamp\n    }\n\n    var fields = [\n      numeric(startTimestamp),\n      numeric(node.end - node.start),\n      numeric(node.jsEnd - node.end),\n      numeric(node.jsTime)\n    ]\n\n    switch (typeId) {\n      case 1:\n        fields[2] = numeric(node.jsEnd - firstTimestamp)\n        fields.push(\n          addString(attrs.trigger),\n          addString(cleanURL(attrs.initialPageURL, includeHashFragment)),\n          addString(cleanURL(attrs.oldURL, includeHashFragment)),\n          addString(cleanURL(attrs.newURL, includeHashFragment)),\n          addString(attrs.customName),\n          isInitialPage ? '' : isRouteChange ? 1 : 2,\n          nullable(isInitialPage && queueTime, numeric, true) +\n          nullable(isInitialPage && appTime, numeric, true) +\n          nullable(attrs.oldRoute, addString, true) +\n          nullable(attrs.newRoute, addString, true) +\n          addString(attrs.id),\n          addString(node.id),\n          nullable(attrs.firstPaint, numeric, true) +\n          nullable(attrs.firstContentfulPaint, numeric, false)\n        )\n\n        var attrParts = addCustomAttributes(attrs.custom, addString)\n        children = children.concat(attrParts)\n        attrCount = attrParts.length\n\n        if (apmAttributes) {\n          childCount++\n          children.push('a,' + addString(apmAttributes))\n        }\n\n        break\n\n      case 2:\n        fields.push(\n          addString(params.method),\n          numeric(params.status),\n          addString(params.host),\n          addString(params.pathname),\n          numeric(metrics.txSize),\n          numeric(metrics.rxSize),\n          attrs.isFetch ? 1 : (attrs.isJSONP ? 2 : ''),\n          addString(node.id),\n          nullable(node.dt && node.dt.spanId, addString, true) +\n          nullable(node.dt && node.dt.traceId, addString, true) +\n          nullable(node.dt && node.dt.timestamp, numeric, false)\n        )\n        break\n\n      case 4:\n        var tracedTime = attrs.tracedTime\n        fields.push(\n          addString(attrs.name),\n          nullable(tracedTime, numeric, true) +\n          addString(node.id)\n        )\n        break\n    }\n\n    for (var i = 0; i < node.children.length; i++) {\n      addNode(node.children[i], children)\n    }\n\n    fields.unshift(\n      numeric(typeId),\n      numeric(childCount += attrCount)\n    )\n\n    nodeList.push(fields)\n\n    if (childCount) {\n      nodeList.push(children.join(';'))\n    }\n\n    if (hasNavTiming) {\n      // this build up the navTiming node\n      // it for each navTiming value (pre aggregated in nav-timing.js):\n      // we initialize the seperator to ',' (seperates the nodeType id from the first value)\n      // we initialize the navTiming node to 'b' (the nodeType id)\n      // if the value is present:\n      //   we add the seperator followed by the value\n      // otherwise\n      //   we add null seperator ('!') to the navTimingNode\n      //   we set the seperator to an empty string since we already wrote it above\n      //   the reason for writing the null seperator instead of setting the seperator\n      //   is to ensure we still write it if the null is the last navTiming value.\n\n      var seperator = ','\n      var navTimingNode = 'b'\n      var prev = 0\n\n      // get all navTiming values except navigationStart\n      // (since its the same as interaction.start)\n      // and limit to just the first 20 values we know about\n      mapOwn(navTiming.slice(1, 21), function (i, v) {\n        if (v !== void 0) {\n          navTimingNode += seperator + numeric(v - prev)\n          seperator = ','\n          prev = v\n        } else {\n          navTimingNode += seperator + '!'\n          seperator = ''\n        }\n      })\n      nodeList.push(navTimingNode)\n    } else if (typeId === 1) {\n      nodeList.push('')\n    }\n\n    return nodeList\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar loader = require(\"loader\")\nvar registerHandler = require(17)\nvar harvest = require(10)\nvar HarvestScheduler = require(9)\nvar mapOwn = require(44)\nvar reduce = require(47)\nvar stringify = require(22)\nvar slice = require(45)\nvar parseUrl = require(38)\nvar config = require(39)\n\nif (!harvest.xhrUsable || !loader.xhrWrappable) return\n\nvar ptid = ''\nvar ignoredEvents = {mouseup: true, mousedown: true}\nvar toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n}\n\nvar rename = {\n  typing: {\n    keydown: true,\n    keyup: true,\n    keypress: true\n  },\n  mousing: {\n    mousemove: true,\n    mouseenter: true,\n    mouseleave: true,\n    mouseover: true,\n    mouseout: true\n  },\n  scrolling: {\n    scroll: true\n  },\n  touching: {\n    touchstart: true,\n    touchmove: true,\n    touchend: true,\n    touchcancel: true,\n    touchenter: true,\n    touchleave: true\n  }\n}\n\nvar trace = {}\nvar nodeCount = 0\nvar sentTrace = null\nvar harvestTimeSeconds = config.getConfiguration('stn.harvestTimeSeconds') || 10\nvar maxNodesPerHarvest = config.getConfiguration('stn.maxNodesPerHarvest') || 1000\n\nvar ee = require(\"ee\")\n\n// exports only used for testing\nmodule.exports = {\n  _takeSTNs: takeSTNs\n}\n\n// Make sure loader.offset is as accurate as possible\nrequire(20)\n\n// bail if not instrumented\nif (!loader.features.stn) return\n\nee.on('feat-stn', function () {\n  storeTiming(window.performance.timing)\n\n  harvest.on('resources', prepareHarvest)\n\n  var scheduler = new HarvestScheduler(loader, 'resources', { onFinished: onHarvestFinished, retryDelay: harvestTimeSeconds })\n  scheduler.runHarvest({ needResponse: true })\n\n  function onHarvestFinished(result) {\n    // start timer only if ptid was returned by server\n    if (result.sent && result.responseText && !ptid) {\n      ptid = result.responseText\n      scheduler.startTimer(harvestTimeSeconds)\n    }\n\n    if (result.sent && result.retry && sentTrace) {\n      mapOwn(sentTrace, function (name, nodes) {\n        mergeSTNs(name, nodes)\n      })\n      sentTrace = null\n    }\n  }\n\n  function prepareHarvest(options) {\n    if ((loader.now()) > (15 * 60 * 1000)) {\n      // been collecting for over 15 min, empty trace object and bail\n      scheduler.stopTimer()\n      trace = {}\n      return\n    }\n\n    // only send when there are more than 30 nodes to send\n    if (ptid && nodeCount <= 30) return\n\n    return takeSTNs(options.retry)\n  }\n\n  registerHandler('bst', storeEvent)\n  registerHandler('bstTimer', storeTimer)\n  registerHandler('bstResource', storeResources)\n  registerHandler('bstHist', storeHist)\n  registerHandler('bstXhrAgg', storeXhrAgg)\n  registerHandler('bstApi', storeSTN)\n  registerHandler('errorAgg', storeErrorAgg)\n})\n\nfunction storeTiming (_t) {\n  var key\n  var val\n  var timeOffset\n  var now = Date.now()\n\n  // loop iterates through prototype also (for FF)\n  for (key in _t) {\n    val = _t[key]\n\n    // ignore inherited methods, meaningless 0 values, and bogus timestamps\n    // that are in the future (Microsoft Edge seems to sometimes produce these)\n    if (!(typeof (val) === 'number' && val > 0 && val < now)) continue\n\n    timeOffset = _t[key] - loader.offset\n\n    storeSTN({\n      n: key,\n      s: timeOffset,\n      e: timeOffset,\n      o: 'document',\n      t: 'timing'\n    })\n  }\n}\n\nfunction storeTimer (target, start, end, type) {\n  var category = 'timer'\n  if (type === 'requestAnimationFrame') category = type\n\n  var evt = {\n    n: type,\n    s: start,\n    e: end,\n    o: 'window',\n    t: category\n  }\n\n  storeSTN(evt)\n}\n\nfunction storeEvent (currentEvent, target, start, end) {\n  // we find that certain events make the data too noisy to be useful\n  if (currentEvent.type in ignoredEvents) { return false }\n\n  var evt = {\n    n: evtName(currentEvent.type),\n    s: start,\n    e: end,\n    t: 'event'\n  }\n\n  try {\n    // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n    // it does not check currentEvent.currentTarget before calling getRootNode() on it\n    evt.o = evtOrigin(currentEvent.target, target)\n  } catch (e) {\n    evt.o = evtOrigin(null, target)\n  }\n\n  storeSTN(evt)\n}\n\nfunction evtName (type) {\n  var name = type\n\n  mapOwn(rename, function (key, val) {\n    if (type in val) name = key\n  })\n\n  return name\n}\n\nfunction evtOrigin (t, target) {\n  var origin = 'unknown'\n\n  if (t && t instanceof XMLHttpRequest) {\n    var params = ee.context(t).params\n    origin = params.status + ' ' + params.method + ': ' + params.host + params.pathname\n  } else if (t && typeof (t.tagName) === 'string') {\n    origin = t.tagName.toLowerCase()\n    if (t.id) origin += '#' + t.id\n    if (t.className) origin += '.' + slice(t.classList).join('.')\n  }\n\n  if (origin === 'unknown') {\n    if (target === document) origin = 'document'\n    else if (target === window) origin = 'window'\n    else if (target instanceof FileReader) origin = 'FileReader'\n  }\n\n  return origin\n}\n\nfunction storeHist (path, old, time) {\n  var node = {\n    n: 'history.pushState',\n    s: time,\n    e: time,\n    o: path,\n    t: old\n  }\n\n  storeSTN(node)\n}\n\nvar laststart = 0\n\nfunction storeResources (resources) {\n  resources.forEach(function (currentResource) {\n    var parsed = parseUrl(currentResource.name)\n    var res = {\n      n: currentResource.initiatorType,\n      s: currentResource.fetchStart | 0,\n      e: currentResource.responseEnd | 0,\n      o: parsed.protocol + '://' + parsed.hostname + ':' + parsed.port + parsed.pathname, // resource.name is actually a URL so it's the source\n      t: currentResource.entryType\n    }\n\n    // don't recollect old resources\n    if (res.s < laststart) return\n\n    laststart = res.s\n\n    storeSTN(res)\n  })\n}\n\nfunction storeErrorAgg (type, name, params, metrics) {\n  if (type !== 'err') return\n  var node = {\n    n: 'error',\n    s: metrics.time,\n    e: metrics.time,\n    o: params.message,\n    t: params.stackHash\n  }\n  storeSTN(node)\n}\n\nfunction storeXhrAgg (type, name, params, metrics) {\n  if (type !== 'xhr') return\n  var node = {\n    n: 'Ajax',\n    s: metrics.time,\n    e: metrics.time + metrics.duration,\n    o: params.status + ' ' + params.method + ': ' + params.host + params.pathname,\n    t: 'ajax'\n  }\n  storeSTN(node)\n}\n\nfunction storeSTN (stn) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[stn.n]\n  if (!traceArr) traceArr = trace[stn.n] = []\n\n  traceArr.push(stn)\n  nodeCount++\n}\n\nfunction mergeSTNs(key, nodes) {\n  // limit the number of data that is stored\n  if (nodeCount >= maxNodesPerHarvest) return\n\n  var traceArr = trace[key]\n  if (!traceArr) traceArr = trace[key] = []\n\n  trace[key] = nodes.concat(traceArr)\n  nodeCount += nodes.length\n}\n\nfunction takeSTNs (retry) {\n  storeResources(window.performance.getEntriesByType('resource'))\n  var stns = reduce(mapOwn(trace, function (name, nodes) {\n    if (!(name in toAggregate)) return nodes\n\n    return reduce(mapOwn(reduce(nodes.sort(byStart), smearEvtsByOrigin(name), {}), val), flatten, [])\n  }), flatten, [])\n\n  if (stns.length === 0) return {}\n\n  if (retry) {\n    sentTrace = trace\n  }\n  trace = {}\n  nodeCount = 0\n\n  var stnInfo = {\n    qs: {st: '' + loader.offset, ptid: ptid},\n    body: {res: stns}\n  }\n\n  if (!ptid) {\n    stnInfo.qs.ua = loader.info.userAttributes\n    stnInfo.qs.at = loader.info.atts\n    var ja = stringify(loader.info.jsAttributes)\n    stnInfo.qs.ja = ja === '{}' ? null : ja\n  }\n  return stnInfo\n}\n\nfunction byStart (a, b) {\n  return a.s - b.s\n}\n\nfunction smearEvtsByOrigin (name) {\n  var maxGap = toAggregate[name][0]\n  var maxLen = toAggregate[name][1]\n  var lastO = {}\n\n  return function (byOrigin, evt) {\n    var lastArr = byOrigin[evt.o]\n\n    lastArr || (lastArr = byOrigin[evt.o] = [])\n\n    var last = lastO[evt.o]\n\n    if (name === 'scrolling' && !trivial(evt)) {\n      lastO[evt.o] = null\n      evt.n = 'scroll'\n      lastArr.push(evt)\n    } else if (last && (evt.s - last.s) < maxLen && last.e > (evt.s - maxGap)) {\n      last.e = evt.e\n    } else {\n      lastO[evt.o] = evt\n      lastArr.push(evt)\n    }\n\n    return byOrigin\n  }\n}\n\nfunction val (key, value) {\n  return value\n}\n\nfunction flatten (a, b) {\n  return a.concat(b)\n}\n\nfunction trivial (node) {\n  var limit = 4\n  if (node && typeof node.e === 'number' && typeof node.s === 'number' && (node.e - node.s) < limit) return true\n  else return false\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar agg = require(2)\nvar register = require(17)\nvar harvest = require(10)\nvar stringify = require(22)\nvar loader = require(\"loader\")\nvar ee = require(\"ee\")\nvar handle = require(\"handle\")\n\n// bail if not instrumented\nif (!loader.features.xhr) return\n\nharvest.on('jserrors', function () {\n  return { body: agg.take([ 'xhr' ]) }\n})\n\nee.on('feat-err', function () { register('xhr', storeXhr) })\n\nmodule.exports = storeXhr\n\nfunction storeXhr (params, metrics, start) {\n  metrics.time = start\n\n  var type = 'xhr'\n  var hash\n  if (params.cat) {\n    hash = stringify([params.status, params.cat])\n  } else {\n    hash = stringify([params.status, params.host, params.pathname])\n  }\n\n  handle('bstXhrAgg', [type, hash, params, metrics])\n  agg.store(type, hash, params, metrics)\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stringsToParsedUrls = {}\n\nmodule.exports = function parseUrl (url) {\n  if (url in stringsToParsedUrls) {\n    return stringsToParsedUrls[url]\n  }\n\n  var urlEl = document.createElement('a')\n  var location = window.location\n  var ret = {}\n\n  // Use an anchor dom element to resolve the url natively.\n  urlEl.href = url\n\n  ret.port = urlEl.port\n\n  var firstSplit = urlEl.href.split('://')\n\n  if (!ret.port && firstSplit[1]) {\n    ret.port = firstSplit[1].split('/')[0].split('@').pop().split(':')[1]\n  }\n  if (!ret.port || ret.port === '0') ret.port = (firstSplit[0] === 'https' ? '443' : '80')\n\n  // Host not provided in IE for relative urls\n  ret.hostname = (urlEl.hostname || location.hostname)\n\n  ret.pathname = urlEl.pathname\n\n  ret.protocol = firstSplit[0]\n\n  // Pathname sometimes doesn't have leading slash (IE 8 and 9)\n  if (ret.pathname.charAt(0) !== '/') ret.pathname = '/' + ret.pathname\n\n  // urlEl.protocol is ':' in old ie when protocol is not specified\n  var sameProtocol = !urlEl.protocol || urlEl.protocol === ':' || urlEl.protocol === location.protocol\n  var sameDomain = urlEl.hostname === document.domain && urlEl.port === location.port\n\n  // urlEl.hostname is not provided by IE for relative urls, but relative urls are also same-origin\n  ret.sameOrigin = sameProtocol && (!urlEl.hostname || sameDomain)\n\n  // Only cache if url doesn't have a path\n  if (ret.pathname === '/') {\n    stringsToParsedUrls[url] = ret\n  }\n\n  return ret\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  getConfiguration: getConfiguration\n}\n\nfunction getConfiguration(path) {\n  if (!NREUM.init) return\n  var val = NREUM.init\n  var parts = path.split('.')\n  for (var i = 0; i < parts.length - 1; i++) {\n    val = val[parts[i]]\n    if (typeof val !== 'object') return\n  }\n  val = val[parts[parts.length - 1]]\n  return val\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = function dataSize (data) {\n  if (typeof data === 'string' && data.length) return data.length\n  if (typeof data !== 'object') return undefined\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer && data.byteLength) return data.byteLength\n  if (typeof Blob !== 'undefined' && data instanceof Blob && data.size) return data.size\n  if (typeof FormData !== 'undefined' && data instanceof FormData) return undefined\n\n  try {\n    return JSON.stringify(data).length\n  } catch (e) {\n    return undefined\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar ffVersion = 0\nvar match = navigator.userAgent.match(/Firefox[\\/\\s](\\d+\\.\\d+)/)\nif (match) ffVersion = +match[1]\n\nmodule.exports = ffVersion\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar lastTimestamp = new Date().getTime()\nvar offset = lastTimestamp\n\nvar performanceCheck = require(46)\n\nmodule.exports = now\nmodule.exports.offset = offset\nmodule.exports.getLastTimestamp = getLastTimestamp\n\nfunction now () {\n  if (performanceCheck.exists && performance.now) {\n    return Math.round(performance.now())\n  }\n  // ensure a new timestamp is never smaller than a previous timestamp\n  return (lastTimestamp = Math.max(new Date().getTime(), lastTimestamp)) - offset\n}\n\nfunction getLastTimestamp() {\n  return lastTimestamp\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  generateUuid: generateUuid,\n  generateSpanId: generateSpanId,\n  generateTraceId: generateTraceId\n}\n\nfunction generateUuid () {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n\n  // v4 UUID\n  var template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  var id = ''\n  var c\n  for (var i = 0; i < template.length; i++) {\n    c = template[i]\n    if (c === 'x') {\n      id += getRandomValue().toString(16)\n    } else if (c === 'y') {\n      // this is the uuid variant per spec (8, 9, a, b)\n      // % 4, then shift to get values 8-11\n      c = getRandomValue() & 0x3 | 0x8\n      id += c.toString(16)\n    } else {\n      id += c\n    }\n  }\n\n  return id\n}\n\n// 16-character hex string (per DT spec)\nfunction generateSpanId () {\n  return generateRandomHexString(16)\n}\n\n// 32-character hex string (per DT spec)\nfunction generateTraceId() {\n  return generateRandomHexString(32)\n}\n\nfunction generateRandomHexString(length) {\n  var randomVals = null\n  var rvIndex = 0\n  var crypto = window.crypto || window.msCrypto\n  if (crypto && crypto.getRandomValues && Uint8Array) {\n    randomVals = crypto.getRandomValues(new Uint8Array(31))\n  }\n\n  var chars = []\n  for (var i = 0; i < length; i++) {\n    chars.push(getRandomValue().toString(16))\n  }\n  return chars.join('')\n\n  function getRandomValue () {\n    if (randomVals) {\n      // same as % 16\n      return randomVals[rvIndex++] & 15\n    } else {\n      return Math.random() * 16 | 0\n    }\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\nmodule.exports = mapOwn\n\nfunction mapOwn (obj, fn) {\n  var results = []\n  var key = ''\n  var i = 0\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      results[i] = fn(key, obj[key])\n      i += 1\n    }\n  }\n\n  return results\n}\n","/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = {\n  exists: typeof (window.performance) !== 'undefined' && window.performance.timing && typeof (window.performance.timing.navigationStart) !== 'undefined'\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nmodule.exports = reduce\n\nfunction reduce (arr, fn, next) {\n  var i = 0\n  if (typeof next === 'undefined') {\n    next = arr[0]\n    i = 1\n  }\n\n  for (i; i < arr.length; i++) {\n    next = fn(next, arr[i])\n  }\n\n  return next\n}\n"]}